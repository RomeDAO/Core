{
  "0x6cddecd7d30197dc6a54bd2da9fb3e02606f5fc0aeda12dafa6ffbc34e1928b9": {
    "name": "RomeAuthority",
    "deployment": {
      "_format": "hh-sol-artifact-1",
      "contractName": "RomeAuthority",
      "sourceName": "src/RomeAuthority.sol",
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_governor",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_guardian",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_policy",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_vault",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "constructor"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "contract IRomeAuthority",
              "name": "authority",
              "type": "address"
            }
          ],
          "name": "AuthorityUpdated",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "to",
              "type": "address"
            }
          ],
          "name": "GovernorPulled",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bool",
              "name": "_effectiveImmediately",
              "type": "bool"
            }
          ],
          "name": "GovernorPushed",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "to",
              "type": "address"
            }
          ],
          "name": "GuardianPulled",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bool",
              "name": "_effectiveImmediately",
              "type": "bool"
            }
          ],
          "name": "GuardianPushed",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "to",
              "type": "address"
            }
          ],
          "name": "PolicyPulled",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bool",
              "name": "_effectiveImmediately",
              "type": "bool"
            }
          ],
          "name": "PolicyPushed",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "to",
              "type": "address"
            }
          ],
          "name": "VaultPulled",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bool",
              "name": "_effectiveImmediately",
              "type": "bool"
            }
          ],
          "name": "VaultPushed",
          "type": "event"
        },
        {
          "inputs": [],
          "name": "authority",
          "outputs": [
            {
              "internalType": "contract IRomeAuthority",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "governor",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "guardian",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "newGovernor",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "newGuardian",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "newPolicy",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "newVault",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "policy",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "pullGovernor",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "pullGuardian",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "pullPolicy",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "pullVault",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_newGovernor",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "_effectiveImmediately",
              "type": "bool"
            }
          ],
          "name": "pushGovernor",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_newGuardian",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "_effectiveImmediately",
              "type": "bool"
            }
          ],
          "name": "pushGuardian",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_newPolicy",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "_effectiveImmediately",
              "type": "bool"
            }
          ],
          "name": "pushPolicy",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_newVault",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "_effectiveImmediately",
              "type": "bool"
            }
          ],
          "name": "pushVault",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "contract IRomeAuthority",
              "name": "_newAuthority",
              "type": "address"
            }
          ],
          "name": "setAuthority",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "vault",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        }
      ],
      "bytecode": "0x60c0604052600c60808190526b15539055551213d49256915160a21b60a09081526200002f916000919062000248565b503480156200003d57600080fd5b50604051620012d6380380620012d6833981810160405260808110156200006357600080fd5b5080516020820151604080840151606090940151600180546001600160a01b0319163090811790915591519394929390919081907f2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad90600090a250600280546001600160a01b038087166001600160a01b031990921691909117918290556040805160018152905192909116916000917f4f337dcbb2512f18373c1f72d990a2f0a6ee5024b04007c52afd01eb73374a89919081900360200190a3600380546001600160a01b038086166001600160a01b031990921691909117918290556040805160018152905192909116916000917fde655975891e8f09671597b37bd4d663bcc5c21dc6d7641b33cdf85fbe15d08b919081900360200190a3600480546001600160a01b038085166001600160a01b031990921691909117918290556040805160018152905192909116916000917f90a5902a45c24aae553d5aff384ca16d6560f08d74c9784a4fbd2796d9e13f2b919081900360200190a3600580546001600160a01b038084166001600160a01b031990921691909117918290556040805160018152905192909116916000917f05a80f5053574d6a62733e1692e8cbcfaf927dc82df0a7267ea2e489a7cc18ff919081900360200190a350505050620002f4565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282620002805760008555620002cb565b82601f106200029b57805160ff1916838001178555620002cb565b82800160010185558215620002cb579182015b82811115620002cb578251825591602001919060010190620002ae565b50620002d9929150620002dd565b5090565b5b80821115620002d95760008155600101620002de565b610fd280620003046000396000f3fe608060405234801561001057600080fd5b50600436106101365760003560e01c80635beede08116100b25780638fd2057711610081578063bf7e214f11610066578063bf7e214f14610287578063d8a042121461028f578063fbfa77cf1461029757610136565b80638fd2057714610277578063be11f1dd1461027f57610136565b80635beede08146102135780636fe72c141461021b5780637a9e5e4b1461024957806388aaf0c81461026f57610136565b8063215e92bc11610109578063452a9320116100ee578063452a9320146101af57806352759694146101b757806354e3d703146101e557610136565b8063215e92bc1461019f5780633bf90c28146101a757610136565b80630505c8c91461013b5780630c340a241461015f57806319859847146101675780631afe87141461016f575b600080fd5b61014361029f565b604080516001600160a01b039092168252519081900360200190f35b6101436102ae565b6101436102bd565b61019d6004803603604081101561018557600080fd5b506001600160a01b03813516906020013515156102cc565b005b61019d6104c7565b6101436105bb565b6101436105ca565b61019d600480360360408110156101cd57600080fd5b506001600160a01b03813516906020013515156105d9565b61019d600480360360408110156101fb57600080fd5b506001600160a01b038135169060200135151561079a565b61019d61095b565b61019d6004803603604081101561023157600080fd5b506001600160a01b0381351690602001351515610a4f565b61019d6004803603602081101561025f57600080fd5b50356001600160a01b0316610c10565b610143610d78565b610143610d87565b61019d610d96565b610143610e8a565b61019d610e99565b610143610f8d565b6004546001600160a01b031681565b6002546001600160a01b031681565b6007546001600160a01b031681565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b15801561031a57600080fd5b505afa15801561032e573d6000803e3d6000fd5b505050506040513d602081101561034457600080fd5b50516000906001600160a01b0316331461040b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b820191906000526020600020905b8154815290600101906020018083116103df57829003601f168201915b50509250505060405180910390fd5b50801561044657600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600780546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560035460408051851515815290519383169391909216917fde655975891e8f09671597b37bd4d663bcc5c21dc6d7641b33cdf85fbe15d08b919081900360200190a35050565b6009546001600160a01b0316331461054057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f216e65775661756c740000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6009546005546040516001600160a01b0392831692909116907f3d08e01e3b8340be6ca709db7a9321448661a1f490da4d7f3eb03d84fe73095390600090a3600954600580547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b6008546001600160a01b031681565b6003546001600160a01b031681565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b15801561062757600080fd5b505afa15801561063b573d6000803e3d6000fd5b505050506040513d602081101561065157600080fd5b50516000906001600160a01b031633146106de576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b50801561071957600280547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600680546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560025460408051851515815290519383169391909216917f4f337dcbb2512f18373c1f72d990a2f0a6ee5024b04007c52afd01eb73374a89919081900360200190a35050565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b1580156107e857600080fd5b505afa1580156107fc573d6000803e3d6000fd5b505050506040513d602081101561081257600080fd5b50516000906001600160a01b0316331461089f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b5080156108da57600480547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600880546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560045460408051851515815290519383169391909216917f90a5902a45c24aae553d5aff384ca16d6560f08d74c9784a4fbd2796d9e13f2b919081900360200190a35050565b6008546001600160a01b031633146109d457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f216e6577506f6c69637900000000000000000000000000000000000000000000604482015290519081900360640190fd5b6008546004546040516001600160a01b0392831692909116907f64d2fa522b403ca222efff0c7ad07d2ef45472a45e5770918bdfa9a2845d29a890600090a3600854600480547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b158015610a9d57600080fd5b505afa158015610ab1573d6000803e3d6000fd5b505050506040513d6020811015610ac757600080fd5b50516000906001600160a01b03163314610b54576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b508015610b8f57600580547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600980546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560055460408051851515815290519383169391909216917f05a80f5053574d6a62733e1692e8cbcfaf927dc82df0a7267ea2e489a7cc18ff919081900360200190a35050565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b158015610c5e57600080fd5b505afa158015610c72573d6000803e3d6000fd5b505050506040513d6020811015610c8857600080fd5b50516000906001600160a01b03163314610d15576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b50600180547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0383169081179091556040517f2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad90600090a250565b6009546001600160a01b031681565b6006546001600160a01b031681565b6007546001600160a01b03163314610e0f57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f216e657747756172640000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6007546003546040516001600160a01b0392831692909116907f0960fb9900fb8096216606c4f7fc2fce5d08cc0c82da55cec8619b66b523848190600090a3600754600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b6001546001600160a01b031681565b6006546001600160a01b03163314610f1257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f216e6577476f7665726e6f720000000000000000000000000000000000000000604482015290519081900360640190fd5b6006546002546040516001600160a01b0392831692909116907fffd6fed33fe8ec1016718bdd5d04ae6fecd9aba0da6578807daaaa7fc3d1682690600090a3600654600280547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b6005546001600160a01b03168156fea2646970667358221220a33e88bd9811578012ad7813bdb3873418713dcd698aa1f936bec475f2a3f14d64736f6c63430007050033",
      "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101365760003560e01c80635beede08116100b25780638fd2057711610081578063bf7e214f11610066578063bf7e214f14610287578063d8a042121461028f578063fbfa77cf1461029757610136565b80638fd2057714610277578063be11f1dd1461027f57610136565b80635beede08146102135780636fe72c141461021b5780637a9e5e4b1461024957806388aaf0c81461026f57610136565b8063215e92bc11610109578063452a9320116100ee578063452a9320146101af57806352759694146101b757806354e3d703146101e557610136565b8063215e92bc1461019f5780633bf90c28146101a757610136565b80630505c8c91461013b5780630c340a241461015f57806319859847146101675780631afe87141461016f575b600080fd5b61014361029f565b604080516001600160a01b039092168252519081900360200190f35b6101436102ae565b6101436102bd565b61019d6004803603604081101561018557600080fd5b506001600160a01b03813516906020013515156102cc565b005b61019d6104c7565b6101436105bb565b6101436105ca565b61019d600480360360408110156101cd57600080fd5b506001600160a01b03813516906020013515156105d9565b61019d600480360360408110156101fb57600080fd5b506001600160a01b038135169060200135151561079a565b61019d61095b565b61019d6004803603604081101561023157600080fd5b506001600160a01b0381351690602001351515610a4f565b61019d6004803603602081101561025f57600080fd5b50356001600160a01b0316610c10565b610143610d78565b610143610d87565b61019d610d96565b610143610e8a565b61019d610e99565b610143610f8d565b6004546001600160a01b031681565b6002546001600160a01b031681565b6007546001600160a01b031681565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b15801561031a57600080fd5b505afa15801561032e573d6000803e3d6000fd5b505050506040513d602081101561034457600080fd5b50516000906001600160a01b0316331461040b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b820191906000526020600020905b8154815290600101906020018083116103df57829003601f168201915b50509250505060405180910390fd5b50801561044657600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600780546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560035460408051851515815290519383169391909216917fde655975891e8f09671597b37bd4d663bcc5c21dc6d7641b33cdf85fbe15d08b919081900360200190a35050565b6009546001600160a01b0316331461054057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f216e65775661756c740000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6009546005546040516001600160a01b0392831692909116907f3d08e01e3b8340be6ca709db7a9321448661a1f490da4d7f3eb03d84fe73095390600090a3600954600580547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b6008546001600160a01b031681565b6003546001600160a01b031681565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b15801561062757600080fd5b505afa15801561063b573d6000803e3d6000fd5b505050506040513d602081101561065157600080fd5b50516000906001600160a01b031633146106de576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b50801561071957600280547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600680546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560025460408051851515815290519383169391909216917f4f337dcbb2512f18373c1f72d990a2f0a6ee5024b04007c52afd01eb73374a89919081900360200190a35050565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b1580156107e857600080fd5b505afa1580156107fc573d6000803e3d6000fd5b505050506040513d602081101561081257600080fd5b50516000906001600160a01b0316331461089f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b5080156108da57600480547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600880546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560045460408051851515815290519383169391909216917f90a5902a45c24aae553d5aff384ca16d6560f08d74c9784a4fbd2796d9e13f2b919081900360200190a35050565b6008546001600160a01b031633146109d457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f216e6577506f6c69637900000000000000000000000000000000000000000000604482015290519081900360640190fd5b6008546004546040516001600160a01b0392831692909116907f64d2fa522b403ca222efff0c7ad07d2ef45472a45e5770918bdfa9a2845d29a890600090a3600854600480547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b158015610a9d57600080fd5b505afa158015610ab1573d6000803e3d6000fd5b505050506040513d6020811015610ac757600080fd5b50516000906001600160a01b03163314610b54576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b508015610b8f57600580547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600980546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560055460408051851515815290519383169391909216917f05a80f5053574d6a62733e1692e8cbcfaf927dc82df0a7267ea2e489a7cc18ff919081900360200190a35050565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b158015610c5e57600080fd5b505afa158015610c72573d6000803e3d6000fd5b505050506040513d6020811015610c8857600080fd5b50516000906001600160a01b03163314610d15576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b50600180547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0383169081179091556040517f2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad90600090a250565b6009546001600160a01b031681565b6006546001600160a01b031681565b6007546001600160a01b03163314610e0f57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f216e657747756172640000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6007546003546040516001600160a01b0392831692909116907f0960fb9900fb8096216606c4f7fc2fce5d08cc0c82da55cec8619b66b523848190600090a3600754600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b6001546001600160a01b031681565b6006546001600160a01b03163314610f1257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f216e6577476f7665726e6f720000000000000000000000000000000000000000604482015290519081900360640190fd5b6006546002546040516001600160a01b0392831692909116907fffd6fed33fe8ec1016718bdd5d04ae6fecd9aba0da6578807daaaa7fc3d1682690600090a3600654600280547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b6005546001600160a01b03168156fea2646970667358221220a33e88bd9811578012ad7813bdb3873418713dcd698aa1f936bec475f2a3f14d64736f6c63430007050033",
      "linkReferences": {},
      "deployedLinkReferences": {},
      "devdoc": {
        "kind": "dev",
        "methods": {},
        "version": 1
      },
      "evm": {
        "bytecode": {
          "generatedSources": [],
          "linkReferences": {},
          "object": "60c0604052600c60808190526b15539055551213d49256915160a21b60a09081526200002f916000919062000248565b503480156200003d57600080fd5b50604051620012d6380380620012d6833981810160405260808110156200006357600080fd5b5080516020820151604080840151606090940151600180546001600160a01b0319163090811790915591519394929390919081907f2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad90600090a250600280546001600160a01b038087166001600160a01b031990921691909117918290556040805160018152905192909116916000917f4f337dcbb2512f18373c1f72d990a2f0a6ee5024b04007c52afd01eb73374a89919081900360200190a3600380546001600160a01b038086166001600160a01b031990921691909117918290556040805160018152905192909116916000917fde655975891e8f09671597b37bd4d663bcc5c21dc6d7641b33cdf85fbe15d08b919081900360200190a3600480546001600160a01b038085166001600160a01b031990921691909117918290556040805160018152905192909116916000917f90a5902a45c24aae553d5aff384ca16d6560f08d74c9784a4fbd2796d9e13f2b919081900360200190a3600580546001600160a01b038084166001600160a01b031990921691909117918290556040805160018152905192909116916000917f05a80f5053574d6a62733e1692e8cbcfaf927dc82df0a7267ea2e489a7cc18ff919081900360200190a350505050620002f4565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282620002805760008555620002cb565b82601f106200029b57805160ff1916838001178555620002cb565b82800160010185558215620002cb579182015b82811115620002cb578251825591602001919060010190620002ae565b50620002d9929150620002dd565b5090565b5b80821115620002d95760008155600101620002de565b610fd280620003046000396000f3fe608060405234801561001057600080fd5b50600436106101365760003560e01c80635beede08116100b25780638fd2057711610081578063bf7e214f11610066578063bf7e214f14610287578063d8a042121461028f578063fbfa77cf1461029757610136565b80638fd2057714610277578063be11f1dd1461027f57610136565b80635beede08146102135780636fe72c141461021b5780637a9e5e4b1461024957806388aaf0c81461026f57610136565b8063215e92bc11610109578063452a9320116100ee578063452a9320146101af57806352759694146101b757806354e3d703146101e557610136565b8063215e92bc1461019f5780633bf90c28146101a757610136565b80630505c8c91461013b5780630c340a241461015f57806319859847146101675780631afe87141461016f575b600080fd5b61014361029f565b604080516001600160a01b039092168252519081900360200190f35b6101436102ae565b6101436102bd565b61019d6004803603604081101561018557600080fd5b506001600160a01b03813516906020013515156102cc565b005b61019d6104c7565b6101436105bb565b6101436105ca565b61019d600480360360408110156101cd57600080fd5b506001600160a01b03813516906020013515156105d9565b61019d600480360360408110156101fb57600080fd5b506001600160a01b038135169060200135151561079a565b61019d61095b565b61019d6004803603604081101561023157600080fd5b506001600160a01b0381351690602001351515610a4f565b61019d6004803603602081101561025f57600080fd5b50356001600160a01b0316610c10565b610143610d78565b610143610d87565b61019d610d96565b610143610e8a565b61019d610e99565b610143610f8d565b6004546001600160a01b031681565b6002546001600160a01b031681565b6007546001600160a01b031681565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b15801561031a57600080fd5b505afa15801561032e573d6000803e3d6000fd5b505050506040513d602081101561034457600080fd5b50516000906001600160a01b0316331461040b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b820191906000526020600020905b8154815290600101906020018083116103df57829003601f168201915b50509250505060405180910390fd5b50801561044657600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600780546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560035460408051851515815290519383169391909216917fde655975891e8f09671597b37bd4d663bcc5c21dc6d7641b33cdf85fbe15d08b919081900360200190a35050565b6009546001600160a01b0316331461054057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f216e65775661756c740000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6009546005546040516001600160a01b0392831692909116907f3d08e01e3b8340be6ca709db7a9321448661a1f490da4d7f3eb03d84fe73095390600090a3600954600580547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b6008546001600160a01b031681565b6003546001600160a01b031681565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b15801561062757600080fd5b505afa15801561063b573d6000803e3d6000fd5b505050506040513d602081101561065157600080fd5b50516000906001600160a01b031633146106de576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b50801561071957600280547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600680546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560025460408051851515815290519383169391909216917f4f337dcbb2512f18373c1f72d990a2f0a6ee5024b04007c52afd01eb73374a89919081900360200190a35050565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b1580156107e857600080fd5b505afa1580156107fc573d6000803e3d6000fd5b505050506040513d602081101561081257600080fd5b50516000906001600160a01b0316331461089f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b5080156108da57600480547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600880546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560045460408051851515815290519383169391909216917f90a5902a45c24aae553d5aff384ca16d6560f08d74c9784a4fbd2796d9e13f2b919081900360200190a35050565b6008546001600160a01b031633146109d457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f216e6577506f6c69637900000000000000000000000000000000000000000000604482015290519081900360640190fd5b6008546004546040516001600160a01b0392831692909116907f64d2fa522b403ca222efff0c7ad07d2ef45472a45e5770918bdfa9a2845d29a890600090a3600854600480547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b158015610a9d57600080fd5b505afa158015610ab1573d6000803e3d6000fd5b505050506040513d6020811015610ac757600080fd5b50516000906001600160a01b03163314610b54576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b508015610b8f57600580547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600980546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560055460408051851515815290519383169391909216917f05a80f5053574d6a62733e1692e8cbcfaf927dc82df0a7267ea2e489a7cc18ff919081900360200190a35050565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b158015610c5e57600080fd5b505afa158015610c72573d6000803e3d6000fd5b505050506040513d6020811015610c8857600080fd5b50516000906001600160a01b03163314610d15576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b50600180547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0383169081179091556040517f2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad90600090a250565b6009546001600160a01b031681565b6006546001600160a01b031681565b6007546001600160a01b03163314610e0f57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f216e657747756172640000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6007546003546040516001600160a01b0392831692909116907f0960fb9900fb8096216606c4f7fc2fce5d08cc0c82da55cec8619b66b523848190600090a3600754600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b6001546001600160a01b031681565b6006546001600160a01b03163314610f1257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f216e6577476f7665726e6f720000000000000000000000000000000000000000604482015290519081900360640190fd5b6006546002546040516001600160a01b0392831692909116907fffd6fed33fe8ec1016718bdd5d04ae6fecd9aba0da6578807daaaa7fc3d1682690600090a3600654600280547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b6005546001600160a01b03168156fea2646970667358221220a33e88bd9811578012ad7813bdb3873418713dcd698aa1f936bec475f2a3f14d64736f6c63430007050033",
          "opcodes": "PUSH1 0xC0 PUSH1 0x40 MSTORE PUSH1 0xC PUSH1 0x80 DUP2 SWAP1 MSTORE PUSH12 0x15539055551213D492569151 PUSH1 0xA2 SHL PUSH1 0xA0 SWAP1 DUP2 MSTORE PUSH3 0x2F SWAP2 PUSH1 0x0 SWAP2 SWAP1 PUSH3 0x248 JUMP JUMPDEST POP CALLVALUE DUP1 ISZERO PUSH3 0x3D JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x40 MLOAD PUSH3 0x12D6 CODESIZE SUB DUP1 PUSH3 0x12D6 DUP4 CODECOPY DUP2 DUP2 ADD PUSH1 0x40 MSTORE PUSH1 0x80 DUP2 LT ISZERO PUSH3 0x63 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP DUP1 MLOAD PUSH1 0x20 DUP3 ADD MLOAD PUSH1 0x40 DUP1 DUP5 ADD MLOAD PUSH1 0x60 SWAP1 SWAP5 ADD MLOAD PUSH1 0x1 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND ADDRESS SWAP1 DUP2 OR SWAP1 SWAP2 SSTORE SWAP2 MLOAD SWAP4 SWAP5 SWAP3 SWAP4 SWAP1 SWAP2 SWAP1 DUP2 SWAP1 PUSH32 0x2F658B440C35314F52658EA8A740E05B284CDC84DC9AE01E891F21B8933E7CAD SWAP1 PUSH1 0x0 SWAP1 LOG2 POP PUSH1 0x2 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP1 DUP8 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP2 DUP3 SWAP1 SSTORE PUSH1 0x40 DUP1 MLOAD PUSH1 0x1 DUP2 MSTORE SWAP1 MLOAD SWAP3 SWAP1 SWAP2 AND SWAP2 PUSH1 0x0 SWAP2 PUSH32 0x4F337DCBB2512F18373C1F72D990A2F0A6EE5024B04007C52AFD01EB73374A89 SWAP2 SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 LOG3 PUSH1 0x3 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP1 DUP7 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP2 DUP3 SWAP1 SSTORE PUSH1 0x40 DUP1 MLOAD PUSH1 0x1 DUP2 MSTORE SWAP1 MLOAD SWAP3 SWAP1 SWAP2 AND SWAP2 PUSH1 0x0 SWAP2 PUSH32 0xDE655975891E8F09671597B37BD4D663BCC5C21DC6D7641B33CDF85FBE15D08B SWAP2 SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 LOG3 PUSH1 0x4 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP1 DUP6 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP2 DUP3 SWAP1 SSTORE PUSH1 0x40 DUP1 MLOAD PUSH1 0x1 DUP2 MSTORE SWAP1 MLOAD SWAP3 SWAP1 SWAP2 AND SWAP2 PUSH1 0x0 SWAP2 PUSH32 0x90A5902A45C24AAE553D5AFF384CA16D6560F08D74C9784A4FBD2796D9E13F2B SWAP2 SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 LOG3 PUSH1 0x5 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP1 DUP5 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP2 DUP3 SWAP1 SSTORE PUSH1 0x40 DUP1 MLOAD PUSH1 0x1 DUP2 MSTORE SWAP1 MLOAD SWAP3 SWAP1 SWAP2 AND SWAP2 PUSH1 0x0 SWAP2 PUSH32 0x5A80F5053574D6A62733E1692E8CBCFAF927DC82DF0A7267EA2E489A7CC18FF SWAP2 SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 LOG3 POP POP POP POP PUSH3 0x2F4 JUMP JUMPDEST DUP3 DUP1 SLOAD PUSH1 0x1 DUP2 PUSH1 0x1 AND ISZERO PUSH2 0x100 MUL SUB AND PUSH1 0x2 SWAP1 DIV SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 KECCAK256 SWAP1 PUSH1 0x1F ADD PUSH1 0x20 SWAP1 DIV DUP2 ADD SWAP3 DUP3 PUSH3 0x280 JUMPI PUSH1 0x0 DUP6 SSTORE PUSH3 0x2CB JUMP JUMPDEST DUP3 PUSH1 0x1F LT PUSH3 0x29B JUMPI DUP1 MLOAD PUSH1 0xFF NOT AND DUP4 DUP1 ADD OR DUP6 SSTORE PUSH3 0x2CB JUMP JUMPDEST DUP3 DUP1 ADD PUSH1 0x1 ADD DUP6 SSTORE DUP3 ISZERO PUSH3 0x2CB JUMPI SWAP2 DUP3 ADD JUMPDEST DUP3 DUP2 GT ISZERO PUSH3 0x2CB JUMPI DUP3 MLOAD DUP3 SSTORE SWAP2 PUSH1 0x20 ADD SWAP2 SWAP1 PUSH1 0x1 ADD SWAP1 PUSH3 0x2AE JUMP JUMPDEST POP PUSH3 0x2D9 SWAP3 SWAP2 POP PUSH3 0x2DD JUMP JUMPDEST POP SWAP1 JUMP JUMPDEST JUMPDEST DUP1 DUP3 GT ISZERO PUSH3 0x2D9 JUMPI PUSH1 0x0 DUP2 SSTORE PUSH1 0x1 ADD PUSH3 0x2DE JUMP JUMPDEST PUSH2 0xFD2 DUP1 PUSH3 0x304 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x136 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x5BEEDE08 GT PUSH2 0xB2 JUMPI DUP1 PUSH4 0x8FD20577 GT PUSH2 0x81 JUMPI DUP1 PUSH4 0xBF7E214F GT PUSH2 0x66 JUMPI DUP1 PUSH4 0xBF7E214F EQ PUSH2 0x287 JUMPI DUP1 PUSH4 0xD8A04212 EQ PUSH2 0x28F JUMPI DUP1 PUSH4 0xFBFA77CF EQ PUSH2 0x297 JUMPI PUSH2 0x136 JUMP JUMPDEST DUP1 PUSH4 0x8FD20577 EQ PUSH2 0x277 JUMPI DUP1 PUSH4 0xBE11F1DD EQ PUSH2 0x27F JUMPI PUSH2 0x136 JUMP JUMPDEST DUP1 PUSH4 0x5BEEDE08 EQ PUSH2 0x213 JUMPI DUP1 PUSH4 0x6FE72C14 EQ PUSH2 0x21B JUMPI DUP1 PUSH4 0x7A9E5E4B EQ PUSH2 0x249 JUMPI DUP1 PUSH4 0x88AAF0C8 EQ PUSH2 0x26F JUMPI PUSH2 0x136 JUMP JUMPDEST DUP1 PUSH4 0x215E92BC GT PUSH2 0x109 JUMPI DUP1 PUSH4 0x452A9320 GT PUSH2 0xEE JUMPI DUP1 PUSH4 0x452A9320 EQ PUSH2 0x1AF JUMPI DUP1 PUSH4 0x52759694 EQ PUSH2 0x1B7 JUMPI DUP1 PUSH4 0x54E3D703 EQ PUSH2 0x1E5 JUMPI PUSH2 0x136 JUMP JUMPDEST DUP1 PUSH4 0x215E92BC EQ PUSH2 0x19F JUMPI DUP1 PUSH4 0x3BF90C28 EQ PUSH2 0x1A7 JUMPI PUSH2 0x136 JUMP JUMPDEST DUP1 PUSH4 0x505C8C9 EQ PUSH2 0x13B JUMPI DUP1 PUSH4 0xC340A24 EQ PUSH2 0x15F JUMPI DUP1 PUSH4 0x19859847 EQ PUSH2 0x167 JUMPI DUP1 PUSH4 0x1AFE8714 EQ PUSH2 0x16F JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x143 PUSH2 0x29F JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP3 AND DUP3 MSTORE MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 RETURN JUMPDEST PUSH2 0x143 PUSH2 0x2AE JUMP JUMPDEST PUSH2 0x143 PUSH2 0x2BD JUMP JUMPDEST PUSH2 0x19D PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x185 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 CALLDATALOAD AND SWAP1 PUSH1 0x20 ADD CALLDATALOAD ISZERO ISZERO PUSH2 0x2CC JUMP JUMPDEST STOP JUMPDEST PUSH2 0x19D PUSH2 0x4C7 JUMP JUMPDEST PUSH2 0x143 PUSH2 0x5BB JUMP JUMPDEST PUSH2 0x143 PUSH2 0x5CA JUMP JUMPDEST PUSH2 0x19D PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x1CD JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 CALLDATALOAD AND SWAP1 PUSH1 0x20 ADD CALLDATALOAD ISZERO ISZERO PUSH2 0x5D9 JUMP JUMPDEST PUSH2 0x19D PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x1FB JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 CALLDATALOAD AND SWAP1 PUSH1 0x20 ADD CALLDATALOAD ISZERO ISZERO PUSH2 0x79A JUMP JUMPDEST PUSH2 0x19D PUSH2 0x95B JUMP JUMPDEST PUSH2 0x19D PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x231 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 CALLDATALOAD AND SWAP1 PUSH1 0x20 ADD CALLDATALOAD ISZERO ISZERO PUSH2 0xA4F JUMP JUMPDEST PUSH2 0x19D PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x25F JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP CALLDATALOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH2 0xC10 JUMP JUMPDEST PUSH2 0x143 PUSH2 0xD78 JUMP JUMPDEST PUSH2 0x143 PUSH2 0xD87 JUMP JUMPDEST PUSH2 0x19D PUSH2 0xD96 JUMP JUMPDEST PUSH2 0x143 PUSH2 0xE8A JUMP JUMPDEST PUSH2 0x19D PUSH2 0xE99 JUMP JUMPDEST PUSH2 0x143 PUSH2 0xF8D JUMP JUMPDEST PUSH1 0x4 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x2 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x7 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0xC340A24 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x31A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x32E JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x344 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP MLOAD PUSH1 0x0 SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0x40B JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD SWAP1 DUP2 MSTORE DUP3 SLOAD PUSH1 0x2 PUSH1 0x0 NOT PUSH2 0x100 PUSH1 0x1 DUP5 AND ISZERO MUL ADD SWAP1 SWAP2 AND DIV PUSH1 0x24 DUP4 ADD DUP2 SWAP1 MSTORE SWAP1 SWAP2 DUP3 SWAP2 PUSH1 0x44 SWAP1 SWAP2 ADD SWAP1 DUP5 SWAP1 DUP1 ISZERO PUSH2 0x3FC JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x3D1 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x3FC JUMP JUMPDEST DUP3 ADD SWAP2 SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 KECCAK256 SWAP1 JUMPDEST DUP2 SLOAD DUP2 MSTORE SWAP1 PUSH1 0x1 ADD SWAP1 PUSH1 0x20 ADD DUP1 DUP4 GT PUSH2 0x3DF JUMPI DUP3 SWAP1 SUB PUSH1 0x1F AND DUP3 ADD SWAP2 JUMPDEST POP POP SWAP3 POP POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST POP DUP1 ISZERO PUSH2 0x446 JUMPI PUSH1 0x3 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 AND OR SWAP1 SSTORE JUMPDEST PUSH1 0x7 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP1 DUP6 AND PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP2 DUP3 SWAP1 SSTORE PUSH1 0x3 SLOAD PUSH1 0x40 DUP1 MLOAD DUP6 ISZERO ISZERO DUP2 MSTORE SWAP1 MLOAD SWAP4 DUP4 AND SWAP4 SWAP2 SWAP1 SWAP3 AND SWAP2 PUSH32 0xDE655975891E8F09671597B37BD4D663BCC5C21DC6D7641B33CDF85FBE15D08B SWAP2 SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH1 0x9 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0x540 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x9 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x216E65775661756C740000000000000000000000000000000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x9 SLOAD PUSH1 0x5 SLOAD PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP3 DUP4 AND SWAP3 SWAP1 SWAP2 AND SWAP1 PUSH32 0x3D08E01E3B8340BE6CA709DB7A9321448661A1F490DA4D7F3EB03D84FE730953 SWAP1 PUSH1 0x0 SWAP1 LOG3 PUSH1 0x9 SLOAD PUSH1 0x5 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 0x8 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x3 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0xC340A24 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x627 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x63B JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x651 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP MLOAD PUSH1 0x0 SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0x6DE JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD SWAP1 DUP2 MSTORE DUP3 SLOAD PUSH1 0x2 PUSH1 0x0 NOT PUSH2 0x100 PUSH1 0x1 DUP5 AND ISZERO MUL ADD SWAP1 SWAP2 AND DIV PUSH1 0x24 DUP4 ADD DUP2 SWAP1 MSTORE SWAP1 SWAP2 DUP3 SWAP2 PUSH1 0x44 SWAP1 SWAP2 ADD SWAP1 DUP5 SWAP1 DUP1 ISZERO PUSH2 0x3FC JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x3D1 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x3FC JUMP JUMPDEST POP DUP1 ISZERO PUSH2 0x719 JUMPI PUSH1 0x2 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 AND OR SWAP1 SSTORE JUMPDEST PUSH1 0x6 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP1 DUP6 AND PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP2 DUP3 SWAP1 SSTORE PUSH1 0x2 SLOAD PUSH1 0x40 DUP1 MLOAD DUP6 ISZERO ISZERO DUP2 MSTORE SWAP1 MLOAD SWAP4 DUP4 AND SWAP4 SWAP2 SWAP1 SWAP3 AND SWAP2 PUSH32 0x4F337DCBB2512F18373C1F72D990A2F0A6EE5024B04007C52AFD01EB73374A89 SWAP2 SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0xC340A24 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x7E8 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x7FC JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x812 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP MLOAD PUSH1 0x0 SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0x89F JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD SWAP1 DUP2 MSTORE DUP3 SLOAD PUSH1 0x2 PUSH1 0x0 NOT PUSH2 0x100 PUSH1 0x1 DUP5 AND ISZERO MUL ADD SWAP1 SWAP2 AND DIV PUSH1 0x24 DUP4 ADD DUP2 SWAP1 MSTORE SWAP1 SWAP2 DUP3 SWAP2 PUSH1 0x44 SWAP1 SWAP2 ADD SWAP1 DUP5 SWAP1 DUP1 ISZERO PUSH2 0x3FC JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x3D1 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x3FC JUMP JUMPDEST POP DUP1 ISZERO PUSH2 0x8DA JUMPI PUSH1 0x4 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 AND OR SWAP1 SSTORE JUMPDEST PUSH1 0x8 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP1 DUP6 AND PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP2 DUP3 SWAP1 SSTORE PUSH1 0x4 SLOAD PUSH1 0x40 DUP1 MLOAD DUP6 ISZERO ISZERO DUP2 MSTORE SWAP1 MLOAD SWAP4 DUP4 AND SWAP4 SWAP2 SWAP1 SWAP3 AND SWAP2 PUSH32 0x90A5902A45C24AAE553D5AFF384CA16D6560F08D74C9784A4FBD2796D9E13F2B SWAP2 SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH1 0x8 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0x9D4 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0xA PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x216E6577506F6C69637900000000000000000000000000000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x8 SLOAD PUSH1 0x4 SLOAD PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP3 DUP4 AND SWAP3 SWAP1 SWAP2 AND SWAP1 PUSH32 0x64D2FA522B403CA222EFFF0C7AD07D2EF45472A45E5770918BDFA9A2845D29A8 SWAP1 PUSH1 0x0 SWAP1 LOG3 PUSH1 0x8 SLOAD PUSH1 0x4 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0xC340A24 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0xA9D JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0xAB1 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0xAC7 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP MLOAD PUSH1 0x0 SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0xB54 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD SWAP1 DUP2 MSTORE DUP3 SLOAD PUSH1 0x2 PUSH1 0x0 NOT PUSH2 0x100 PUSH1 0x1 DUP5 AND ISZERO MUL ADD SWAP1 SWAP2 AND DIV PUSH1 0x24 DUP4 ADD DUP2 SWAP1 MSTORE SWAP1 SWAP2 DUP3 SWAP2 PUSH1 0x44 SWAP1 SWAP2 ADD SWAP1 DUP5 SWAP1 DUP1 ISZERO PUSH2 0x3FC JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x3D1 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x3FC JUMP JUMPDEST POP DUP1 ISZERO PUSH2 0xB8F JUMPI PUSH1 0x5 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 AND OR SWAP1 SSTORE JUMPDEST PUSH1 0x9 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP1 DUP6 AND PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP2 DUP3 SWAP1 SSTORE PUSH1 0x5 SLOAD PUSH1 0x40 DUP1 MLOAD DUP6 ISZERO ISZERO DUP2 MSTORE SWAP1 MLOAD SWAP4 DUP4 AND SWAP4 SWAP2 SWAP1 SWAP3 AND SWAP2 PUSH32 0x5A80F5053574D6A62733E1692E8CBCFAF927DC82DF0A7267EA2E489A7CC18FF SWAP2 SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0xC340A24 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0xC5E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0xC72 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0xC88 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP MLOAD PUSH1 0x0 SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0xD15 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD SWAP1 DUP2 MSTORE DUP3 SLOAD PUSH1 0x2 PUSH1 0x0 NOT PUSH2 0x100 PUSH1 0x1 DUP5 AND ISZERO MUL ADD SWAP1 SWAP2 AND DIV PUSH1 0x24 DUP4 ADD DUP2 SWAP1 MSTORE SWAP1 SWAP2 DUP3 SWAP2 PUSH1 0x44 SWAP1 SWAP2 ADD SWAP1 DUP5 SWAP1 DUP1 ISZERO PUSH2 0x3FC JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x3D1 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x3FC JUMP JUMPDEST POP PUSH1 0x1 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 AND SWAP1 DUP2 OR SWAP1 SWAP2 SSTORE PUSH1 0x40 MLOAD PUSH32 0x2F658B440C35314F52658EA8A740E05B284CDC84DC9AE01E891F21B8933E7CAD SWAP1 PUSH1 0x0 SWAP1 LOG2 POP JUMP JUMPDEST PUSH1 0x9 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x6 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x7 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0xE0F JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x9 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x216E657747756172640000000000000000000000000000000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x7 SLOAD PUSH1 0x3 SLOAD PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP3 DUP4 AND SWAP3 SWAP1 SWAP2 AND SWAP1 PUSH32 0x960FB9900FB8096216606C4F7FC2FCE5D08CC0C82DA55CEC8619B66B5238481 SWAP1 PUSH1 0x0 SWAP1 LOG3 PUSH1 0x7 SLOAD PUSH1 0x3 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 0x1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x6 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0xF12 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0xC PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x216E6577476F7665726E6F720000000000000000000000000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x6 SLOAD PUSH1 0x2 SLOAD PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP3 DUP4 AND SWAP3 SWAP1 SWAP2 AND SWAP1 PUSH32 0xFFD6FED33FE8EC1016718BDD5D04AE6FECD9ABA0DA6578807DAAAA7FC3D16826 SWAP1 PUSH1 0x0 SWAP1 LOG3 PUSH1 0x6 SLOAD PUSH1 0x2 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 0x5 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 LOG3 RETURNDATACOPY DUP9 0xBD SWAP9 GT JUMPI DUP1 SLT 0xAD PUSH25 0x13BDB3873418713DCD698AA1F936BEC475F2A3F14D64736F6C PUSH4 0x43000705 STOP CALLER ",
          "sourceMap": "272:36:31:-:0;160:2932:8;272:36:31;;160:2932:8;272:36:31;;;-1:-1:-1;;;272:36:31;;;;;;-1:-1:-1;;272:36:31;;:::i;:::-;;628:524:8;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;628:524:8;;;;;;;;;;;;;;;;519:9:31;:22;;-1:-1:-1;;;;;;519:22:31;799:4:8;519:22:31;;;;;;557:28;;628:524:8;;;;;;799:4;;;557:28:31;;519:9;;557:28;-1:-1:-1;819:8:8::1;:20:::0;;-1:-1:-1;;;;;819:20:8;;::::1;-1:-1:-1::0;;;;;;819:20:8;;::::1;::::0;;;::::1;::::0;;;;855:42:::1;::::0;;819:20;855:42;;;;882:8;;;::::1;::::0;819::::1;::::0;855:42:::1;::::0;;;;;::::1;::::0;;::::1;908:8;:20:::0;;-1:-1:-1;;;;;908:20:8;;::::1;-1:-1:-1::0;;;;;;908:20:8;;::::1;::::0;;;::::1;::::0;;;;944:42:::1;::::0;;908:20;944:42;;;;971:8;;;::::1;::::0;908::::1;::::0;944:42:::1;::::0;;;;;::::1;::::0;;::::1;997:6;:16:::0;;-1:-1:-1;;;;;997:16:8;;::::1;-1:-1:-1::0;;;;;;997:16:8;;::::1;::::0;;;::::1;::::0;;;;1029:38:::1;::::0;;997:16;1029:38;;;;1054:6;;;::::1;::::0;997::::1;::::0;1029:38:::1;::::0;;;;;::::1;::::0;;::::1;1078:5;:14:::0;;-1:-1:-1;;;;;1078:14:8;;::::1;-1:-1:-1::0;;;;;;1078:14:8;;::::1;::::0;;;::::1;::::0;;;;1108:36:::1;::::0;;1078:14;1108:36;;;;1132:5;;;::::1;::::0;1078::::1;::::0;1108:36:::1;::::0;;;;;::::1;::::0;;::::1;628:524:::0;;;;160:2932;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;160:2932:8;;;-1:-1:-1;160:2932:8;:::i;:::-;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;"
        },
        "deployedBytecode": {
          "generatedSources": [],
          "immutableReferences": {},
          "linkReferences": {},
          "object": "608060405234801561001057600080fd5b50600436106101365760003560e01c80635beede08116100b25780638fd2057711610081578063bf7e214f11610066578063bf7e214f14610287578063d8a042121461028f578063fbfa77cf1461029757610136565b80638fd2057714610277578063be11f1dd1461027f57610136565b80635beede08146102135780636fe72c141461021b5780637a9e5e4b1461024957806388aaf0c81461026f57610136565b8063215e92bc11610109578063452a9320116100ee578063452a9320146101af57806352759694146101b757806354e3d703146101e557610136565b8063215e92bc1461019f5780633bf90c28146101a757610136565b80630505c8c91461013b5780630c340a241461015f57806319859847146101675780631afe87141461016f575b600080fd5b61014361029f565b604080516001600160a01b039092168252519081900360200190f35b6101436102ae565b6101436102bd565b61019d6004803603604081101561018557600080fd5b506001600160a01b03813516906020013515156102cc565b005b61019d6104c7565b6101436105bb565b6101436105ca565b61019d600480360360408110156101cd57600080fd5b506001600160a01b03813516906020013515156105d9565b61019d600480360360408110156101fb57600080fd5b506001600160a01b038135169060200135151561079a565b61019d61095b565b61019d6004803603604081101561023157600080fd5b506001600160a01b0381351690602001351515610a4f565b61019d6004803603602081101561025f57600080fd5b50356001600160a01b0316610c10565b610143610d78565b610143610d87565b61019d610d96565b610143610e8a565b61019d610e99565b610143610f8d565b6004546001600160a01b031681565b6002546001600160a01b031681565b6007546001600160a01b031681565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b15801561031a57600080fd5b505afa15801561032e573d6000803e3d6000fd5b505050506040513d602081101561034457600080fd5b50516000906001600160a01b0316331461040b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b820191906000526020600020905b8154815290600101906020018083116103df57829003601f168201915b50509250505060405180910390fd5b50801561044657600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600780546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560035460408051851515815290519383169391909216917fde655975891e8f09671597b37bd4d663bcc5c21dc6d7641b33cdf85fbe15d08b919081900360200190a35050565b6009546001600160a01b0316331461054057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f216e65775661756c740000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6009546005546040516001600160a01b0392831692909116907f3d08e01e3b8340be6ca709db7a9321448661a1f490da4d7f3eb03d84fe73095390600090a3600954600580547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b6008546001600160a01b031681565b6003546001600160a01b031681565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b15801561062757600080fd5b505afa15801561063b573d6000803e3d6000fd5b505050506040513d602081101561065157600080fd5b50516000906001600160a01b031633146106de576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b50801561071957600280547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600680546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560025460408051851515815290519383169391909216917f4f337dcbb2512f18373c1f72d990a2f0a6ee5024b04007c52afd01eb73374a89919081900360200190a35050565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b1580156107e857600080fd5b505afa1580156107fc573d6000803e3d6000fd5b505050506040513d602081101561081257600080fd5b50516000906001600160a01b0316331461089f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b5080156108da57600480547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600880546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560045460408051851515815290519383169391909216917f90a5902a45c24aae553d5aff384ca16d6560f08d74c9784a4fbd2796d9e13f2b919081900360200190a35050565b6008546001600160a01b031633146109d457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f216e6577506f6c69637900000000000000000000000000000000000000000000604482015290519081900360640190fd5b6008546004546040516001600160a01b0392831692909116907f64d2fa522b403ca222efff0c7ad07d2ef45472a45e5770918bdfa9a2845d29a890600090a3600854600480547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b158015610a9d57600080fd5b505afa158015610ab1573d6000803e3d6000fd5b505050506040513d6020811015610ac757600080fd5b50516000906001600160a01b03163314610b54576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b508015610b8f57600580547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600980546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560055460408051851515815290519383169391909216917f05a80f5053574d6a62733e1692e8cbcfaf927dc82df0a7267ea2e489a7cc18ff919081900360200190a35050565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b158015610c5e57600080fd5b505afa158015610c72573d6000803e3d6000fd5b505050506040513d6020811015610c8857600080fd5b50516000906001600160a01b03163314610d15576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b50600180547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0383169081179091556040517f2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad90600090a250565b6009546001600160a01b031681565b6006546001600160a01b031681565b6007546001600160a01b03163314610e0f57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f216e657747756172640000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6007546003546040516001600160a01b0392831692909116907f0960fb9900fb8096216606c4f7fc2fce5d08cc0c82da55cec8619b66b523848190600090a3600754600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b6001546001600160a01b031681565b6006546001600160a01b03163314610f1257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f216e6577476f7665726e6f720000000000000000000000000000000000000000604482015290519081900360640190fd5b6006546002546040516001600160a01b0392831692909116907fffd6fed33fe8ec1016718bdd5d04ae6fecd9aba0da6578807daaaa7fc3d1682690600090a3600654600280547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b6005546001600160a01b03168156fea2646970667358221220a33e88bd9811578012ad7813bdb3873418713dcd698aa1f936bec475f2a3f14d64736f6c63430007050033",
          "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x136 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x5BEEDE08 GT PUSH2 0xB2 JUMPI DUP1 PUSH4 0x8FD20577 GT PUSH2 0x81 JUMPI DUP1 PUSH4 0xBF7E214F GT PUSH2 0x66 JUMPI DUP1 PUSH4 0xBF7E214F EQ PUSH2 0x287 JUMPI DUP1 PUSH4 0xD8A04212 EQ PUSH2 0x28F JUMPI DUP1 PUSH4 0xFBFA77CF EQ PUSH2 0x297 JUMPI PUSH2 0x136 JUMP JUMPDEST DUP1 PUSH4 0x8FD20577 EQ PUSH2 0x277 JUMPI DUP1 PUSH4 0xBE11F1DD EQ PUSH2 0x27F JUMPI PUSH2 0x136 JUMP JUMPDEST DUP1 PUSH4 0x5BEEDE08 EQ PUSH2 0x213 JUMPI DUP1 PUSH4 0x6FE72C14 EQ PUSH2 0x21B JUMPI DUP1 PUSH4 0x7A9E5E4B EQ PUSH2 0x249 JUMPI DUP1 PUSH4 0x88AAF0C8 EQ PUSH2 0x26F JUMPI PUSH2 0x136 JUMP JUMPDEST DUP1 PUSH4 0x215E92BC GT PUSH2 0x109 JUMPI DUP1 PUSH4 0x452A9320 GT PUSH2 0xEE JUMPI DUP1 PUSH4 0x452A9320 EQ PUSH2 0x1AF JUMPI DUP1 PUSH4 0x52759694 EQ PUSH2 0x1B7 JUMPI DUP1 PUSH4 0x54E3D703 EQ PUSH2 0x1E5 JUMPI PUSH2 0x136 JUMP JUMPDEST DUP1 PUSH4 0x215E92BC EQ PUSH2 0x19F JUMPI DUP1 PUSH4 0x3BF90C28 EQ PUSH2 0x1A7 JUMPI PUSH2 0x136 JUMP JUMPDEST DUP1 PUSH4 0x505C8C9 EQ PUSH2 0x13B JUMPI DUP1 PUSH4 0xC340A24 EQ PUSH2 0x15F JUMPI DUP1 PUSH4 0x19859847 EQ PUSH2 0x167 JUMPI DUP1 PUSH4 0x1AFE8714 EQ PUSH2 0x16F JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x143 PUSH2 0x29F JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP3 AND DUP3 MSTORE MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 RETURN JUMPDEST PUSH2 0x143 PUSH2 0x2AE JUMP JUMPDEST PUSH2 0x143 PUSH2 0x2BD JUMP JUMPDEST PUSH2 0x19D PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x185 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 CALLDATALOAD AND SWAP1 PUSH1 0x20 ADD CALLDATALOAD ISZERO ISZERO PUSH2 0x2CC JUMP JUMPDEST STOP JUMPDEST PUSH2 0x19D PUSH2 0x4C7 JUMP JUMPDEST PUSH2 0x143 PUSH2 0x5BB JUMP JUMPDEST PUSH2 0x143 PUSH2 0x5CA JUMP JUMPDEST PUSH2 0x19D PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x1CD JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 CALLDATALOAD AND SWAP1 PUSH1 0x20 ADD CALLDATALOAD ISZERO ISZERO PUSH2 0x5D9 JUMP JUMPDEST PUSH2 0x19D PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x1FB JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 CALLDATALOAD AND SWAP1 PUSH1 0x20 ADD CALLDATALOAD ISZERO ISZERO PUSH2 0x79A JUMP JUMPDEST PUSH2 0x19D PUSH2 0x95B JUMP JUMPDEST PUSH2 0x19D PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x231 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 CALLDATALOAD AND SWAP1 PUSH1 0x20 ADD CALLDATALOAD ISZERO ISZERO PUSH2 0xA4F JUMP JUMPDEST PUSH2 0x19D PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x25F JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP CALLDATALOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH2 0xC10 JUMP JUMPDEST PUSH2 0x143 PUSH2 0xD78 JUMP JUMPDEST PUSH2 0x143 PUSH2 0xD87 JUMP JUMPDEST PUSH2 0x19D PUSH2 0xD96 JUMP JUMPDEST PUSH2 0x143 PUSH2 0xE8A JUMP JUMPDEST PUSH2 0x19D PUSH2 0xE99 JUMP JUMPDEST PUSH2 0x143 PUSH2 0xF8D JUMP JUMPDEST PUSH1 0x4 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x2 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x7 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0xC340A24 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x31A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x32E JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x344 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP MLOAD PUSH1 0x0 SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0x40B JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD SWAP1 DUP2 MSTORE DUP3 SLOAD PUSH1 0x2 PUSH1 0x0 NOT PUSH2 0x100 PUSH1 0x1 DUP5 AND ISZERO MUL ADD SWAP1 SWAP2 AND DIV PUSH1 0x24 DUP4 ADD DUP2 SWAP1 MSTORE SWAP1 SWAP2 DUP3 SWAP2 PUSH1 0x44 SWAP1 SWAP2 ADD SWAP1 DUP5 SWAP1 DUP1 ISZERO PUSH2 0x3FC JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x3D1 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x3FC JUMP JUMPDEST DUP3 ADD SWAP2 SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 KECCAK256 SWAP1 JUMPDEST DUP2 SLOAD DUP2 MSTORE SWAP1 PUSH1 0x1 ADD SWAP1 PUSH1 0x20 ADD DUP1 DUP4 GT PUSH2 0x3DF JUMPI DUP3 SWAP1 SUB PUSH1 0x1F AND DUP3 ADD SWAP2 JUMPDEST POP POP SWAP3 POP POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST POP DUP1 ISZERO PUSH2 0x446 JUMPI PUSH1 0x3 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 AND OR SWAP1 SSTORE JUMPDEST PUSH1 0x7 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP1 DUP6 AND PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP2 DUP3 SWAP1 SSTORE PUSH1 0x3 SLOAD PUSH1 0x40 DUP1 MLOAD DUP6 ISZERO ISZERO DUP2 MSTORE SWAP1 MLOAD SWAP4 DUP4 AND SWAP4 SWAP2 SWAP1 SWAP3 AND SWAP2 PUSH32 0xDE655975891E8F09671597B37BD4D663BCC5C21DC6D7641B33CDF85FBE15D08B SWAP2 SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH1 0x9 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0x540 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x9 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x216E65775661756C740000000000000000000000000000000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x9 SLOAD PUSH1 0x5 SLOAD PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP3 DUP4 AND SWAP3 SWAP1 SWAP2 AND SWAP1 PUSH32 0x3D08E01E3B8340BE6CA709DB7A9321448661A1F490DA4D7F3EB03D84FE730953 SWAP1 PUSH1 0x0 SWAP1 LOG3 PUSH1 0x9 SLOAD PUSH1 0x5 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 0x8 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x3 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0xC340A24 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x627 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x63B JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x651 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP MLOAD PUSH1 0x0 SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0x6DE JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD SWAP1 DUP2 MSTORE DUP3 SLOAD PUSH1 0x2 PUSH1 0x0 NOT PUSH2 0x100 PUSH1 0x1 DUP5 AND ISZERO MUL ADD SWAP1 SWAP2 AND DIV PUSH1 0x24 DUP4 ADD DUP2 SWAP1 MSTORE SWAP1 SWAP2 DUP3 SWAP2 PUSH1 0x44 SWAP1 SWAP2 ADD SWAP1 DUP5 SWAP1 DUP1 ISZERO PUSH2 0x3FC JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x3D1 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x3FC JUMP JUMPDEST POP DUP1 ISZERO PUSH2 0x719 JUMPI PUSH1 0x2 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 AND OR SWAP1 SSTORE JUMPDEST PUSH1 0x6 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP1 DUP6 AND PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP2 DUP3 SWAP1 SSTORE PUSH1 0x2 SLOAD PUSH1 0x40 DUP1 MLOAD DUP6 ISZERO ISZERO DUP2 MSTORE SWAP1 MLOAD SWAP4 DUP4 AND SWAP4 SWAP2 SWAP1 SWAP3 AND SWAP2 PUSH32 0x4F337DCBB2512F18373C1F72D990A2F0A6EE5024B04007C52AFD01EB73374A89 SWAP2 SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0xC340A24 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x7E8 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x7FC JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x812 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP MLOAD PUSH1 0x0 SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0x89F JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD SWAP1 DUP2 MSTORE DUP3 SLOAD PUSH1 0x2 PUSH1 0x0 NOT PUSH2 0x100 PUSH1 0x1 DUP5 AND ISZERO MUL ADD SWAP1 SWAP2 AND DIV PUSH1 0x24 DUP4 ADD DUP2 SWAP1 MSTORE SWAP1 SWAP2 DUP3 SWAP2 PUSH1 0x44 SWAP1 SWAP2 ADD SWAP1 DUP5 SWAP1 DUP1 ISZERO PUSH2 0x3FC JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x3D1 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x3FC JUMP JUMPDEST POP DUP1 ISZERO PUSH2 0x8DA JUMPI PUSH1 0x4 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 AND OR SWAP1 SSTORE JUMPDEST PUSH1 0x8 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP1 DUP6 AND PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP2 DUP3 SWAP1 SSTORE PUSH1 0x4 SLOAD PUSH1 0x40 DUP1 MLOAD DUP6 ISZERO ISZERO DUP2 MSTORE SWAP1 MLOAD SWAP4 DUP4 AND SWAP4 SWAP2 SWAP1 SWAP3 AND SWAP2 PUSH32 0x90A5902A45C24AAE553D5AFF384CA16D6560F08D74C9784A4FBD2796D9E13F2B SWAP2 SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH1 0x8 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0x9D4 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0xA PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x216E6577506F6C69637900000000000000000000000000000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x8 SLOAD PUSH1 0x4 SLOAD PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP3 DUP4 AND SWAP3 SWAP1 SWAP2 AND SWAP1 PUSH32 0x64D2FA522B403CA222EFFF0C7AD07D2EF45472A45E5770918BDFA9A2845D29A8 SWAP1 PUSH1 0x0 SWAP1 LOG3 PUSH1 0x8 SLOAD PUSH1 0x4 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0xC340A24 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0xA9D JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0xAB1 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0xAC7 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP MLOAD PUSH1 0x0 SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0xB54 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD SWAP1 DUP2 MSTORE DUP3 SLOAD PUSH1 0x2 PUSH1 0x0 NOT PUSH2 0x100 PUSH1 0x1 DUP5 AND ISZERO MUL ADD SWAP1 SWAP2 AND DIV PUSH1 0x24 DUP4 ADD DUP2 SWAP1 MSTORE SWAP1 SWAP2 DUP3 SWAP2 PUSH1 0x44 SWAP1 SWAP2 ADD SWAP1 DUP5 SWAP1 DUP1 ISZERO PUSH2 0x3FC JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x3D1 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x3FC JUMP JUMPDEST POP DUP1 ISZERO PUSH2 0xB8F JUMPI PUSH1 0x5 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 AND OR SWAP1 SSTORE JUMPDEST PUSH1 0x9 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP1 DUP6 AND PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP2 DUP3 SWAP1 SSTORE PUSH1 0x5 SLOAD PUSH1 0x40 DUP1 MLOAD DUP6 ISZERO ISZERO DUP2 MSTORE SWAP1 MLOAD SWAP4 DUP4 AND SWAP4 SWAP2 SWAP1 SWAP3 AND SWAP2 PUSH32 0x5A80F5053574D6A62733E1692E8CBCFAF927DC82DF0A7267EA2E489A7CC18FF SWAP2 SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0xC340A24 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0xC5E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0xC72 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0xC88 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP MLOAD PUSH1 0x0 SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0xD15 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD SWAP1 DUP2 MSTORE DUP3 SLOAD PUSH1 0x2 PUSH1 0x0 NOT PUSH2 0x100 PUSH1 0x1 DUP5 AND ISZERO MUL ADD SWAP1 SWAP2 AND DIV PUSH1 0x24 DUP4 ADD DUP2 SWAP1 MSTORE SWAP1 SWAP2 DUP3 SWAP2 PUSH1 0x44 SWAP1 SWAP2 ADD SWAP1 DUP5 SWAP1 DUP1 ISZERO PUSH2 0x3FC JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x3D1 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x3FC JUMP JUMPDEST POP PUSH1 0x1 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 AND SWAP1 DUP2 OR SWAP1 SWAP2 SSTORE PUSH1 0x40 MLOAD PUSH32 0x2F658B440C35314F52658EA8A740E05B284CDC84DC9AE01E891F21B8933E7CAD SWAP1 PUSH1 0x0 SWAP1 LOG2 POP JUMP JUMPDEST PUSH1 0x9 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x6 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x7 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0xE0F JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x9 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x216E657747756172640000000000000000000000000000000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x7 SLOAD PUSH1 0x3 SLOAD PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP3 DUP4 AND SWAP3 SWAP1 SWAP2 AND SWAP1 PUSH32 0x960FB9900FB8096216606C4F7FC2FCE5D08CC0C82DA55CEC8619B66B5238481 SWAP1 PUSH1 0x0 SWAP1 LOG3 PUSH1 0x7 SLOAD PUSH1 0x3 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 0x1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x6 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0xF12 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0xC PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x216E6577476F7665726E6F720000000000000000000000000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x6 SLOAD PUSH1 0x2 SLOAD PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP3 DUP4 AND SWAP3 SWAP1 SWAP2 AND SWAP1 PUSH32 0xFFD6FED33FE8EC1016718BDD5D04AE6FECD9ABA0DA6578807DAAAA7FC3D16826 SWAP1 PUSH1 0x0 SWAP1 LOG3 PUSH1 0x6 SLOAD PUSH1 0x2 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP3 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE JUMP JUMPDEST PUSH1 0x5 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 LOG3 RETURNDATACOPY DUP9 0xBD SWAP9 GT JUMPI DUP1 SLT 0xAD PUSH25 0x13BDB3873418713DCD698AA1F936BEC475F2A3F14D64736F6C PUSH4 0x43000705 STOP CALLER ",
          "sourceMap": "160:2932:8:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;367:30;;;:::i;:::-;;;;-1:-1:-1;;;;;367:30:8;;;;;;;;;;;;;;285:32;;;:::i;479:26::-;;;:::i;1491:277::-;;;;;;;;;;;;;;;;-1:-1:-1;;;;;;1491:277:8;;;;;;;;;;:::i;:::-;;2925:164;;;:::i;514:24::-;;;:::i;326:32::-;;;:::i;1206:277::-;;;;;;;;;;;;;;;;-1:-1:-1;;;;;;1206:277:8;;;;;;;;;;:::i;1776:259::-;;;;;;;;;;;;;;;;-1:-1:-1;;;;;;1776:259:8;;;;;;;;;;:::i;2745:172::-;;;:::i;2043:250::-;;;;;;;;;;;;;;;;-1:-1:-1;;;;;;2043:250:8;;;;;;;;;;:::i;1186:165:31:-;;;;;;;;;;;;;;;;-1:-1:-1;1186:165:31;-1:-1:-1;;;;;1186:165:31;;:::i;547:23:8:-;;;:::i;444:26::-;;;:::i;2552:185::-;;;:::i;380:31:31:-;;;:::i;2356:188:8:-;;;:::i;406:29::-;;;:::i;367:30::-;;;-1:-1:-1;;;;;367:30:8;;:::o;285:32::-;;;-1:-1:-1;;;;;285:32:8;;:::o;479:26::-;;;-1:-1:-1;;;;;479:26:8;;:::o;1491:277::-;713:9:31;;;;;;;;;-1:-1:-1;;;;;713:9:31;-1:-1:-1;;;;;713:18:31;;:20;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;713:20:31;735:12;;-1:-1:-1;;;;;699:34:31;:10;:34;691:57;;;;;;;;;;;;;;;;;-1:-1:-1;;691:57:31;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1600:21:8::1;1596:51;;;1624:8;:23:::0;;;::::1;-1:-1:-1::0;;;;;1624:23:8;::::1;;::::0;;1596:51:::1;1658:11;:26:::0;;-1:-1:-1;;;;;1658:26:8;;::::1;::::0;;;::::1;::::0;;;::::1;::::0;;;;1715:8:::1;::::0;1700:60:::1;::::0;;;::::1;;::::0;;;;1725:11;;::::1;::::0;1715:8;;;::::1;::::0;1700:60:::1;::::0;;;;;::::1;::::0;;::::1;1491:277:::0;;:::o;2925:164::-;2988:8;;-1:-1:-1;;;;;2988:8:8;2974:10;:22;2966:44;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3045:8;;3038:5;;3026:28;;-1:-1:-1;;;;;3045:8:8;;;;3038:5;;;;3026:28;;3045:8;;3026:28;3073:8;;3065:5;:16;;;;-1:-1:-1;;;;;3073:8:8;;;3065:16;;;;;;2925:164::o;514:24::-;;;-1:-1:-1;;;;;514:24:8;;:::o;326:32::-;;;-1:-1:-1;;;;;326:32:8;;:::o;1206:277::-;713:9:31;;;;;;;;;-1:-1:-1;;;;;713:9:31;-1:-1:-1;;;;;713:18:31;;:20;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;713:20:31;735:12;;-1:-1:-1;;;;;699:34:31;:10;:34;691:57;;;;;;;;;;;;;;;;;-1:-1:-1;;691:57:31;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1315:21:8::1;1311:51;;;1339:8;:23:::0;;;::::1;-1:-1:-1::0;;;;;1339:23:8;::::1;;::::0;;1311:51:::1;1373:11;:26:::0;;-1:-1:-1;;;;;1373:26:8;;::::1;::::0;;;::::1;::::0;;;::::1;::::0;;;;1430:8:::1;::::0;1415:60:::1;::::0;;;::::1;;::::0;;;;1440:11;;::::1;::::0;1430:8;;;::::1;::::0;1415:60:::1;::::0;;;;;::::1;::::0;;::::1;1206:277:::0;;:::o;1776:259::-;713:9:31;;;;;;;;;-1:-1:-1;;;;;713:9:31;-1:-1:-1;;;;;713:18:31;;:20;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;713:20:31;735:12;;-1:-1:-1;;;;;699:34:31;:10;:34;691:57;;;;;;;;;;;;;;;;;-1:-1:-1;;691:57:31;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1881:21:8::1;1877:47;;;1905:6;:19:::0;;;::::1;-1:-1:-1::0;;;;;1905:19:8;::::1;;::::0;;1877:47:::1;1935:9;:22:::0;;-1:-1:-1;;;;;1935:22:8;;::::1;::::0;;;::::1;::::0;;;::::1;::::0;;;;1986:6:::1;::::0;1973:54:::1;::::0;;;::::1;;::::0;;;;1994:9;;::::1;::::0;1986:6;;;::::1;::::0;1973:54:::1;::::0;;;;;::::1;::::0;;::::1;1776:259:::0;;:::o;2745:172::-;2809:9;;-1:-1:-1;;;;;2809:9:8;2795:10;:23;2787:46;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2870:9;;2862:6;;2849:31;;-1:-1:-1;;;;;2870:9:8;;;;2862:6;;;;2849:31;;2870:9;;2849:31;2900:9;;2891:6;:18;;;;-1:-1:-1;;;;;2900:9:8;;;2891:18;;;;;;2745:172::o;2043:250::-;713:9:31;;;;;;;;;-1:-1:-1;;;;;713:9:31;-1:-1:-1;;;;;713:18:31;;:20;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;713:20:31;735:12;;-1:-1:-1;;;;;699:34:31;:10;:34;691:57;;;;;;;;;;;;;;;;;-1:-1:-1;;691:57:31;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2146:21:8::1;2142:45;;;2170:5;:17:::0;;;::::1;-1:-1:-1::0;;;;;2170:17:8;::::1;;::::0;;2142:45:::1;2198:8;:20:::0;;-1:-1:-1;;;;;2198:20:8;;::::1;::::0;;;::::1;::::0;;;::::1;::::0;;;;2246:5:::1;::::0;2234:51:::1;::::0;;;::::1;;::::0;;;;2253:8;;::::1;::::0;2246:5;;;::::1;::::0;2234:51:::1;::::0;;;;;::::1;::::0;;::::1;2043:250:::0;;:::o;1186:165:31:-;713:9;;;;;;;;;-1:-1:-1;;;;;713:9:31;-1:-1:-1;;;;;713:18:31;;:20;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;713:20:31;735:12;;-1:-1:-1;;;;;699:34:31;:10;:34;691:57;;;;;;;;;;;;;;;;;-1:-1:-1;;691:57:31;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;1271:9:31::1;:25:::0;;;::::1;-1:-1:-1::0;;;;;1271:25:31;::::1;::::0;;::::1;::::0;;;1312:31:::1;::::0;::::1;::::0;-1:-1:-1;;1312:31:31::1;1186:165:::0;:::o;547:23:8:-;;;-1:-1:-1;;;;;547:23:8;;:::o;444:26::-;;;-1:-1:-1;;;;;444:26:8;;:::o;2552:185::-;2618:11;;-1:-1:-1;;;;;2618:11:8;2604:10;:25;2596:47;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2684:11;;2674:8;;2659:37;;-1:-1:-1;;;;;2684:11:8;;;;2674:8;;;;2659:37;;2684:11;;2659:37;2718:11;;2707:8;:22;;;;-1:-1:-1;;;;;2718:11:8;;;2707:22;;;;;;2552:185::o;380:31:31:-;;;-1:-1:-1;;;;;380:31:31;;:::o;2356:188:8:-;2422:11;;-1:-1:-1;;;;;2422:11:8;2408:10;:25;2400:50;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2491:11;;2481:8;;2466:37;;-1:-1:-1;;;;;2491:11:8;;;;2481:8;;;;2466:37;;2491:11;;2466:37;2525:11;;2514:8;:22;;;;-1:-1:-1;;;;;2525:11:8;;;2514:22;;;;;;2356:188::o;406:29::-;;;-1:-1:-1;;;;;406:29:8;;:::o"
        },
        "gasEstimates": {
          "creation": {
            "codeDepositCost": "810000",
            "executionCost": "infinite",
            "totalCost": "infinite"
          },
          "external": {
            "authority()": "1081",
            "governor()": "1083",
            "guardian()": "1082",
            "newGovernor()": "1082",
            "newGuardian()": "1105",
            "newPolicy()": "1105",
            "newVault()": "1126",
            "policy()": "1061",
            "pullGovernor()": "25867",
            "pullGuardian()": "25868",
            "pullPolicy()": "25824",
            "pullVault()": "25847",
            "pushGovernor(address,bool)": "infinite",
            "pushGuardian(address,bool)": "infinite",
            "pushPolicy(address,bool)": "infinite",
            "pushVault(address,bool)": "infinite",
            "setAuthority(address)": "infinite",
            "vault()": "1125"
          }
        },
        "methodIdentifiers": {
          "authority()": "bf7e214f",
          "governor()": "0c340a24",
          "guardian()": "452a9320",
          "newGovernor()": "8fd20577",
          "newGuardian()": "19859847",
          "newPolicy()": "3bf90c28",
          "newVault()": "88aaf0c8",
          "policy()": "0505c8c9",
          "pullGovernor()": "d8a04212",
          "pullGuardian()": "be11f1dd",
          "pullPolicy()": "5beede08",
          "pullVault()": "215e92bc",
          "pushGovernor(address,bool)": "52759694",
          "pushGuardian(address,bool)": "1afe8714",
          "pushPolicy(address,bool)": "54e3d703",
          "pushVault(address,bool)": "6fe72c14",
          "setAuthority(address)": "7a9e5e4b",
          "vault()": "fbfa77cf"
        }
      },
      "metadata": "{\"compiler\":{\"version\":\"0.7.5+commit.eb77ed08\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_policy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IRomeAuthority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"GovernorPulled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_effectiveImmediately\",\"type\":\"bool\"}],\"name\":\"GovernorPushed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"GuardianPulled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_effectiveImmediately\",\"type\":\"bool\"}],\"name\":\"GuardianPushed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"PolicyPulled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_effectiveImmediately\",\"type\":\"bool\"}],\"name\":\"PolicyPushed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"VaultPulled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_effectiveImmediately\",\"type\":\"bool\"}],\"name\":\"VaultPushed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract IRomeAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newGuardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newPolicy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"policy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pullGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pullGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pullPolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pullVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_effectiveImmediately\",\"type\":\"bool\"}],\"name\":\"pushGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGuardian\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_effectiveImmediately\",\"type\":\"bool\"}],\"name\":\"pushGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPolicy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_effectiveImmediately\",\"type\":\"bool\"}],\"name\":\"pushPolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newVault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_effectiveImmediately\",\"type\":\"bool\"}],\"name\":\"pushVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IRomeAuthority\",\"name\":\"_newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/RomeAuthority.sol\":\"RomeAuthority\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":9999},\"remappings\":[]},\"sources\":{\"src/RomeAuthority.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"./interfaces/IRomeAuthority.sol\\\";\\r\\n\\r\\nimport \\\"./types/RomeAccessControlled.sol\\\";\\r\\n\\r\\ncontract RomeAuthority is IRomeAuthority, RomeAccessControlled {\\r\\n\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    address public override governor;\\r\\n\\r\\n    address public override guardian;\\r\\n\\r\\n    address public override policy;\\r\\n\\r\\n    address public override vault;\\r\\n\\r\\n    address public newGovernor;\\r\\n\\r\\n    address public newGuardian;\\r\\n\\r\\n    address public newPolicy;\\r\\n\\r\\n    address public newVault;\\r\\n\\r\\n\\r\\n    /* ========== Constructor ========== */\\r\\n\\r\\n    constructor(\\r\\n        address _governor,\\r\\n        address _guardian,\\r\\n        address _policy,\\r\\n        address _vault\\r\\n    ) RomeAccessControlled( IRomeAuthority(address(this)) ) {\\r\\n        governor = _governor;\\r\\n        emit GovernorPushed(address(0), governor, true);\\r\\n        guardian = _guardian;\\r\\n        emit GuardianPushed(address(0), guardian, true);\\r\\n        policy = _policy;\\r\\n        emit PolicyPushed(address(0), policy, true);\\r\\n        vault = _vault;\\r\\n        emit VaultPushed(address(0), vault, true);\\r\\n    }\\r\\n\\r\\n\\r\\n    /* ========== GOV ONLY ========== */\\r\\n\\r\\n    function pushGovernor(address _newGovernor, bool _effectiveImmediately) external onlyGovernor {\\r\\n        if( _effectiveImmediately ) governor = _newGovernor;\\r\\n        newGovernor = _newGovernor;\\r\\n        emit GovernorPushed(governor, newGovernor, _effectiveImmediately);\\r\\n    }\\r\\n\\r\\n    function pushGuardian(address _newGuardian, bool _effectiveImmediately) external onlyGovernor {\\r\\n        if( _effectiveImmediately ) guardian = _newGuardian;\\r\\n        newGuardian = _newGuardian;\\r\\n        emit GuardianPushed(guardian, newGuardian, _effectiveImmediately);\\r\\n    }\\r\\n\\r\\n    function pushPolicy(address _newPolicy, bool _effectiveImmediately) external onlyGovernor {\\r\\n        if( _effectiveImmediately ) policy = _newPolicy;\\r\\n        newPolicy = _newPolicy;\\r\\n        emit PolicyPushed(policy, newPolicy, _effectiveImmediately);\\r\\n    }\\r\\n\\r\\n    function pushVault(address _newVault, bool _effectiveImmediately) external onlyGovernor {\\r\\n        if( _effectiveImmediately ) vault = _newVault;\\r\\n        newVault = _newVault;\\r\\n        emit VaultPushed(vault, newVault, _effectiveImmediately);\\r\\n    }\\r\\n\\r\\n\\r\\n    /* ========== PENDING ROLE ONLY ========== */\\r\\n\\r\\n    function pullGovernor() external {\\r\\n        require(msg.sender == newGovernor, \\\"!newGovernor\\\");\\r\\n        emit GovernorPulled(governor, newGovernor);\\r\\n        governor = newGovernor;\\r\\n    }\\r\\n\\r\\n    function pullGuardian() external {\\r\\n        require(msg.sender == newGuardian, \\\"!newGuard\\\");\\r\\n        emit GuardianPulled(guardian, newGuardian);\\r\\n        guardian = newGuardian;\\r\\n    }\\r\\n\\r\\n    function pullPolicy() external {\\r\\n        require(msg.sender == newPolicy, \\\"!newPolicy\\\");\\r\\n        emit PolicyPulled(policy, newPolicy);\\r\\n        policy = newPolicy;\\r\\n    }\\r\\n\\r\\n    function pullVault() external {\\r\\n        require(msg.sender == newVault, \\\"!newVault\\\");\\r\\n        emit VaultPulled(vault, newVault);\\r\\n        vault = newVault;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xd7b090cb34d9f3825cb8c189d62c514c0b5db2da5c77464396f9407196a70970\",\"license\":\"AGPL-3.0-only\"},\"src/interfaces/IRomeAuthority.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity >=0.7.5;\\r\\n\\r\\ninterface IRomeAuthority {\\r\\n    /* ========== EVENTS ========== */\\r\\n    \\r\\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\r\\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \\r\\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \\r\\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \\r\\n\\r\\n    event GovernorPulled(address indexed from, address indexed to);\\r\\n    event GuardianPulled(address indexed from, address indexed to);\\r\\n    event PolicyPulled(address indexed from, address indexed to);\\r\\n    event VaultPulled(address indexed from, address indexed to);\\r\\n\\r\\n    /* ========== VIEW ========== */\\r\\n    \\r\\n    function governor() external view returns (address);\\r\\n    function guardian() external view returns (address);\\r\\n    function policy() external view returns (address);\\r\\n    function vault() external view returns (address);\\r\\n}\\r\\n\",\"keccak256\":\"0xca4d1b1c8ee925a52c6c8aa2260620595f4abab19b8ad42548d87fd1ff9b6f00\",\"license\":\"AGPL-3.0-or-later\"},\"src/types/RomeAccessControlled.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity >=0.7.5;\\r\\n\\r\\nimport \\\"../interfaces/IRomeAuthority.sol\\\";\\r\\n\\r\\nabstract contract RomeAccessControlled {\\r\\n\\r\\n    /* ========== EVENTS ========== */\\r\\n\\r\\n    event AuthorityUpdated(IRomeAuthority indexed authority);\\r\\n\\r\\n    string UNAUTHORIZED = \\\"UNAUTHORIZED\\\"; // save gas\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    IRomeAuthority public authority;\\r\\n\\r\\n\\r\\n    /* ========== Constructor ========== */\\r\\n\\r\\n    constructor(IRomeAuthority _authority) {\\r\\n        authority = _authority;\\r\\n        emit AuthorityUpdated(_authority);\\r\\n    }\\r\\n    \\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n    \\r\\n    modifier onlyGovernor() {\\r\\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    modifier onlyGuardian() {\\r\\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    modifier onlyPolicy() {\\r\\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyVault() {\\r\\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /* ========== GOV ONLY ========== */\\r\\n    \\r\\n    function setAuthority(IRomeAuthority _newAuthority) external onlyGovernor {\\r\\n        authority = _newAuthority;\\r\\n        emit AuthorityUpdated(_newAuthority);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x803650d4cff0ebf1b81f497416d5b7cfd3e6d1a88cc901afa577c8710dd8da02\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
      "storageLayout": {
        "storage": [
          {
            "astId": 15689,
            "contract": "src/RomeAuthority.sol:RomeAuthority",
            "label": "UNAUTHORIZED",
            "offset": 0,
            "slot": "0",
            "type": "t_string_storage"
          },
          {
            "astId": 15691,
            "contract": "src/RomeAuthority.sol:RomeAuthority",
            "label": "authority",
            "offset": 0,
            "slot": "1",
            "type": "t_contract(IRomeAuthority)12679"
          },
          {
            "astId": 8791,
            "contract": "src/RomeAuthority.sol:RomeAuthority",
            "label": "governor",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 8794,
            "contract": "src/RomeAuthority.sol:RomeAuthority",
            "label": "guardian",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 8797,
            "contract": "src/RomeAuthority.sol:RomeAuthority",
            "label": "policy",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 8800,
            "contract": "src/RomeAuthority.sol:RomeAuthority",
            "label": "vault",
            "offset": 0,
            "slot": "5",
            "type": "t_address"
          },
          {
            "astId": 8802,
            "contract": "src/RomeAuthority.sol:RomeAuthority",
            "label": "newGovernor",
            "offset": 0,
            "slot": "6",
            "type": "t_address"
          },
          {
            "astId": 8804,
            "contract": "src/RomeAuthority.sol:RomeAuthority",
            "label": "newGuardian",
            "offset": 0,
            "slot": "7",
            "type": "t_address"
          },
          {
            "astId": 8806,
            "contract": "src/RomeAuthority.sol:RomeAuthority",
            "label": "newPolicy",
            "offset": 0,
            "slot": "8",
            "type": "t_address"
          },
          {
            "astId": 8808,
            "contract": "src/RomeAuthority.sol:RomeAuthority",
            "label": "newVault",
            "offset": 0,
            "slot": "9",
            "type": "t_address"
          }
        ],
        "types": {
          "t_address": {
            "encoding": "inplace",
            "label": "address",
            "numberOfBytes": "20"
          },
          "t_contract(IRomeAuthority)12679": {
            "encoding": "inplace",
            "label": "contract IRomeAuthority",
            "numberOfBytes": "20"
          },
          "t_string_storage": {
            "encoding": "bytes",
            "label": "string",
            "numberOfBytes": "32"
          }
        }
      },
      "userdoc": {
        "kind": "user",
        "methods": {},
        "version": 1
      },
      "solcInput": "{\n  \"language\": \"Solidity\",\n  \"sources\": {\n    \"src/aRomeERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport \\\"./types/ERC20Permit.sol\\\";\\n\\nimport \\\"./types/Policy.sol\\\";\\n\\ncontract PresaleOwned is Policy {\\n    \\n  address internal _presale;\\n\\n  function setPresale( address presale_ ) external onlyPolicy() returns ( bool ) {\\n    _presale = presale_;\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current vault.\\n   */\\n  function presale() public view returns (address) {\\n    return _presale;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the vault.\\n   */\\n  modifier onlyPresale() {\\n    require( _presale == msg.sender, \\\"PresaleOwned: caller is not the Presale\\\" );\\n    _;\\n  }\\n\\n}\\n\\ncontract aRome is ERC20Permit, PresaleOwned {\\n\\n  using SafeMath for uint256;\\n\\n    constructor()\\n    ERC20(\\\"Alpha Rome\\\", \\\"aROME\\\", 9)\\n    ERC20Permit(\\\"Alpha Rome\\\"){}\\n\\n    function mint(address account_, uint256 amount_) external onlyPresale() {\\n        _mint(account_, amount_);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    /*\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n     \\n    function burnFrom(address account_, uint256 amount_) public virtual {\\n        _burnFrom(account_, amount_);\\n    }\\n\\n    function _burnFrom(address account_, uint256 amount_) public virtual {\\n        uint256 decreasedAllowance_ =\\n            allowance(account_, msg.sender).sub(\\n                amount_,\\n                \\\"ERC20: burn amount exceeds allowance\\\"\\n            );\\n\\n        _approve(account_, msg.sender, decreasedAllowance_);\\n        _burn(account_, amount_);\\n    }\\n}\\n\"\n    },\n    \"src/types/ERC20Permit.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.5;\\n\\nimport \\\"../interfaces/IERC20Permit.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"../cryptography/EIP712.sol\\\";\\nimport \\\"../cryptography/ECDSA.sol\\\";\\nimport \\\"../libraries/Counters.sol\\\";\\n\\n/**\\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * _Available since v3.4._\\n */\\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\\n    using Counters for Counters.Counter;\\n\\n    mapping(address => Counters.Counter) private _nonces;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 private immutable _PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    /**\\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\\\"1\\\"`.\\n     *\\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\\n     */\\n    constructor(string memory name) EIP712(name, \\\"1\\\") {}\\n\\n    /**\\n     * @dev See {IERC20Permit-permit}.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-nonces}.\\n     */\\n    function nonces(address owner) public view virtual override returns (uint256) {\\n        return _nonces[owner].current();\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n\\n    /**\\n     * @dev \\\"Consume a nonce\\\": return the current value and increment.\\n     *\\n     * _Available since v4.1._\\n     */\\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\\n        Counters.Counter storage nonce = _nonces[owner];\\n        current = nonce.current();\\n        nonce.increment();\\n    }\\n}\\n\"\n    },\n    \"src/types/Policy.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.5;\\n\\ninterface IPolicy {\\n  function policy() external view returns (address);\\n\\n  function renouncePolicy() external;\\n\\n  function pushPolicy( address newOwner_ ) external;\\n\\n  function pullPolicy() external;\\n}\\n\\ncontract Policy is IPolicy {\\n\\n    address internal _owner;\\n    address internal _newOwner;\\n\\n    event OwnershipPushed(address indexed previousOwner, address indexed newOwner);\\n    event OwnershipPulled(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () {\\n        _owner = msg.sender;\\n        emit OwnershipPushed( address(0), _owner );\\n    }\\n\\n    function policy() public view override returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyPolicy() {\\n        require( _owner == msg.sender, \\\"Ownable: caller is not the owner\\\" );\\n        _;\\n    }\\n\\n    function renouncePolicy() public virtual override onlyPolicy() {\\n        emit OwnershipPushed( _owner, address(0) );\\n        _owner = address(0);\\n    }\\n\\n    function pushPolicy( address newOwner_ ) public virtual override onlyPolicy() {\\n        require( newOwner_ != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipPushed( _owner, newOwner_ );\\n        _newOwner = newOwner_;\\n    }\\n\\n    function pullPolicy() public virtual override {\\n        require( msg.sender == _newOwner, \\\"Ownable: must be new owner to pull\\\");\\n        emit OwnershipPulled( _owner, _newOwner );\\n        _owner = _newOwner;\\n    }\\n}\\n\"\n    },\n    \"src/interfaces/IERC20Permit.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.5;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\n    },\n    \"src/types/ERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity >=0.7.5;\\n\\nimport \\\"../libraries/SafeMath.sol\\\";\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n\\nabstract contract ERC20 is IERC20 {\\n\\n    using SafeMath for uint256;\\n\\n    // TODO comment actual hash value.\\n    bytes32 constant private ERC20TOKEN_ERC1820_INTERFACE_ID = keccak256( \\\"ERC20Token\\\" );\\n\\n    mapping (address => uint256) internal _balances;\\n\\n    mapping (address => mapping (address => uint256)) internal _allowances;\\n\\n    uint256 internal _totalSupply;\\n\\n    string internal _name;\\n\\n    string internal _symbol;\\n\\n    uint8 internal immutable _decimals;\\n\\n    constructor (string memory name_, string memory symbol_, uint8 decimals_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = decimals_;\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account_, uint256 ammount_) internal virtual {\\n        require(account_ != address(0), \\\"ERC20: mint to the zero address\\\");\\n        _beforeTokenTransfer(address(0), account_, ammount_);\\n        _totalSupply = _totalSupply.add(ammount_);\\n        _balances[account_] = _balances[account_].add(ammount_);\\n        emit Transfer(address(0), account_, ammount_);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n  function _beforeTokenTransfer( address from_, address to_, uint256 amount_ ) internal virtual { }\\n}\\n\"\n    },\n    \"src/cryptography/EIP712.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.5;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n\\n        uint256 chainID;\\n        assembly {\\n            chainID := chainid()\\n        }\\n\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = chainID;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n\\n        uint256 chainID;\\n        assembly {\\n            chainID := chainid()\\n        }\\n\\n        if (chainID == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        uint256 chainID;\\n        assembly {\\n            chainID := chainid()\\n        }\\n\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, chainID, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\n    },\n    \"src/cryptography/ECDSA.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.5;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\n    },\n    \"src/libraries/Counters.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\\n * directly accessed.\\n */\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\"\n    },\n    \"src/libraries/SafeMath.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/*\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n    // Only used in the  BondingCalculator.sol\\n    function sqrrt(uint256 a) internal pure returns (uint c) {\\n        if (a > 3) {\\n            c = a;\\n            uint b = add( div( a, 2), 1 );\\n            while (b < c) {\\n                c = b;\\n                b = div( add( div( a, b ), b), 2 );\\n            }\\n        } else if (a != 0) {\\n            c = 1;\\n        }\\n    }\\n}\\n\"\n    },\n    \"src/interfaces/IERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\n    },\n    \"src/Treasury.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport './libraries/SafeERC20.sol';\\n\\nimport './types/Policy.sol';\\n\\nimport \\\"./interfaces/IERC20Metadata.sol\\\";\\n\\ninterface IROMEERC20 {\\n    function burnFrom(address account_, uint256 amount_) external;\\n    function mint( uint256 amount_ ) external;\\n    function mint( address account_, uint256 ammount_ ) external;\\n}\\n\\ninterface IBondCalculator {\\n  function valuation( address pair_, uint amount_ ) external view returns ( uint _value );\\n}\\n\\ncontract RomeTreasury is Policy {\\n\\n    using SafeMath for uint;\\n    using SafeERC20 for IERC20;\\n\\n    event Deposit( address indexed token, uint amount, uint value );\\n    event Withdrawal( address indexed token, uint amount, uint value );\\n    event CreateDebt( address indexed debtor, address indexed token, uint amount, uint value );\\n    event RepayDebt( address indexed debtor, address indexed token, uint amount, uint value );\\n    event ReservesManaged( address indexed token, uint amount );\\n    event ReservesUpdated( uint indexed totalReserves );\\n    event ReservesAudited( uint indexed totalReserves );\\n    event RewardsMinted( address indexed caller, address indexed recipient, uint amount );\\n    event ChangeQueued( MANAGING indexed managing, address queued );\\n    event ChangeActivated( MANAGING indexed managing, address activated, bool result );\\n\\n    enum MANAGING { RESERVEDEPOSITOR, RESERVESPENDER, RESERVETOKEN, RESERVEMANAGER, LIQUIDITYDEPOSITOR, LIQUIDITYTOKEN, LIQUIDITYMANAGER, DEBTOR, REWARDMANAGER, SROME }\\n\\n    address public immutable ROME;\\n    uint public immutable blocksNeededForQueue;\\n\\n    address[] public reserveTokens; // Push only, beware false-positives.\\n    mapping( address => bool ) public isReserveToken;\\n    mapping( address => uint ) public reserveTokenQueue; // Delays changes to mapping.\\n\\n    address[] public reserveDepositors; // Push only, beware false-positives. Only for viewing.\\n    mapping( address => bool ) public isReserveDepositor;\\n    mapping( address => uint ) public reserveDepositorQueue; // Delays changes to mapping.\\n\\n    address[] public reserveSpenders; // Push only, beware false-positives. Only for viewing.\\n    mapping( address => bool ) public isReserveSpender;\\n    mapping( address => uint ) public reserveSpenderQueue; // Delays changes to mapping.\\n\\n    address[] public liquidityTokens; // Push only, beware false-positives.\\n    mapping( address => bool ) public isLiquidityToken;\\n    mapping( address => uint ) public LiquidityTokenQueue; // Delays changes to mapping.\\n\\n    address[] public liquidityDepositors; // Push only, beware false-positives. Only for viewing.\\n    mapping( address => bool ) public isLiquidityDepositor;\\n    mapping( address => uint ) public LiquidityDepositorQueue; // Delays changes to mapping.\\n\\n    mapping( address => address ) public bondCalculator; // bond calculator for liquidity token\\n\\n    address[] public reserveManagers; // Push only, beware false-positives. Only for viewing.\\n    mapping( address => bool ) public isReserveManager;\\n    mapping( address => uint ) public ReserveManagerQueue; // Delays changes to mapping.\\n\\n    address[] public liquidityManagers; // Push only, beware false-positives. Only for viewing.\\n    mapping( address => bool ) public isLiquidityManager;\\n    mapping( address => uint ) public LiquidityManagerQueue; // Delays changes to mapping.\\n\\n    address[] public debtors; // Push only, beware false-positives. Only for viewing.\\n    mapping( address => bool ) public isDebtor;\\n    mapping( address => uint ) public debtorQueue; // Delays changes to mapping.\\n    mapping( address => uint ) public debtorBalance;\\n\\n    address[] public rewardManagers; // Push only, beware false-positives. Only for viewing.\\n    mapping( address => bool ) public isRewardManager;\\n    mapping( address => uint ) public rewardManagerQueue; // Delays changes to mapping.\\n\\n    address public sROME;\\n    uint public sROMEQueue; // Delays change to sROME address\\n    \\n    uint public totalReserves; // Risk-free value of all assets\\n    uint public totalDebt;\\n\\n    constructor (\\n        address _ROME,\\n        address _DAI,\\n        address _MIM,\\n        address _FRAX,\\n        address _ROMEFRAX,\\n        address _bondCalculator,\\n        address _DAO,\\n        uint _blocksNeededForQueue\\n    ) {\\n        require( _ROME != address(0) );\\n        ROME = _ROME;\\n\\n        isReserveToken[ _DAI ] = true;\\n        reserveTokens.push( _DAI );\\n\\n        isReserveToken[ _MIM ] = true;\\n        reserveTokens.push( _MIM );\\n\\n        isReserveToken[ _FRAX ] = true;\\n        reserveTokens.push( _FRAX );\\n\\n        isLiquidityToken[ _ROMEFRAX ] = true;\\n        liquidityTokens.push( _ROMEFRAX );\\n        bondCalculator[ _ROMEFRAX ] = _bondCalculator;\\n\\n        isReserveDepositor[ _DAO ] = true;\\n        reserveDepositors.push(_DAO);\\n\\n        isLiquidityDepositor[ _DAO ] = true;\\n        liquidityDepositors.push(_DAO);\\n\\n        blocksNeededForQueue = _blocksNeededForQueue;\\n    }\\n\\n    /**\\n        @notice allow approved address to deposit an asset for ROME\\n        @param _amount uint\\n        @param _token address\\n        @param _profit uint\\n        @return send_ uint\\n     */\\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( uint send_ ) {\\n        require( isReserveToken[ _token ] || isLiquidityToken[ _token ], \\\"Not accepted\\\" );\\n        IERC20( _token ).safeTransferFrom( msg.sender, address(this), _amount );\\n\\n        if ( isReserveToken[ _token ] ) {\\n            require( isReserveDepositor[ msg.sender ], \\\"Not approved\\\" );\\n        } else {\\n            require( isLiquidityDepositor[ msg.sender ], \\\"Not approved\\\" );\\n        }\\n\\n        uint value = valueOf( _token, _amount );\\n        // mint ROME needed and store amount of rewards for distribution\\n        send_ = value.sub( _profit );\\n        IROMEERC20( ROME ).mint( msg.sender, send_ );\\n\\n        totalReserves = totalReserves.add( value );\\n        emit ReservesUpdated( totalReserves );\\n\\n        emit Deposit( _token, _amount, value );\\n    }\\n\\n    /**\\n        @notice allow approved address to burn ROME for reserves\\n        @param _amount uint\\n        @param _token address\\n     */\\n    function withdraw( uint _amount, address _token ) external {\\n        require( isReserveToken[ _token ], \\\"Not accepted\\\" ); // Only reserves can be used for redemptions\\n        require( isReserveSpender[ msg.sender ] == true, \\\"Not approved\\\" );\\n\\n        uint value = valueOf( _token, _amount );\\n        IROMEERC20( ROME ).burnFrom( msg.sender, value );\\n\\n        totalReserves = totalReserves.sub( value );\\n        emit ReservesUpdated( totalReserves );\\n\\n        IERC20( _token ).safeTransfer( msg.sender, _amount );\\n\\n        emit Withdrawal( _token, _amount, value );\\n    }\\n\\n    /**\\n        @notice allow approved address to borrow reserves\\n        @param _amount uint\\n        @param _token address\\n     */\\n    function incurDebt( uint _amount, address _token ) external {\\n        require( isDebtor[ msg.sender ], \\\"Not approved\\\" );\\n        require( isReserveToken[ _token ], \\\"Not accepted\\\" );\\n\\n        uint value = valueOf( _token, _amount );\\n\\n        uint maximumDebt = IERC20( sROME ).balanceOf( msg.sender ); // Can only borrow against sROME held\\n        uint availableDebt = maximumDebt.sub( debtorBalance[ msg.sender ] );\\n        require( value <= availableDebt, \\\"Exceeds debt limit\\\" );\\n\\n        debtorBalance[ msg.sender ] = debtorBalance[ msg.sender ].add( value );\\n        totalDebt = totalDebt.add( value );\\n\\n        totalReserves = totalReserves.sub( value );\\n        emit ReservesUpdated( totalReserves );\\n\\n        IERC20( _token ).transfer( msg.sender, _amount );\\n        \\n        emit CreateDebt( msg.sender, _token, _amount, value );\\n    }\\n\\n    /**\\n        @notice allow approved address to repay borrowed reserves with reserves\\n        @param _amount uint\\n        @param _token address\\n     */\\n    function repayDebtWithReserve( uint _amount, address _token ) external {\\n        require( isDebtor[ msg.sender ], \\\"Not approved\\\" );\\n        require( isReserveToken[ _token ], \\\"Not accepted\\\" );\\n\\n        IERC20( _token ).safeTransferFrom( msg.sender, address(this), _amount );\\n\\n        uint value = valueOf( _token, _amount );\\n        debtorBalance[ msg.sender ] = debtorBalance[ msg.sender ].sub( value );\\n        totalDebt = totalDebt.sub( value );\\n\\n        totalReserves = totalReserves.add( value );\\n        emit ReservesUpdated( totalReserves );\\n\\n        emit RepayDebt( msg.sender, _token, _amount, value );\\n    }\\n\\n    /**\\n        @notice allow approved address to repay borrowed reserves with ROME\\n        @param _amount uint\\n     */\\n    function repayDebtWithROME( uint _amount ) external {\\n        require( isDebtor[ msg.sender ], \\\"Not approved\\\" );\\n\\n        IROMEERC20( ROME ).burnFrom( msg.sender, _amount );\\n\\n        debtorBalance[ msg.sender ] = debtorBalance[ msg.sender ].sub( _amount );\\n        totalDebt = totalDebt.sub( _amount );\\n\\n        emit RepayDebt( msg.sender, ROME, _amount, _amount );\\n    }\\n\\n    /**\\n        @notice allow approved address to withdraw assets\\n        @param _token address\\n        @param _amount uint\\n     */\\n    function manage( address _token, uint _amount ) external {\\n        if( isLiquidityToken[ _token ] ) {\\n            require( isLiquidityManager[ msg.sender ], \\\"Not approved\\\" );\\n        } else {\\n            require( isReserveManager[ msg.sender ], \\\"Not approved\\\" );\\n        }\\n\\n        uint value = valueOf( _token, _amount );\\n        require( value <= excessReserves(), \\\"Insufficient reserves\\\" );\\n\\n        totalReserves = totalReserves.sub( value );\\n        emit ReservesUpdated( totalReserves );\\n\\n        IERC20( _token ).safeTransfer( msg.sender, _amount );\\n\\n        emit ReservesManaged( _token, _amount );\\n    }\\n\\n    /**\\n        @notice send epoch reward to staking contract\\n     */\\n    function mintRewards( address _recipient, uint _amount ) external {\\n        require( isRewardManager[ msg.sender ], \\\"Not approved\\\" );\\n        require( _amount <= excessReserves(), \\\"Insufficient reserves\\\" );\\n\\n        IROMEERC20( ROME ).mint( _recipient, _amount );\\n\\n        emit RewardsMinted( msg.sender, _recipient, _amount );\\n    } \\n\\n    /**\\n        @notice returns excess reserves not backing tokens\\n        @return uint\\n     */\\n    function excessReserves() public view returns ( uint ) {\\n        return totalReserves.sub( IERC20( ROME ).totalSupply().sub( totalDebt ) );\\n    }\\n\\n    /**\\n        @notice takes inventory of all tracked assets\\n        @notice always consolidate to recognized reserves before audit\\n     */\\n    function auditReserves() external onlyPolicy() {\\n        uint reserves;\\n        for( uint i = 0; i < reserveTokens.length; i++ ) {\\n            reserves = reserves.add ( \\n                valueOf( reserveTokens[ i ], IERC20( reserveTokens[ i ] ).balanceOf( address(this) ) )\\n            );\\n        }\\n        for( uint i = 0; i < liquidityTokens.length; i++ ) {\\n            reserves = reserves.add (\\n                valueOf( liquidityTokens[ i ], IERC20( liquidityTokens[ i ] ).balanceOf( address(this) ) )\\n            );\\n        }\\n        totalReserves = reserves;\\n        emit ReservesUpdated( reserves );\\n        emit ReservesAudited( reserves );\\n    }\\n\\n    /**\\n        @notice returns ROME valuation of asset\\n        @param _token address\\n        @param _amount uint\\n        @return value_ uint\\n     */\\n    function valueOf( address _token, uint _amount ) public view returns ( uint value_ ) {\\n        if ( isReserveToken[ _token ] ) {\\n            // convert amount to match ROME decimals\\n            value_ = _amount.mul( 10 ** IERC20Metadata( ROME ).decimals() ).div( 10 ** IERC20Metadata( _token ).decimals() );\\n        } else if ( isLiquidityToken[ _token ] ) {\\n            value_ = IBondCalculator( bondCalculator[ _token ] ).valuation( _token, _amount );\\n        }\\n    }\\n\\n    /**\\n        @notice queue address to change boolean in mapping\\n        @param _managing MANAGING\\n        @param _address address\\n        @return bool\\n     */\\n    function queue( MANAGING _managing, address _address ) external onlyPolicy() returns ( bool ) {\\n        require( _address != address(0) );\\n        if ( _managing == MANAGING.RESERVEDEPOSITOR ) { // 0\\n            reserveDepositorQueue[ _address ] = block.number.add( blocksNeededForQueue );\\n        } else if ( _managing == MANAGING.RESERVESPENDER ) { // 1\\n            reserveSpenderQueue[ _address ] = block.number.add( blocksNeededForQueue );\\n        } else if ( _managing == MANAGING.RESERVETOKEN ) { // 2\\n            reserveTokenQueue[ _address ] = block.number.add( blocksNeededForQueue );\\n        } else if ( _managing == MANAGING.RESERVEMANAGER ) { // 3\\n            ReserveManagerQueue[ _address ] = block.number.add( blocksNeededForQueue.mul( 2 ) );\\n        } else if ( _managing == MANAGING.LIQUIDITYDEPOSITOR ) { // 4\\n            LiquidityDepositorQueue[ _address ] = block.number.add( blocksNeededForQueue );\\n        } else if ( _managing == MANAGING.LIQUIDITYTOKEN ) { // 5\\n            LiquidityTokenQueue[ _address ] = block.number.add( blocksNeededForQueue );\\n        } else if ( _managing == MANAGING.LIQUIDITYMANAGER ) { // 6\\n            LiquidityManagerQueue[ _address ] = block.number.add( blocksNeededForQueue.mul( 2 ) );\\n        } else if ( _managing == MANAGING.DEBTOR ) { // 7\\n            debtorQueue[ _address ] = block.number.add( blocksNeededForQueue );\\n        } else if ( _managing == MANAGING.REWARDMANAGER ) { // 8\\n            rewardManagerQueue[ _address ] = block.number.add( blocksNeededForQueue );\\n        } else if ( _managing == MANAGING.SROME ) { // 9\\n            sROMEQueue = block.number.add( blocksNeededForQueue );\\n        } else return false;\\n\\n        emit ChangeQueued( _managing, _address );\\n        return true;\\n    }\\n\\n    /**\\n        @notice verify queue then set boolean in mapping\\n        @param _managing MANAGING\\n        @param _address address\\n        @param _calculator address\\n        @return bool\\n     */\\n    function toggle( MANAGING _managing, address _address, address _calculator ) external onlyPolicy() returns ( bool ) {\\n        require( _address != address(0) );\\n        bool result;\\n        if ( _managing == MANAGING.RESERVEDEPOSITOR ) { // 0\\n            if ( requirements( reserveDepositorQueue, isReserveDepositor, _address ) ) {\\n                reserveDepositorQueue[ _address ] = 0;\\n                if( !listContains( reserveDepositors, _address ) ) {\\n                    reserveDepositors.push( _address );\\n                }\\n            }\\n            result = !isReserveDepositor[ _address ];\\n            isReserveDepositor[ _address ] = result;\\n            \\n        } else if ( _managing == MANAGING.RESERVESPENDER ) { // 1\\n            if ( requirements( reserveSpenderQueue, isReserveSpender, _address ) ) {\\n                reserveSpenderQueue[ _address ] = 0;\\n                if( !listContains( reserveSpenders, _address ) ) {\\n                    reserveSpenders.push( _address );\\n                }\\n            }\\n            result = !isReserveSpender[ _address ];\\n            isReserveSpender[ _address ] = result;\\n\\n        } else if ( _managing == MANAGING.RESERVETOKEN ) { // 2\\n            if ( requirements( reserveTokenQueue, isReserveToken, _address ) ) {\\n                reserveTokenQueue[ _address ] = 0;\\n                if( !listContains( reserveTokens, _address ) ) {\\n                    reserveTokens.push( _address );\\n                }\\n            }\\n            result = !isReserveToken[ _address ];\\n            isReserveToken[ _address ] = result;\\n\\n        } else if ( _managing == MANAGING.RESERVEMANAGER ) { // 3\\n            if ( requirements( ReserveManagerQueue, isReserveManager, _address ) ) {\\n                reserveManagers.push( _address );\\n                ReserveManagerQueue[ _address ] = 0;\\n                if( !listContains( reserveManagers, _address ) ) {\\n                    reserveManagers.push( _address );\\n                }\\n            }\\n            result = !isReserveManager[ _address ];\\n            isReserveManager[ _address ] = result;\\n\\n        } else if ( _managing == MANAGING.LIQUIDITYDEPOSITOR ) { // 4\\n            if ( requirements( LiquidityDepositorQueue, isLiquidityDepositor, _address ) ) {\\n                liquidityDepositors.push( _address );\\n                LiquidityDepositorQueue[ _address ] = 0;\\n                if( !listContains( liquidityDepositors, _address ) ) {\\n                    liquidityDepositors.push( _address );\\n                }\\n            }\\n            result = !isLiquidityDepositor[ _address ];\\n            isLiquidityDepositor[ _address ] = result;\\n\\n        } else if ( _managing == MANAGING.LIQUIDITYTOKEN ) { // 5\\n            if ( requirements( LiquidityTokenQueue, isLiquidityToken, _address ) ) {\\n                LiquidityTokenQueue[ _address ] = 0;\\n                if( !listContains( liquidityTokens, _address ) ) {\\n                    liquidityTokens.push( _address );\\n                }\\n            }\\n            result = !isLiquidityToken[ _address ];\\n            isLiquidityToken[ _address ] = result;\\n            bondCalculator[ _address ] = _calculator;\\n\\n        } else if ( _managing == MANAGING.LIQUIDITYMANAGER ) { // 6\\n            if ( requirements( LiquidityManagerQueue, isLiquidityManager, _address ) ) {\\n                LiquidityManagerQueue[ _address ] = 0;\\n                if( !listContains( liquidityManagers, _address ) ) {\\n                    liquidityManagers.push( _address );\\n                }\\n            }\\n            result = !isLiquidityManager[ _address ];\\n            isLiquidityManager[ _address ] = result;\\n\\n        } else if ( _managing == MANAGING.DEBTOR ) { // 7\\n            if ( requirements( debtorQueue, isDebtor, _address ) ) {\\n                debtorQueue[ _address ] = 0;\\n                if( !listContains( debtors, _address ) ) {\\n                    debtors.push( _address );\\n                }\\n            }\\n            result = !isDebtor[ _address ];\\n            isDebtor[ _address ] = result;\\n\\n        } else if ( _managing == MANAGING.REWARDMANAGER ) { // 8\\n            if ( requirements( rewardManagerQueue, isRewardManager, _address ) ) {\\n                rewardManagerQueue[ _address ] = 0;\\n                if( !listContains( rewardManagers, _address ) ) {\\n                    rewardManagers.push( _address );\\n                }\\n            }\\n            result = !isRewardManager[ _address ];\\n            isRewardManager[ _address ] = result;\\n\\n        } else if ( _managing == MANAGING.SROME ) { // 9\\n            sROMEQueue = 0;\\n            sROME = _address;\\n            result = true;\\n\\n        } else return false;\\n\\n        emit ChangeActivated( _managing, _address, result );\\n        return true;\\n    }\\n\\n    /**\\n        @notice checks requirements and returns altered structs\\n        @param queue_ mapping( address => uint )\\n        @param status_ mapping( address => bool )\\n        @param _address address\\n        @return bool \\n     */\\n    function requirements( \\n        mapping( address => uint ) storage queue_, \\n        mapping( address => bool ) storage status_, \\n        address _address \\n    ) internal view returns ( bool ) {\\n        if ( !status_[ _address ] ) {\\n            require( queue_[ _address ] != 0, \\\"Must queue\\\" );\\n            require( queue_[ _address ] <= block.number, \\\"Queue not expired\\\" );\\n            return true;\\n        } return false;\\n    }\\n\\n    /**\\n        @notice checks array to ensure against duplicate\\n        @param _list address[]\\n        @param _token address\\n        @return bool\\n     */\\n    function listContains( address[] storage _list, address _token ) internal view returns ( bool ) {\\n        for( uint i = 0; i < _list.length; i++ ) {\\n            if( _list[ i ] == _token ) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\"\n    },\n    \"src/libraries/SafeERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\n    },\n    \"src/interfaces/IERC20Metadata.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity >=0.7.5;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\"\n    },\n    \"src/libraries/Address.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n    function addressToString(address _address) internal pure returns(string memory) {\\n        bytes32 _bytes = bytes32(uint256(_address));\\n        bytes memory HEX = \\\"0123456789abcdef\\\";\\n        bytes memory _addr = new bytes(42);\\n\\n        _addr[0] = '0';\\n        _addr[1] = 'x';\\n\\n        for(uint256 i = 0; i < 20; i++) {\\n            _addr[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\\n            _addr[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\\n        }\\n\\n        return string(_addr);\\n\\n    }\\n}\\n\"\n    },\n    \"src/Bonds/ROMEMIMBondDepository.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport \\\"../types/Policy.sol\\\";\\n\\nimport \\\"../types/ERC20Permit.sol\\\";\\n\\nimport \\\"../libraries/SafeERC20.sol\\\";\\n\\nimport \\\"../libraries/FixedPoint.sol\\\";\\n\\nimport \\\"../interfaces/IERC20Metadata.sol\\\";\\n\\ninterface ITreasury {\\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( bool );\\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\\n}\\n\\ninterface IBondCalculator {\\n    function valuation( address _LP, uint _amount ) external view returns ( uint );\\n    function markdown( address _LP ) external view returns ( uint );\\n}\\n\\ninterface IStaking {\\n    function stake( uint _amount, address _recipient ) external returns ( bool );\\n}\\n\\ninterface IStakingHelper {\\n    function stake( uint _amount, address _recipient ) external;\\n}\\n\\ncontract ROMEMIMBondDepository is Policy {\\n\\n    using FixedPoint for *;\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint;\\n\\n\\n\\n\\n    /* ======== EVENTS ======== */\\n\\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\\n\\n\\n\\n\\n    /* ======== STATE VARIABLES ======== */\\n\\n    address public immutable ROME; // token given as payment for bond\\n    address public immutable principle; // token used to create bond\\n    address public immutable treasury; // mints ROME when receives principle\\n    address public immutable WARCHEST; // receives fee from principle\\n\\n    bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\\n    address public immutable bondCalculator; // calculates value of LP tokens\\n\\n    address public staking; // to auto-stake payout\\n    address public stakingHelper; // to stake and claim if no staking warmup\\n    bool public useHelper;\\n\\n    Terms public terms; // stores terms for new bonds\\n    Adjust public adjustment; // stores adjustment to BCV data\\n\\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\\n\\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\\n    uint public lastDecay; // reference block for debt decay\\n\\n\\n\\n\\n\\n    /* ======== STRUCTS ======== */\\n\\n    // Info for creating new bonds\\n    struct Terms {\\n        uint controlVariable; // scaling variable for price\\n        uint vestingTerm; // in blocks\\n        uint minimumPrice; // vs principle value\\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\n        uint fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)]\\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\\n    }\\n\\n    // Info for bond holder\\n    struct Bond {\\n        uint payout; // ROME remaining to be paid\\n        uint vesting; // Blocks left to vest\\n        uint lastBlock; // Last interaction\\n        uint pricePaid; // In DAI, for front end viewing\\n    }\\n\\n    // Info for incremental adjustments to control variable \\n    struct Adjust {\\n        bool add; // addition or subtraction\\n        uint rate; // increment\\n        uint target; // BCV when adjustment finished\\n        uint buffer; // minimum length (in blocks) between adjustments\\n        uint lastBlock; // block when last adjustment made\\n    }\\n\\n\\n\\n\\n    /* ======== INITIALIZATION ======== */\\n\\n    constructor ( \\n        address _ROME,\\n        address _principle,\\n        address _treasury, \\n        address _WARCHEST,\\n        address _bondCalculator\\n    ) {\\n        require( _ROME != address(0) );\\n        ROME = _ROME;\\n        require( _principle != address(0) );\\n        principle = _principle;\\n        require( _treasury != address(0) );\\n        treasury = _treasury;\\n        require( _WARCHEST != address(0) );\\n        WARCHEST = _WARCHEST;\\n        // bondCalculator should be address(0) if not LP bond\\n        bondCalculator = _bondCalculator;\\n        isLiquidityBond = ( _bondCalculator != address(0) );\\n    }\\n\\n    /**\\n     *  @notice initializes bond parameters\\n     *  @param _controlVariable uint\\n     *  @param _vestingTerm uint\\n     *  @param _minimumPrice uint\\n     *  @param _maxPayout uint\\n     *  @param _fee uint\\n     *  @param _maxDebt uint\\n     *  @param _initialDebt uint\\n     */\\n    function initializeBondTerms( \\n        uint _controlVariable, \\n        uint _vestingTerm,\\n        uint _minimumPrice,\\n        uint _maxPayout,\\n        uint _fee,\\n        uint _maxDebt,\\n        uint _initialDebt\\n    ) external onlyPolicy() {\\n        require( terms.controlVariable == 0, \\\"Bonds must be initialized from 0\\\" );\\n        terms = Terms ({\\n            controlVariable: _controlVariable,\\n            vestingTerm: _vestingTerm,\\n            minimumPrice: _minimumPrice,\\n            maxPayout: _maxPayout,\\n            fee: _fee,\\n            maxDebt: _maxDebt\\n        });\\n        totalDebt = _initialDebt;\\n        lastDecay = block.number;\\n    }\\n\\n\\n\\n    \\n    /* ======== POLICY FUNCTIONS ======== */\\n\\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT }\\n    /**\\n     *  @notice set parameters for new bonds\\n     *  @param _parameter PARAMETER\\n     *  @param _input uint\\n     */\\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyPolicy() {\\n        if ( _parameter == PARAMETER.VESTING ) { // 0\\n            require( _input >= 10000, \\\"Vesting must be longer than 36 hours\\\" );\\n            terms.vestingTerm = _input;\\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\\n            require( _input <= 1000, \\\"Payout cannot be above 1 percent\\\" );\\n            terms.maxPayout = _input;\\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\\n            require( _input <= 1000, \\\"WARCHEST fee cannot exceed 10 percent\\\" );\\n            terms.fee = _input;\\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\\n            terms.maxDebt = _input;\\n        }\\n    }\\n\\n    /**\\n     *  @notice set control variable adjustment\\n     *  @param _addition bool\\n     *  @param _increment uint\\n     *  @param _target uint\\n     *  @param _buffer uint\\n     */\\n    function setAdjustment ( \\n        bool _addition,\\n        uint _increment, \\n        uint _target,\\n        uint _buffer \\n    ) external onlyPolicy() {\\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \\\"Increment too large\\\" );\\n\\n        adjustment = Adjust({\\n            add: _addition,\\n            rate: _increment,\\n            target: _target,\\n            buffer: _buffer,\\n            lastBlock: block.number\\n        });\\n    }\\n\\n    /**\\n     *  @notice set contract for auto stake\\n     *  @param _staking address\\n     *  @param _helper bool\\n     */\\n    function setStaking( address _staking, bool _helper ) external onlyPolicy() {\\n        require( _staking != address(0) );\\n        if ( _helper ) {\\n            useHelper = true;\\n            stakingHelper = _staking;\\n        } else {\\n            useHelper = false;\\n            staking = _staking;\\n        }\\n    }\\n\\n\\n    \\n\\n    /* ======== USER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice deposit bond\\n     *  @param _amount uint\\n     *  @param _maxPrice uint\\n     *  @param _depositor address\\n     *  @return uint\\n     */\\n    function deposit( \\n        uint _amount, \\n        uint _maxPrice,\\n        address _depositor\\n    ) external returns ( uint ) {\\n        require( _depositor != address(0), \\\"Invalid address\\\" );\\n\\n        decayDebt();\\n        require( totalDebt <= terms.maxDebt && terms.maxDebt > 0, \\\"Max capacity reached\\\" );\\n\\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\\n        uint nativePrice = _bondPrice();\\n\\n        require( _maxPrice >= nativePrice, \\\"Slippage limit: more than max price\\\" ); // slippage protection\\n\\n        uint value = ITreasury( treasury ).valueOf( principle, _amount );\\n        uint payout = payoutFor( value ); // payout to bonder is computed\\n\\n        require( payout >= 10000000, \\\"Bond too small\\\" ); // must be > 0.01 ROME ( underflow protection )\\n        require( payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\n\\n        // profits are calculated\\n        uint fee = payout.mul( terms.fee ).div( 10000 );\\n        uint profit = value.sub( payout ).sub( fee );\\n\\n        /**\\n            principle is transferred in\\n            approved and\\n            deposited into the treasury, returning (_amount - profit) ROME\\n         */\\n        IERC20( principle ).safeTransferFrom( msg.sender, address(this), _amount );\\n        IERC20( principle ).approve( address( treasury ), _amount );\\n        ITreasury( treasury ).deposit( _amount, principle, profit );\\n        \\n        if ( fee != 0 ) { // fee is transferred to WARCHEST\\n            IERC20( ROME ).safeTransfer( WARCHEST, fee );\\n        }\\n        \\n        // total debt is increased\\n        totalDebt = totalDebt.add( value ); \\n                \\n        // depositor info is stored\\n        bondInfo[ _depositor ] = Bond({ \\n            payout: bondInfo[ _depositor ].payout.add( payout ),\\n            vesting: terms.vestingTerm,\\n            lastBlock: block.number,\\n            pricePaid: priceInUSD\\n        });\\n\\n        // indexed events are emitted\\n        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );\\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\\n\\n        adjust(); // control variable is adjusted\\n        return payout; \\n    }\\n\\n    /** \\n     *  @notice redeem bond for user\\n     *  @param _recipient address\\n     *  @param _stake bool\\n     *  @return uint\\n     */ \\n    function redeem( address _recipient, bool _stake ) external returns ( uint ) {        \\n        Bond memory info = bondInfo[ _recipient ];\\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\\n\\n        if ( percentVested >= 10000 ) { // if fully vested\\n            delete bondInfo[ _recipient ]; // delete user info\\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\\n            return stakeOrSend( _recipient, _stake, info.payout ); // pay user everything due\\n\\n        } else { // if unfinished\\n            // calculate payout vested\\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\\n\\n            // store updated deposit info\\n            bondInfo[ _recipient ] = Bond({\\n                payout: info.payout.sub( payout ),\\n                vesting: info.vesting.sub( block.number.sub( info.lastBlock ) ),\\n                lastBlock: block.number,\\n                pricePaid: info.pricePaid\\n            });\\n\\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\\n            return stakeOrSend( _recipient, _stake, payout );\\n        }\\n    }\\n\\n\\n\\n    \\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice allow user to stake payout automatically\\n     *  @param _stake bool\\n     *  @param _amount uint\\n     *  @return uint\\n     */\\n    function stakeOrSend( address _recipient, bool _stake, uint _amount ) internal returns ( uint ) {\\n        if ( !_stake ) { // if user does not want to stake\\n            IERC20( ROME ).transfer( _recipient, _amount ); // send payout\\n        } else { // if user wants to stake\\n            if ( useHelper ) { // use if staking warmup is 0\\n                IERC20( ROME ).approve( stakingHelper, _amount );\\n                IStakingHelper( stakingHelper ).stake( _amount, _recipient );\\n            } else {\\n                IERC20( ROME ).approve( staking, _amount );\\n                IStaking( staking ).stake( _amount, _recipient );\\n            }\\n        }\\n        return _amount;\\n    }\\n\\n    /**\\n     *  @notice makes incremental adjustment to control variable\\n     */\\n    function adjust() internal {\\n        uint blockCanAdjust = adjustment.lastBlock.add( adjustment.buffer );\\n        if( adjustment.rate != 0 && block.number >= blockCanAdjust ) {\\n            uint initial = terms.controlVariable;\\n            if ( adjustment.add ) {\\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\\n                if ( terms.controlVariable >= adjustment.target ) {\\n                    adjustment.rate = 0;\\n                }\\n            } else {\\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\\n                if ( terms.controlVariable <= adjustment.target ) {\\n                    adjustment.rate = 0;\\n                }\\n            }\\n            adjustment.lastBlock = block.number;\\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\\n        }\\n    }\\n\\n    /**\\n     *  @notice reduce total debt\\n     */\\n    function decayDebt() internal {\\n        totalDebt = totalDebt.sub( debtDecay() );\\n        lastDecay = block.number;\\n    }\\n\\n\\n\\n\\n    /* ======== VIEW FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice determine maximum bond size\\n     *  @return uint\\n     */\\n    function maxPayout() public view returns ( uint ) {\\n        return IERC20( ROME ).totalSupply().mul( terms.maxPayout ).div( 100000 );\\n    }\\n\\n    /**\\n     *  @notice calculate interest due for new bond\\n     *  @param _value uint\\n     *  @return uint\\n     */\\n    function payoutFor( uint _value ) public view returns ( uint ) {\\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e16 );\\n    }\\n\\n\\n    /**\\n     *  @notice calculate current bond premium\\n     *  @return price_ uint\\n     */\\n    function bondPrice() public view returns ( uint price_ ) {        \\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\\n        if ( price_ < terms.minimumPrice ) {\\n            price_ = terms.minimumPrice;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate current bond price and remove floor if above\\n     *  @return price_ uint\\n     */\\n    function _bondPrice() internal returns ( uint price_ ) {\\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\\n        if ( price_ < terms.minimumPrice ) {\\n            price_ = terms.minimumPrice;        \\n        } else if ( terms.minimumPrice != 0 ) {\\n            terms.minimumPrice = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice converts bond price to DAI value\\n     *  @return price_ uint\\n     */\\n    function bondPriceInUSD() public view returns ( uint price_ ) {\\n        if( isLiquidityBond ) {\\n            price_ = bondPrice().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 100 );\\n        } else {\\n            price_ = bondPrice().mul( 10 ** IERC20Metadata( principle ).decimals() ).div( 100 );\\n        }\\n    }\\n\\n\\n    /**\\n     *  @notice calculate current ratio of debt to ROME supply\\n     *  @return debtRatio_ uint\\n     */\\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \\n        uint supply = IERC20( ROME ).totalSupply();\\n        debtRatio_ = FixedPoint.fraction( \\n            currentDebt().mul( 1e9 ), \\n            supply\\n        ).decode112with18().div( 1e18 );\\n    }\\n\\n    /**\\n     *  @notice debt ratio in same terms for reserve or liquidity bonds\\n     *  @return uint\\n     */\\n    function standardizedDebtRatio() external view returns ( uint ) {\\n        if ( isLiquidityBond ) {\\n            return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\\n        } else {\\n            return debtRatio();\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate debt factoring in decay\\n     *  @return uint\\n     */\\n    function currentDebt() public view returns ( uint ) {\\n        return totalDebt.sub( debtDecay() );\\n    }\\n\\n    /**\\n     *  @notice amount to decay total debt by\\n     *  @return decay_ uint\\n     */\\n    function debtDecay() public view returns ( uint decay_ ) {\\n        uint blocksSinceLast = block.number.sub( lastDecay );\\n        decay_ = totalDebt.mul( blocksSinceLast ).div( terms.vestingTerm );\\n        if ( decay_ > totalDebt ) {\\n            decay_ = totalDebt;\\n        }\\n    }\\n\\n\\n    /**\\n     *  @notice calculate how far into vesting a depositor is\\n     *  @param _depositor address\\n     *  @return percentVested_ uint\\n     */\\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\\n        Bond memory bond = bondInfo[ _depositor ];\\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\\n        uint vesting = bond.vesting;\\n\\n        if ( vesting > 0 ) {\\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\\n        } else {\\n            percentVested_ = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate amount of ROME available for claim by depositor\\n     *  @param _depositor address\\n     *  @return pendingPayout_ uint\\n     */\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\\n        uint percentVested = percentVestedFor( _depositor );\\n        uint payout = bondInfo[ _depositor ].payout;\\n\\n        if ( percentVested >= 10000 ) {\\n            pendingPayout_ = payout;\\n        } else {\\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\\n        }\\n    }\\n\\n\\n\\n\\n    /* ======= AUXILLIARY ======= */\\n\\n    /**\\n     *  @notice allow anyone to send lost tokens (excluding principle or ROME) to the WARCHEST\\n     *  @return bool\\n     */\\n    function recoverLostToken( address _token ) external returns ( bool ) {\\n        require( _token != ROME );\\n        require( _token != principle );\\n        IERC20( _token ).safeTransfer( WARCHEST, IERC20( _token ).balanceOf( address(this) ) );\\n        return true;\\n    }\\n}\\n\"\n    },\n    \"src/libraries/FixedPoint.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nlibrary FullMath {\\n    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\\n        uint256 mm = mulmod(x, y, uint256(-1));\\n        l = x * y;\\n        h = mm - l;\\n        if (mm < l) h -= 1;\\n    }\\n\\n    function fullDiv(\\n        uint256 l,\\n        uint256 h,\\n        uint256 d\\n    ) private pure returns (uint256) {\\n        uint256 pow2 = d & -d;\\n        d /= pow2;\\n        l /= pow2;\\n        l += h * ((-pow2) / pow2 + 1);\\n        uint256 r = 1;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        return l * r;\\n    }\\n\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d\\n    ) internal pure returns (uint256) {\\n        (uint256 l, uint256 h) = fullMul(x, y);\\n        uint256 mm = mulmod(x, y, d);\\n        if (mm > l) h -= 1;\\n        l -= mm;\\n        require(h < d, 'FullMath::mulDiv: overflow');\\n        return fullDiv(l, h, d);\\n    }\\n}\\n\\nlibrary FixedPoint {\\n\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    struct uq144x112 {\\n        uint256 _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\\n\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\\n\\n        return uint(self._x) / 5192296858534827;\\n    }\\n\\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\\n        if (numerator == 0) return FixedPoint.uq112x112(0);\\n\\n        if (numerator <= uint144(-1)) {\\n            uint256 result = (numerator << RESOLUTION) / denominator;\\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\\n            return uq112x112(uint224(result));\\n        } else {\\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\\n            return uq112x112(uint224(result));\\n        }\\n    }\\n}\\n\"\n    },\n    \"src/Bonds/ROMEMOVRBondDepository.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport \\\"../types/Policy.sol\\\";\\n\\nimport \\\"../types/ERC20Permit.sol\\\";\\n\\nimport \\\"../libraries/SafeERC20.sol\\\";\\n\\nimport \\\"../libraries/FixedPoint.sol\\\";\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\\ninterface ITreasury {\\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( bool );\\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\\n    function mintRewards( address _recipient, uint _amount ) external;\\n}\\n\\ninterface IBondCalculator {\\n    function valuation( address _LP, uint _amount ) external view returns ( uint );\\n    function markdown( address _LP ) external view returns ( uint );\\n}\\n\\ninterface IStaking {\\n    function stake( uint _amount, address _recipient ) external returns ( bool );\\n}\\n\\ninterface IStakingHelper {\\n    function stake( uint _amount, address _recipient ) external;\\n}\\n\\ncontract ROMEMOVRBondDepository is Policy {\\n\\n    using FixedPoint for *;\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint;\\n\\n\\n\\n\\n    /* ======== EVENTS ======== */\\n\\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\\n\\n\\n\\n\\n    /* ======== STATE VARIABLES ======== */\\n\\n    address public immutable ROME; // token given as payment for bond\\n    address public immutable principle; // token used to create bond\\n    address public immutable treasury; // mints ROME when receives principle\\n    address public immutable WARCHEST; // receives fee share from bond\\n\\n    address public immutable bondCalculator; // calculates value of LP tokens\\n\\n    AggregatorV3Interface internal priceFeed;\\n\\n    address public staking; // to auto-stake payout\\n    address public stakingHelper; // to stake and claim if no staking warmup\\n    bool public useHelper;\\n\\n    Terms public terms; // stores terms for new bonds\\n    Adjust public adjustment; // stores adjustment to BCV data\\n\\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\\n\\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\\n    uint public lastDecay; // reference block for debt decay\\n\\n\\n\\n    /* ======== STRUCTS ======== */\\n\\n    // Info for creating new bonds\\n    struct Terms {\\n        uint controlVariable; // scaling variable for price\\n        uint vestingTerm; // in blocks\\n        uint minimumPrice; // vs principle value. 4 decimals (1500 = 0.15)\\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\n        uint fee; // as % of bond principle, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)]\\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\\n    }\\n\\n    // Info for bond holder\\n    struct Bond {\\n        uint payout; // ROME remaining to be paid\\n        uint vesting; // Blocks left to vest\\n        uint lastBlock; // Last interaction\\n        uint pricePaid; // In DAI, for front end viewing\\n    }\\n\\n    // Info for incremental adjustments to control variable \\n    struct Adjust {\\n        bool add; // addition or subtraction\\n        uint rate; // increment\\n        uint target; // BCV when adjustment finished\\n        uint buffer; // minimum length (in blocks) between adjustments\\n        uint lastBlock; // block when last adjustment made\\n    }\\n\\n\\n\\n\\n    /* ======== INITIALIZATION ======== */\\n\\n    constructor ( \\n        address _ROME,\\n        address _principle,\\n        address _treasury, \\n        address _WARCHEST,\\n        address _bondCalculator,\\n        address _feed\\n    ) {\\n        require( _ROME != address(0) );\\n        ROME = _ROME;\\n        require( _principle != address(0) );\\n        principle = _principle;\\n        require( _treasury != address(0) );\\n        treasury = _treasury;\\n        require( _WARCHEST != address(0) );\\n        WARCHEST = _WARCHEST;\\n        // bondCalculator should be address(0) if not LP bond\\n        bondCalculator = _bondCalculator;\\n        priceFeed = AggregatorV3Interface( _feed );\\n    }\\n\\n    /**\\n     *  @notice initializes bond parameters\\n     *  @param _controlVariable uint\\n     *  @param _vestingTerm uint\\n     *  @param _minimumPrice uint\\n     *  @param _maxPayout uint\\n     *  @param _maxDebt uint\\n     *  @param _initialDebt uint\\n     */\\n    function initializeBondTerms( \\n        uint _controlVariable, \\n        uint _vestingTerm,\\n        uint _minimumPrice,\\n        uint _maxPayout,\\n        uint _fee,\\n        uint _maxDebt,\\n        uint _initialDebt\\n    ) external onlyPolicy() {\\n        require( terms.controlVariable == 0, \\\"Bonds must be initialized from 0\\\" );\\n        terms = Terms ({\\n            controlVariable: _controlVariable,\\n            vestingTerm: _vestingTerm,\\n            minimumPrice: _minimumPrice,\\n            maxPayout: _maxPayout,\\n            fee: _fee,\\n            maxDebt: _maxDebt\\n        });\\n        totalDebt = _initialDebt;\\n        lastDecay = block.number;\\n    }\\n\\n\\n\\n    \\n    /* ======== POLICY FUNCTIONS ======== */\\n\\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT }\\n    /**\\n     *  @notice set parameters for new bonds\\n     *  @param _parameter PARAMETER\\n     *  @param _input uint\\n     */\\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyPolicy() {\\n        if ( _parameter == PARAMETER.VESTING ) { // 0\\n            require( _input >= 10000, \\\"Vesting must be longer than 36 hours\\\" );\\n            terms.vestingTerm = _input;\\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\\n            require( _input <= 1000, \\\"Payout cannot be above 1 percent\\\" );\\n            terms.maxPayout = _input;\\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\\n            require( _input <= 1000, \\\"WARCHEST fee cannot exceed 10 percent\\\" );\\n            terms.fee = _input;\\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\\n            terms.maxDebt = _input;\\n        }\\n    }\\n\\n    /**\\n     *  @notice set control variable adjustment\\n     *  @param _addition bool\\n     *  @param _increment uint\\n     *  @param _target uint\\n     *  @param _buffer uint\\n     */\\n    function setAdjustment ( \\n        bool _addition,\\n        uint _increment, \\n        uint _target,\\n        uint _buffer \\n    ) external onlyPolicy() {\\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \\\"Increment too large\\\" );\\n\\n        adjustment = Adjust({\\n            add: _addition,\\n            rate: _increment,\\n            target: _target,\\n            buffer: _buffer,\\n            lastBlock: block.number\\n        });\\n    }\\n\\n    /**\\n     *  @notice set contract for auto stake\\n     *  @param _staking address\\n     *  @param _helper bool\\n     */\\n    function setStaking( address _staking, bool _helper ) external onlyPolicy() {\\n        require( _staking != address(0) );\\n        if ( _helper ) {\\n            useHelper = true;\\n            stakingHelper = _staking;\\n        } else {\\n            useHelper = false;\\n            staking = _staking;\\n        }\\n    }\\n\\n\\n    \\n\\n    /* ======== USER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice deposit bond\\n     *  @param _amount uint\\n     *  @param _maxPrice uint\\n     *  @param _depositor address\\n     *  @return uint\\n     */\\n    function deposit( \\n        uint _amount, \\n        uint _maxPrice,\\n        address _depositor\\n    ) external returns ( uint ) {\\n        require( _depositor != address(0), \\\"Invalid address\\\" );\\n\\n        decayDebt();\\n        require( totalDebt <= terms.maxDebt && terms.maxDebt > 0, \\\"Max capacity reached\\\" );\\n\\n        // feees are calculated\\n        uint fee = _amount.mul( terms.fee ).div( 10000 );\\n        _amount = _amount.sub( fee );\\n\\n        if ( fee != 0 ) { // fee is transferred to warchest\\n            IERC20( principle ).safeTransfer( WARCHEST, fee );\\n        }\\n        \\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\\n        uint nativePrice = _bondPrice();\\n\\n        require( _maxPrice >= nativePrice, \\\"Slippage limit: more than max price\\\" ); // slippage protection\\n\\n        uint value = ITreasury( treasury ).valueOf( principle, _amount );\\n        uint payout = payoutFor( value ); // payout to bonder is computed\\n\\n        require( payout >= 10000000, \\\"Bond too small\\\" ); // must be > 0.01 ROME ( underflow protection )\\n        require( payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\n\\n        /**\\n            asset carries risk and is not minted against\\n            asset transfered to treasury and rewards minted as payout\\n         */\\n        IERC20( principle ).safeTransferFrom( msg.sender, treasury, _amount );\\n        ITreasury( treasury ).mintRewards( address(this), payout );\\n        \\n        // total debt is increased\\n        totalDebt = totalDebt.add( value ); \\n                \\n        // depositor info is stored\\n        bondInfo[ _depositor ] = Bond({ \\n            payout: bondInfo[ _depositor ].payout.add( payout ),\\n            vesting: terms.vestingTerm,\\n            lastBlock: block.number,\\n            pricePaid: priceInUSD\\n        });\\n\\n        // indexed events are emitted\\n        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );\\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\\n\\n        adjust(); // control variable is adjusted\\n        return payout; \\n    }\\n\\n    /** \\n     *  @notice redeem bond for user\\n     *  @param _recipient address\\n     *  @param _stake bool\\n     *  @return uint\\n     */ \\n    function redeem( address _recipient, bool _stake ) external returns ( uint ) {        \\n        Bond memory info = bondInfo[ _recipient ];\\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\\n\\n        if ( percentVested >= 10000 ) { // if fully vested\\n            delete bondInfo[ _recipient ]; // delete user info\\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\\n            return stakeOrSend( _recipient, _stake, info.payout ); // pay user everything due\\n\\n        } else { // if unfinished\\n            // calculate payout vested\\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\\n\\n            // store updated deposit info\\n            bondInfo[ _recipient ] = Bond({\\n                payout: info.payout.sub( payout ),\\n                vesting: info.vesting.sub( block.number.sub( info.lastBlock ) ),\\n                lastBlock: block.number,\\n                pricePaid: info.pricePaid\\n            });\\n\\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\\n            return stakeOrSend( _recipient, _stake, payout );\\n        }\\n    }\\n\\n\\n\\n    \\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice allow user to stake payout automatically\\n     *  @param _stake bool\\n     *  @param _amount uint\\n     *  @return uint\\n     */\\n    function stakeOrSend( address _recipient, bool _stake, uint _amount ) internal returns ( uint ) {\\n        if ( !_stake ) { // if user does not want to stake\\n            IERC20( ROME ).transfer( _recipient, _amount ); // send payout\\n        } else { // if user wants to stake\\n            if ( useHelper ) { // use if staking warmup is 0\\n                IERC20( ROME ).approve( stakingHelper, _amount );\\n                IStakingHelper( stakingHelper ).stake( _amount, _recipient );\\n            } else {\\n                IERC20( ROME ).approve( staking, _amount );\\n                IStaking( staking ).stake( _amount, _recipient );\\n            }\\n        }\\n        return _amount;\\n    }\\n\\n    /**\\n     *  @notice makes incremental adjustment to control variable\\n     */\\n    function adjust() internal {\\n        uint blockCanAdjust = adjustment.lastBlock.add( adjustment.buffer );\\n        if( adjustment.rate != 0 && block.number >= blockCanAdjust ) {\\n            uint initial = terms.controlVariable;\\n            if ( adjustment.add ) {\\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\\n                if ( terms.controlVariable >= adjustment.target ) {\\n                    adjustment.rate = 0;\\n                }\\n            } else {\\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\\n                if ( terms.controlVariable <= adjustment.target ) {\\n                    adjustment.rate = 0;\\n                }\\n            }\\n            adjustment.lastBlock = block.number;\\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\\n        }\\n    }\\n\\n    /**\\n     *  @notice reduce total debt\\n     */\\n    function decayDebt() internal {\\n        totalDebt = totalDebt.sub( debtDecay() );\\n        lastDecay = block.number;\\n    }\\n\\n\\n\\n\\n    /* ======== VIEW FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice determine maximum bond size\\n     *  @return uint\\n     */\\n    function maxPayout() public view returns ( uint ) {\\n        return IERC20( ROME ).totalSupply().mul( terms.maxPayout ).div( 100000 );\\n    }\\n\\n    /**\\n     *  @notice calculate interest due for new bond\\n     *  @param _value uint\\n     *  @return uint\\n     */\\n    function payoutFor( uint _value ) public view returns ( uint ) {\\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e14 );\\n    }\\n\\n\\n    /**\\n     *  @notice calculate current bond premium\\n     *  @return price_ uint\\n     */\\n    function bondPrice() public view returns ( uint price_ ) {        \\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\\n        if ( price_ < terms.minimumPrice ) {\\n            price_ = terms.minimumPrice;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate current bond price and remove floor if above\\n     *  @return price_ uint\\n     */\\n    function _bondPrice() internal returns ( uint price_ ) {\\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\\n        if ( price_ < terms.minimumPrice ) {\\n            price_ = terms.minimumPrice;        \\n        } else if ( terms.minimumPrice != 0 ) {\\n            terms.minimumPrice = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice get asset price from chainlink\\n     */\\n    function assetPrice() public view returns (int) {\\n        ( , int price, , , ) = priceFeed.latestRoundData();\\n        return price;\\n    }\\n\\n    /**\\n     *  @notice converts bond price to DAI value\\n     *  @return price_ uint\\n     */\\n    function bondPriceInUSD() public view returns ( uint price_ ) {\\n        if (bondCalculator == address(0)) {\\n            price_ = bondPrice().mul( uint( assetPrice() ) ).mul( 1e6 );\\n        } else {\\n            price_ = bondPrice()\\n                    .mul( IBondCalculator( bondCalculator ).markdown( principle ) )\\n                    .mul( uint( assetPrice() ) )\\n                    .div( 1e12 );\\n        }\\n    }\\n\\n\\n    /**\\n     *  @notice calculate current ratio of debt to ROME supply\\n     *  @return debtRatio_ uint\\n     */\\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \\n        debtRatio_ = FixedPoint.fraction(\\n            currentDebt().mul( 1e9 ),\\n            IERC20( ROME ).totalSupply()\\n        ).decode112with18().div( 1e18 );\\n    }\\n\\n\\n    /**\\n     *  @notice debt ratio in same terms as reserve bonds\\n     *  @return uint\\n     */\\n    function standardizedDebtRatio() external view returns ( uint ) {\\n        if (bondCalculator == address(0)) {\\n            return debtRatio().mul( uint( assetPrice() ) ).div( 1e8 ); // ETH feed is 8 decimals\\n        } else {\\n            return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate debt factoring in decay\\n     *  @return uint\\n     */\\n    function currentDebt() public view returns ( uint ) {\\n        return totalDebt.sub( debtDecay() );\\n    }\\n\\n    /**\\n     *  @notice amount to decay total debt by\\n     *  @return decay_ uint\\n     */\\n    function debtDecay() public view returns ( uint decay_ ) {\\n        uint blocksSinceLast = block.number.sub( lastDecay );\\n        decay_ = totalDebt.mul( blocksSinceLast ).div( terms.vestingTerm );\\n        if ( decay_ > totalDebt ) {\\n            decay_ = totalDebt;\\n        }\\n    }\\n\\n\\n    /**\\n     *  @notice calculate how far into vesting a depositor is\\n     *  @param _depositor address\\n     *  @return percentVested_ uint\\n     */\\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\\n        Bond memory bond = bondInfo[ _depositor ];\\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\\n        uint vesting = bond.vesting;\\n\\n        if ( vesting > 0 ) {\\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\\n        } else {\\n            percentVested_ = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate amount of ROME available for claim by depositor\\n     *  @param _depositor address\\n     *  @return pendingPayout_ uint\\n     */\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\\n        uint percentVested = percentVestedFor( _depositor );\\n        uint payout = bondInfo[ _depositor ].payout;\\n\\n        if ( percentVested >= 10000 ) {\\n            pendingPayout_ = payout;\\n        } else {\\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\\n        }\\n    }\\n\\n\\n\\n\\n    /* ======= AUXILLIARY ======= */\\n\\n    /**\\n     *  @notice allow anyone to send lost tokens (excluding principle or ROME) to the WARCHEST\\n     *  @return bool\\n     */\\n    function recoverLostToken( address _token ) external returns ( bool ) {\\n        require( _token != ROME );\\n        require( _token != principle );\\n        IERC20( _token ).safeTransfer( WARCHEST, IERC20( _token ).balanceOf( address(this) ) );\\n        return true;\\n    }\\n}\\n\"\n    },\n    \"src/Staking.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport \\\"./libraries/SafeERC20.sol\\\";\\n\\nimport \\\"./types/Policy.sol\\\";\\n\\ninterface IsROME {\\n    function rebase( uint256 romeProfit_, uint epoch_) external returns (uint256);\\n\\n    function circulatingSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function gonsForBalance( uint amount ) external view returns ( uint );\\n\\n    function balanceForGons( uint gons ) external view returns ( uint );\\n    \\n    function index() external view returns ( uint );\\n}\\n\\ninterface IWarmup {\\n    function retrieve( address staker_, uint amount_ ) external;\\n}\\n\\ninterface IDistributor {\\n    function distribute() external returns ( bool );\\n}\\n\\ncontract RomeStaking is Policy {\\n\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    address public immutable ROME;\\n    address public immutable sROME;\\n\\n    struct Epoch {\\n        uint length;\\n        uint number;\\n        uint endBlock;\\n        uint distribute;\\n    }\\n    Epoch public epoch;\\n\\n    address public distributor;\\n    \\n    address public locker;\\n    uint public totalBonus;\\n    \\n    address public warmupContract;\\n    uint public warmupPeriod;\\n    \\n    constructor ( \\n        address _ROME,\\n        address _sROME,\\n        uint _epochLength,\\n        uint _firstEpochNumber,\\n        uint _firstEpochBlock\\n    ) {\\n        require( _ROME != address(0) );\\n        ROME = _ROME;\\n        require( _sROME != address(0) );\\n        sROME = _sROME;\\n        require( _firstEpochNumber != 0);\\n        require( _firstEpochBlock != 0);\\n\\n        epoch = Epoch({\\n            length: _epochLength,\\n            number: _firstEpochNumber,\\n            endBlock: _firstEpochBlock,\\n            distribute: 0\\n        });\\n    }\\n\\n    struct Claim {\\n        uint deposit;\\n        uint gons;\\n        uint expiry;\\n        bool lock; // prevents malicious delays\\n    }\\n    mapping( address => Claim ) public warmupInfo;\\n\\n    /**\\n        @notice stake ROME to enter warmup\\n        @param _amount uint\\n        @return bool\\n     */\\n    function stake( uint _amount, address _recipient ) external returns ( bool ) {\\n        rebase();\\n        \\n        IERC20( ROME ).safeTransferFrom( msg.sender, address(this), _amount );\\n\\n        Claim memory info = warmupInfo[ _recipient ];\\n        require( !info.lock, \\\"Deposits for account are locked\\\" );\\n\\n        warmupInfo[ _recipient ] = Claim ({\\n            deposit: info.deposit.add( _amount ),\\n            gons: info.gons.add( IsROME( sROME ).gonsForBalance( _amount ) ),\\n            expiry: epoch.number.add( warmupPeriod ),\\n            lock: false\\n        });\\n        \\n        IERC20( sROME ).safeTransfer( warmupContract, _amount );\\n        return true;\\n    }\\n\\n    /**\\n        @notice retrieve sROME from warmup\\n        @param _recipient address\\n     */\\n    function claim ( address _recipient ) public {\\n        Claim memory info = warmupInfo[ _recipient ];\\n        if ( epoch.number >= info.expiry && info.expiry != 0 ) {\\n            delete warmupInfo[ _recipient ];\\n            IWarmup( warmupContract ).retrieve( _recipient, IsROME( sROME ).balanceForGons( info.gons ) );\\n        }\\n    }\\n\\n    /**\\n        @notice forfeit sROME in warmup and retrieve ROME\\n     */\\n    function forfeit() external {\\n        Claim memory info = warmupInfo[ msg.sender ];\\n        delete warmupInfo[ msg.sender ];\\n\\n        IWarmup( warmupContract ).retrieve( address(this), IsROME( sROME ).balanceForGons( info.gons ) );\\n        IERC20( ROME ).safeTransfer( msg.sender, info.deposit );\\n    }\\n\\n    /**\\n        @notice prevent new deposits to address (protection from malicious activity)\\n     */\\n    function toggleDepositLock() external {\\n        warmupInfo[ msg.sender ].lock = !warmupInfo[ msg.sender ].lock;\\n    }\\n\\n    /**\\n        @notice redeem sROME for ROME\\n        @param _amount uint\\n        @param _trigger bool\\n     */\\n    function unstake( uint _amount, bool _trigger ) external {\\n        if ( _trigger ) {\\n            rebase();\\n        }\\n        IERC20( sROME ).safeTransferFrom( msg.sender, address(this), _amount );\\n        IERC20( ROME ).safeTransfer( msg.sender, _amount );\\n    }\\n\\n    /**\\n        @notice returns the sROME index, which tracks rebase growth\\n        @return uint\\n     */\\n    function index() public view returns ( uint ) {\\n        return IsROME( sROME ).index();\\n    }\\n\\n    /**\\n        @notice trigger rebase if epoch over\\n     */\\n    function rebase() public {\\n        if( epoch.endBlock <= block.number ) {\\n\\n            IsROME( sROME ).rebase( epoch.distribute, epoch.number );\\n\\n            epoch.endBlock = epoch.endBlock.add( epoch.length );\\n            epoch.number++;\\n            \\n            if ( distributor != address(0) ) {\\n                IDistributor( distributor ).distribute();\\n            }\\n\\n            uint balance = contractBalance();\\n            uint staked = IsROME( sROME ).circulatingSupply();\\n\\n            if( balance <= staked ) {\\n                epoch.distribute = 0;\\n            } else {\\n                epoch.distribute = balance.sub( staked );\\n            }\\n        }\\n    }\\n\\n    /**\\n        @notice returns contract ROME holdings, including bonuses provided\\n        @return uint\\n     */\\n    function contractBalance() public view returns ( uint ) {\\n        return IERC20( ROME ).balanceOf( address(this) ).add( totalBonus );\\n    }\\n\\n    /**\\n        @notice provide bonus to locked staking contract\\n        @param _amount uint\\n     */\\n    function giveLockBonus( uint _amount ) external {\\n        require( msg.sender == locker );\\n        totalBonus = totalBonus.add( _amount );\\n        IERC20( sROME ).safeTransfer( locker, _amount );\\n    }\\n\\n    /**\\n        @notice reclaim bonus from locked staking contract\\n        @param _amount uint\\n     */\\n    function returnLockBonus( uint _amount ) external {\\n        require( msg.sender == locker );\\n        totalBonus = totalBonus.sub( _amount );\\n        IERC20( sROME ).safeTransferFrom( locker, address(this), _amount );\\n    }\\n\\n    enum CONTRACTS { DISTRIBUTOR, WARMUP, LOCKER }\\n\\n    /**\\n        @notice sets the contract address for LP staking\\n        @param _contract address\\n     */\\n    function setContract( CONTRACTS _contract, address _address ) external onlyPolicy() {\\n        if( _contract == CONTRACTS.DISTRIBUTOR ) { // 0\\n            distributor = _address;\\n        } else if ( _contract == CONTRACTS.WARMUP ) { // 1\\n            require( warmupContract == address( 0 ), \\\"Warmup cannot be set more than once\\\" );\\n            warmupContract = _address;\\n        } else if ( _contract == CONTRACTS.LOCKER ) { // 2\\n            require( locker == address(0), \\\"Locker cannot be set more than once\\\" );\\n            locker = _address;\\n        }\\n    }\\n    \\n    /**\\n     * @notice set warmup period for new stakers\\n     * @param _warmupPeriod uint\\n     */\\n    function setWarmup( uint _warmupPeriod ) external onlyPolicy() {\\n        warmupPeriod = _warmupPeriod;\\n    }\\n}\\n\"\n    },\n    \"src/Distributor.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity 0.7.5;\\n\\nimport './libraries/SafeERC20.sol';\\n\\nimport './types/Policy.sol';\\n\\n\\ninterface ITreasury {\\n    function mintRewards( address _recipient, uint _amount ) external;\\n}\\n\\ncontract Distributor is Policy {\\n    using SafeMath for uint;\\n    using SafeERC20 for IERC20;\\n    \\n    \\n    \\n    /* ====== VARIABLES ====== */\\n\\n    address public immutable ROME;\\n    address public immutable treasury;\\n    \\n    uint public immutable epochLength;\\n    uint public nextEpochBlock;\\n    \\n    mapping( uint => Adjust ) public adjustments;\\n    \\n    \\n    /* ====== STRUCTS ====== */\\n        \\n    struct Info {\\n        uint rate; // in ten-thousandths ( 5000 = 0.5% )\\n        address recipient;\\n    }\\n    Info[] public info;\\n    \\n    struct Adjust {\\n        bool add;\\n        uint rate;\\n        uint target;\\n    }\\n    \\n    \\n    \\n    /* ====== CONSTRUCTOR ====== */\\n\\n    constructor( address _treasury, address _rome, uint _epochLength, uint _nextEpochBlock ) {\\n        require( _treasury != address(0) );\\n        treasury = _treasury;\\n        require( _rome != address(0) );\\n        ROME = _rome;\\n        epochLength = _epochLength;\\n        nextEpochBlock = _nextEpochBlock;\\n    }\\n    \\n    \\n    \\n    /* ====== PUBLIC FUNCTIONS ====== */\\n    \\n    /**\\n        @notice send epoch reward to staking contract\\n     */\\n    function distribute() external returns ( bool ) {\\n        if ( nextEpochBlock <= block.number ) {\\n            nextEpochBlock = nextEpochBlock.add( epochLength ); // set next epoch block\\n            \\n            // distribute rewards to each recipient\\n            for ( uint i = 0; i < info.length; i++ ) {\\n                if ( info[ i ].rate > 0 ) {\\n                    ITreasury( treasury ).mintRewards( // mint and send from treasury\\n                        info[ i ].recipient, \\n                        nextRewardAt( info[ i ].rate ) \\n                    );\\n                    adjust( i ); // check for adjustment\\n                }\\n            }\\n            return true;\\n        } else { \\n            return false; \\n        }\\n    }\\n    \\n    \\n    \\n    /* ====== INTERNAL FUNCTIONS ====== */\\n\\n    /**\\n        @notice increment reward rate for collector\\n     */\\n    function adjust( uint _index ) internal {\\n        Adjust memory adjustment = adjustments[ _index ];\\n        if ( adjustment.rate != 0 ) {\\n            if ( adjustment.add ) { // if rate should increase\\n                info[ _index ].rate = info[ _index ].rate.add( adjustment.rate ); // raise rate\\n                if ( info[ _index ].rate >= adjustment.target ) { // if target met\\n                    adjustments[ _index ].rate = 0; // turn off adjustment\\n                }\\n            } else { // if rate should decrease\\n                info[ _index ].rate = info[ _index ].rate.sub( adjustment.rate ); // lower rate\\n                if ( info[ _index ].rate <= adjustment.target ) { // if target met\\n                    adjustments[ _index ].rate = 0; // turn off adjustment\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    \\n    /* ====== VIEW FUNCTIONS ====== */\\n\\n    /**\\n        @notice view function for next reward at given rate\\n        @param _rate uint\\n        @return uint\\n     */\\n    function nextRewardAt( uint _rate ) public view returns ( uint ) {\\n        return IERC20( ROME ).totalSupply().mul( _rate ).div( 1000000 );\\n    }\\n\\n    /**\\n        @notice view function for next reward for specified address\\n        @param _recipient address\\n        @return uint\\n     */\\n    function nextRewardFor( address _recipient ) public view returns ( uint ) {\\n        uint reward;\\n        for ( uint i = 0; i < info.length; i++ ) {\\n            if ( info[ i ].recipient == _recipient ) {\\n                reward = nextRewardAt( info[ i ].rate );\\n            }\\n        }\\n        return reward;\\n    }\\n    \\n    \\n    \\n    /* ====== POLICY FUNCTIONS ====== */\\n\\n    /**\\n        @notice adds recipient for distributions\\n        @param _recipient address\\n        @param _rewardRate uint\\n     */\\n    function addRecipient( address _recipient, uint _rewardRate ) external onlyPolicy() {\\n        require( _recipient != address(0) );\\n        info.push( Info({\\n            recipient: _recipient,\\n            rate: _rewardRate\\n        }));\\n    }\\n\\n    /**\\n        @notice removes recipient for distributions\\n        @param _index uint\\n        @param _recipient address\\n     */\\n    function removeRecipient( uint _index, address _recipient ) external onlyPolicy() {\\n        require( _recipient == info[ _index ].recipient );\\n        info[ _index ].recipient = address(0);\\n        info[ _index ].rate = 0;\\n    }\\n\\n    /**\\n        @notice set adjustment info for a collector's reward rate\\n        @param _index uint\\n        @param _add bool\\n        @param _rate uint\\n        @param _target uint\\n     */\\n    function setAdjustment( uint _index, bool _add, uint _rate, uint _target ) external onlyPolicy() {\\n        adjustments[ _index ] = Adjust({\\n            add: _add,\\n            rate: _rate,\\n            target: _target\\n        });\\n    }\\n}\\n\"\n    },\n    \"src/Bonds/ROMEFRAXBondDepository.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport \\\"../types/Policy.sol\\\";\\n\\nimport \\\"../types/ERC20Permit.sol\\\";\\n\\nimport \\\"../libraries/SafeERC20.sol\\\";\\n\\nimport \\\"../libraries/FixedPoint.sol\\\";\\n\\nimport \\\"../interfaces/IERC20Metadata.sol\\\";\\n\\ninterface ITreasury {\\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( bool );\\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\\n}\\n\\ninterface IBondCalculator {\\n    function valuation( address _LP, uint _amount ) external view returns ( uint );\\n    function markdown( address _LP ) external view returns ( uint );\\n}\\n\\ninterface IStaking {\\n    function stake( uint _amount, address _recipient ) external returns ( bool );\\n}\\n\\ninterface IStakingHelper {\\n    function stake( uint _amount, address _recipient ) external;\\n}\\n\\ncontract ROMEFRAXBondDepository is Policy {\\n\\n    using FixedPoint for *;\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint;\\n\\n\\n\\n\\n    /* ======== EVENTS ======== */\\n\\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\\n\\n\\n\\n\\n    /* ======== STATE VARIABLES ======== */\\n\\n    address public immutable ROME; // token given as payment for bond\\n    address public immutable principle; // token used to create bond\\n    address public immutable treasury; // mints ROME when receives principle\\n    address public immutable WARCHEST; // receives fee from principle\\n\\n    bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\\n    address public immutable bondCalculator; // calculates value of LP tokens\\n\\n    address public staking; // to auto-stake payout\\n    address public stakingHelper; // to stake and claim if no staking warmup\\n    bool public useHelper;\\n\\n    Terms public terms; // stores terms for new bonds\\n    Adjust public adjustment; // stores adjustment to BCV data\\n\\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\\n\\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\\n    uint public lastDecay; // reference block for debt decay\\n\\n\\n    /* ======== STRUCTS ======== */\\n\\n    // Info for creating new bonds\\n    struct Terms {\\n        uint controlVariable; // scaling variable for price\\n        uint vestingTerm; // in blocks\\n        uint minimumPrice; // vs principle value\\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\n        uint fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)]\\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\\n    }\\n\\n    // Info for bond holder\\n    struct Bond {\\n        uint payout; // ROME remaining to be paid\\n        uint vesting; // Blocks left to vest\\n        uint lastBlock; // Last interaction\\n        uint pricePaid; // In DAI, for front end viewing\\n    }\\n\\n    // Info for incremental adjustments to control variable \\n    struct Adjust {\\n        bool add; // addition or subtraction\\n        uint rate; // increment\\n        uint target; // BCV when adjustment finished\\n        uint buffer; // minimum length (in blocks) between adjustments\\n        uint lastBlock; // block when last adjustment made\\n    }\\n\\n\\n\\n\\n    /* ======== INITIALIZATION ======== */\\n\\n    constructor ( \\n        address _ROME,\\n        address _principle,\\n        address _treasury, \\n        address _WARCHEST,\\n        address _bondCalculator\\n    ) {\\n        require( _ROME != address(0) );\\n        ROME = _ROME;\\n        require( _principle != address(0) );\\n        principle = _principle;\\n        require( _treasury != address(0) );\\n        treasury = _treasury;\\n        require( _WARCHEST != address(0) );\\n        WARCHEST = _WARCHEST;\\n        // bondCalculator should be address(0) if not LP bond\\n        bondCalculator = _bondCalculator;\\n        isLiquidityBond = ( _bondCalculator != address(0) );\\n    }\\n\\n    /**\\n     *  @notice initializes bond parameters\\n     *  @param _controlVariable uint\\n     *  @param _vestingTerm uint\\n     *  @param _minimumPrice uint\\n     *  @param _maxPayout uint\\n     *  @param _fee uint\\n     *  @param _maxDebt uint\\n     *  @param _initialDebt uint\\n     */\\n    function initializeBondTerms( \\n        uint _controlVariable, \\n        uint _vestingTerm,\\n        uint _minimumPrice,\\n        uint _maxPayout,\\n        uint _fee,\\n        uint _maxDebt,\\n        uint _initialDebt\\n    ) external onlyPolicy() {\\n        require( terms.controlVariable == 0, \\\"Bonds must be initialized from 0\\\" );\\n        terms = Terms ({\\n            controlVariable: _controlVariable,\\n            vestingTerm: _vestingTerm,\\n            minimumPrice: _minimumPrice,\\n            maxPayout: _maxPayout,\\n            fee: _fee,\\n            maxDebt: _maxDebt\\n        });\\n        totalDebt = _initialDebt;\\n        lastDecay = block.number;\\n    }\\n\\n\\n\\n    \\n    /* ======== POLICY FUNCTIONS ======== */\\n\\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT }\\n    /**\\n     *  @notice set parameters for new bonds\\n     *  @param _parameter PARAMETER\\n     *  @param _input uint\\n     */\\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyPolicy() {\\n        if ( _parameter == PARAMETER.VESTING ) { // 0\\n            require( _input >= 10000, \\\"Vesting must be longer than 36 hours\\\" );\\n            terms.vestingTerm = _input;\\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\\n            require( _input <= 1000, \\\"Payout cannot be above 1 percent\\\" );\\n            terms.maxPayout = _input;\\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\\n            require( _input <= 1000, \\\"WARCHEST fee cannot exceed 10 percent\\\" );\\n            terms.fee = _input;\\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\\n            terms.maxDebt = _input;\\n        }\\n    }\\n\\n    /**\\n     *  @notice set control variable adjustment\\n     *  @param _addition bool\\n     *  @param _increment uint\\n     *  @param _target uint\\n     *  @param _buffer uint\\n     */\\n    function setAdjustment ( \\n        bool _addition,\\n        uint _increment, \\n        uint _target,\\n        uint _buffer \\n    ) external onlyPolicy() {\\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \\\"Increment too large\\\" );\\n\\n        adjustment = Adjust({\\n            add: _addition,\\n            rate: _increment,\\n            target: _target,\\n            buffer: _buffer,\\n            lastBlock: block.number\\n        });\\n    }\\n\\n    /**\\n     *  @notice set contract for auto stake\\n     *  @param _staking address\\n     *  @param _helper bool\\n     */\\n    function setStaking( address _staking, bool _helper ) external onlyPolicy() {\\n        require( _staking != address(0) );\\n        if ( _helper ) {\\n            useHelper = true;\\n            stakingHelper = _staking;\\n        } else {\\n            useHelper = false;\\n            staking = _staking;\\n        }\\n    }\\n\\n\\n    \\n\\n    /* ======== USER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice deposit bond\\n     *  @param _amount uint\\n     *  @param _maxPrice uint\\n     *  @param _depositor address\\n     *  @return uint\\n     */\\n    function deposit( \\n        uint _amount, \\n        uint _maxPrice,\\n        address _depositor\\n    ) external returns ( uint ) {\\n        require( _depositor != address(0), \\\"Invalid address\\\" );\\n\\n        decayDebt();\\n        require( totalDebt <= terms.maxDebt && terms.maxDebt > 0, \\\"Max capacity reached\\\" );\\n\\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\\n        uint nativePrice = _bondPrice();\\n\\n        require( _maxPrice >= nativePrice, \\\"Slippage limit: more than max price\\\" ); // slippage protection\\n\\n        uint value = ITreasury( treasury ).valueOf( principle, _amount );\\n        uint payout = payoutFor( value ); // payout to bonder is computed\\n\\n        require( payout >= 10000000, \\\"Bond too small\\\" ); // must be > 0.01 ROME ( underflow protection )\\n        require( payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\n\\n        // profits are calculated\\n        uint fee = payout.mul( terms.fee ).div( 10000 );\\n        uint profit = value.sub( payout ).sub( fee );\\n\\n        /**\\n            principle is transferred in\\n            approved and\\n            deposited into the treasury, returning (_amount - profit) ROME\\n         */\\n        IERC20( principle ).safeTransferFrom( msg.sender, address(this), _amount );\\n        IERC20( principle ).approve( address( treasury ), _amount );\\n        ITreasury( treasury ).deposit( _amount, principle, profit );\\n        \\n        if ( fee != 0 ) { // fee is transferred to WARCHEST\\n            IERC20( ROME ).safeTransfer( WARCHEST, fee );\\n        }\\n        \\n        // total debt is increased\\n        totalDebt = totalDebt.add( value ); \\n                \\n        // depositor info is stored\\n        bondInfo[ _depositor ] = Bond({ \\n            payout: bondInfo[ _depositor ].payout.add( payout ),\\n            vesting: terms.vestingTerm,\\n            lastBlock: block.number,\\n            pricePaid: priceInUSD\\n        });\\n\\n        // indexed events are emitted\\n        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );\\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\\n\\n        adjust(); // control variable is adjusted\\n        return payout; \\n    }\\n\\n    /** \\n     *  @notice redeem bond for user\\n     *  @param _recipient address\\n     *  @param _stake bool\\n     *  @return uint\\n     */ \\n    function redeem( address _recipient, bool _stake ) external returns ( uint ) {        \\n        Bond memory info = bondInfo[ _recipient ];\\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\\n\\n        if ( percentVested >= 10000 ) { // if fully vested\\n            delete bondInfo[ _recipient ]; // delete user info\\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\\n            return stakeOrSend( _recipient, _stake, info.payout ); // pay user everything due\\n\\n        } else { // if unfinished\\n            // calculate payout vested\\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\\n\\n            // store updated deposit info\\n            bondInfo[ _recipient ] = Bond({\\n                payout: info.payout.sub( payout ),\\n                vesting: info.vesting.sub( block.number.sub( info.lastBlock ) ),\\n                lastBlock: block.number,\\n                pricePaid: info.pricePaid\\n            });\\n\\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\\n            return stakeOrSend( _recipient, _stake, payout );\\n        }\\n    }\\n\\n\\n\\n    \\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice allow user to stake payout automatically\\n     *  @param _stake bool\\n     *  @param _amount uint\\n     *  @return uint\\n     */\\n    function stakeOrSend( address _recipient, bool _stake, uint _amount ) internal returns ( uint ) {\\n        if ( !_stake ) { // if user does not want to stake\\n            IERC20( ROME ).transfer( _recipient, _amount ); // send payout\\n        } else { // if user wants to stake\\n            if ( useHelper ) { // use if staking warmup is 0\\n                IERC20( ROME ).approve( stakingHelper, _amount );\\n                IStakingHelper( stakingHelper ).stake( _amount, _recipient );\\n            } else {\\n                IERC20( ROME ).approve( staking, _amount );\\n                IStaking( staking ).stake( _amount, _recipient );\\n            }\\n        }\\n        return _amount;\\n    }\\n\\n    /**\\n     *  @notice makes incremental adjustment to control variable\\n     */\\n    function adjust() internal {\\n        uint blockCanAdjust = adjustment.lastBlock.add( adjustment.buffer );\\n        if( adjustment.rate != 0 && block.number >= blockCanAdjust ) {\\n            uint initial = terms.controlVariable;\\n            if ( adjustment.add ) {\\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\\n                if ( terms.controlVariable >= adjustment.target ) {\\n                    adjustment.rate = 0;\\n                }\\n            } else {\\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\\n                if ( terms.controlVariable <= adjustment.target ) {\\n                    adjustment.rate = 0;\\n                }\\n            }\\n            adjustment.lastBlock = block.number;\\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\\n        }\\n    }\\n\\n    /**\\n     *  @notice reduce total debt\\n     */\\n    function decayDebt() internal {\\n        totalDebt = totalDebt.sub( debtDecay() );\\n        lastDecay = block.number;\\n    }\\n\\n\\n\\n\\n    /* ======== VIEW FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice determine maximum bond size\\n     *  @return uint\\n     */\\n    function maxPayout() public view returns ( uint ) {\\n        return IERC20( ROME ).totalSupply().mul( terms.maxPayout ).div( 100000 );\\n    }\\n\\n    /**\\n     *  @notice calculate interest due for new bond\\n     *  @param _value uint\\n     *  @return uint\\n     */\\n    function payoutFor( uint _value ) public view returns ( uint ) {\\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e16 );\\n    }\\n\\n\\n    /**\\n     *  @notice calculate current bond premium\\n     *  @return price_ uint\\n     */\\n    function bondPrice() public view returns ( uint price_ ) {        \\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\\n        if ( price_ < terms.minimumPrice ) {\\n            price_ = terms.minimumPrice;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate current bond price and remove floor if above\\n     *  @return price_ uint\\n     */\\n    function _bondPrice() internal returns ( uint price_ ) {\\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\\n        if ( price_ < terms.minimumPrice ) {\\n            price_ = terms.minimumPrice;        \\n        } else if ( terms.minimumPrice != 0 ) {\\n            terms.minimumPrice = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice converts bond price to DAI value\\n     *  @return price_ uint\\n     */\\n    function bondPriceInUSD() public view returns ( uint price_ ) {\\n        if( isLiquidityBond ) {\\n            price_ = bondPrice().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 100 );\\n        } else {\\n            price_ = bondPrice().mul( 10 ** IERC20Metadata( principle ).decimals() ).div( 100 );\\n        }\\n    }\\n\\n\\n    /**\\n     *  @notice calculate current ratio of debt to ROME supply\\n     *  @return debtRatio_ uint\\n     */\\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \\n        uint supply = IERC20( ROME ).totalSupply();\\n        debtRatio_ = FixedPoint.fraction( \\n            currentDebt().mul( 1e9 ), \\n            supply\\n        ).decode112with18().div( 1e18 );\\n    }\\n\\n    /**\\n     *  @notice debt ratio in same terms for reserve or liquidity bonds\\n     *  @return uint\\n     */\\n    function standardizedDebtRatio() external view returns ( uint ) {\\n        if ( isLiquidityBond ) {\\n            return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\\n        } else {\\n            return debtRatio();\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate debt factoring in decay\\n     *  @return uint\\n     */\\n    function currentDebt() public view returns ( uint ) {\\n        return totalDebt.sub( debtDecay() );\\n    }\\n\\n    /**\\n     *  @notice amount to decay total debt by\\n     *  @return decay_ uint\\n     */\\n    function debtDecay() public view returns ( uint decay_ ) {\\n        uint blocksSinceLast = block.number.sub( lastDecay );\\n        decay_ = totalDebt.mul( blocksSinceLast ).div( terms.vestingTerm );\\n        if ( decay_ > totalDebt ) {\\n            decay_ = totalDebt;\\n        }\\n    }\\n\\n\\n    /**\\n     *  @notice calculate how far into vesting a depositor is\\n     *  @param _depositor address\\n     *  @return percentVested_ uint\\n     */\\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\\n        Bond memory bond = bondInfo[ _depositor ];\\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\\n        uint vesting = bond.vesting;\\n\\n        if ( vesting > 0 ) {\\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\\n        } else {\\n            percentVested_ = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate amount of ROME available for claim by depositor\\n     *  @param _depositor address\\n     *  @return pendingPayout_ uint\\n     */\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\\n        uint percentVested = percentVestedFor( _depositor );\\n        uint payout = bondInfo[ _depositor ].payout;\\n\\n        if ( percentVested >= 10000 ) {\\n            pendingPayout_ = payout;\\n        } else {\\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\\n        }\\n    }\\n\\n\\n\\n\\n    /* ======= AUXILLIARY ======= */\\n\\n    /**\\n     *  @notice allow anyone to send lost tokens (excluding principle or ROME) to the WARCHEST\\n     *  @return bool\\n     */\\n    function recoverLostToken( address _token ) external returns ( bool ) {\\n        require( _token != ROME );\\n        require( _token != principle );\\n        IERC20( _token ).safeTransfer( WARCHEST, IERC20( _token ).balanceOf( address(this) ) );\\n        return true;\\n    }\\n}\\n\"\n    },\n    \"src/sRomeERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport \\\"./types/ERC20Permit.sol\\\";\\n\\nimport \\\"./types/Policy.sol\\\";\\n\\ncontract sRome is ERC20Permit, Policy {\\n\\n    using SafeMath for uint256;\\n\\n    modifier onlyStakingContract() {\\n        require( msg.sender == stakingContract );\\n        _;\\n    }\\n\\n    address public stakingContract;\\n    address public initializer;\\n\\n    event LogSupply(uint256 indexed epoch, uint256 timestamp, uint256 totalSupply );\\n    event LogRebase( uint256 indexed epoch, uint256 rebase, uint256 index );\\n    event LogStakingContractUpdated( address stakingContract );\\n\\n    struct Rebase {\\n        uint epoch;\\n        uint rebase; // 18 decimals\\n        uint totalStakedBefore;\\n        uint totalStakedAfter;\\n        uint amountRebased;\\n        uint index;\\n        uint blockNumberOccured;\\n    }\\n    Rebase[] public rebases;\\n\\n    uint public INDEX;\\n\\n    uint256 private constant MAX_UINT256 = ~uint256(0);\\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 5000000 * 10**9;\\n\\n    // TOTAL_GONS is a multiple of INITIAL_FRAGMENTS_SUPPLY so that _gonsPerFragment is an integer.\\n    // Use the highest value that fits in a uint256 for max granularity.\\n    uint256 private constant TOTAL_GONS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\\n\\n    // MAX_SUPPLY = maximum integer < (sqrt(4*TOTAL_GONS + 1) - 1) / 2\\n    uint256 private constant MAX_SUPPLY = ~uint128(0);  // (2^128) - 1\\n\\n    uint256 private _gonsPerFragment;\\n    mapping(address => uint256) private _gonBalances;\\n\\n    mapping ( address => mapping ( address => uint256 ) ) private _allowedValue;\\n\\n    constructor()\\n    ERC20(\\\"Staked Rome\\\", \\\"sROME\\\", 9)\\n    ERC20Permit(\\\"Staked Rome\\\") {\\n        initializer = msg.sender;\\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\n    }\\n\\n    function initialize( address stakingContract_ ) external returns ( bool ) {\\n        require( msg.sender == initializer );\\n        require( stakingContract_ != address(0) );\\n        stakingContract = stakingContract_;\\n        _gonBalances[ stakingContract ] = TOTAL_GONS;\\n\\n        emit Transfer( address(0x0), stakingContract, _totalSupply );\\n        emit LogStakingContractUpdated( stakingContract_ );\\n        \\n        initializer = address(0);\\n        return true;\\n    }\\n\\n    function setIndex( uint _INDEX ) external onlyPolicy() returns ( bool ) {\\n        require( INDEX == 0 );\\n        INDEX = gonsForBalance( _INDEX );\\n        return true;\\n    }\\n\\n    /**\\n        @notice increases sROME supply to increase staking balances relative to profit_\\n        @param profit_ uint256\\n        @return uint256\\n     */\\n    function rebase( uint256 profit_, uint epoch_ ) public onlyStakingContract() returns ( uint256 ) {\\n        uint256 rebaseAmount;\\n        uint256 circulatingSupply_ = circulatingSupply();\\n\\n        if ( profit_ == 0 ) {\\n            emit LogSupply( epoch_, block.timestamp, _totalSupply );\\n            emit LogRebase( epoch_, 0, index() );\\n            return _totalSupply;\\n        } else if ( circulatingSupply_ > 0 ){\\n            rebaseAmount = profit_.mul( _totalSupply ).div( circulatingSupply_ );\\n        } else {\\n            rebaseAmount = profit_;\\n        }\\n\\n        _totalSupply = _totalSupply.add( rebaseAmount );\\n\\n        if ( _totalSupply > MAX_SUPPLY ) {\\n            _totalSupply = MAX_SUPPLY;\\n        }\\n\\n        _gonsPerFragment = TOTAL_GONS.div( _totalSupply );\\n\\n        _storeRebase( circulatingSupply_, profit_, epoch_ );\\n\\n        return _totalSupply;\\n    }\\n\\n    /**\\n        @notice emits event with data about rebase\\n        @param previousCirculating_ uint\\n        @param profit_ uint\\n        @param epoch_ uint\\n        @return bool\\n     */\\n    function _storeRebase( uint previousCirculating_, uint profit_, uint epoch_ ) internal returns ( bool ) {\\n        uint rebasePercent = profit_.mul( 1e18 ).div( previousCirculating_ );\\n\\n        rebases.push( Rebase ( {\\n            epoch: epoch_,\\n            rebase: rebasePercent, // 18 decimals\\n            totalStakedBefore: previousCirculating_,\\n            totalStakedAfter: circulatingSupply(),\\n            amountRebased: profit_,\\n            index: index(),\\n            blockNumberOccured: block.number\\n        }));\\n        \\n        emit LogSupply( epoch_, block.timestamp, _totalSupply );\\n        emit LogRebase( epoch_, rebasePercent, index() );\\n\\n        return true;\\n    }\\n\\n    function balanceOf( address who ) public view override returns ( uint256 ) {\\n        return _gonBalances[ who ].div( _gonsPerFragment );\\n    }\\n\\n    function gonsForBalance( uint amount ) public view returns ( uint ) {\\n        return amount.mul( _gonsPerFragment );\\n    }\\n\\n    function balanceForGons( uint gons ) public view returns ( uint ) {\\n        return gons.div( _gonsPerFragment );\\n    }\\n\\n    // Staking contract holds excess sROME\\n    function circulatingSupply() public view returns ( uint ) {\\n        return _totalSupply.sub( balanceOf( stakingContract ) );\\n    }\\n\\n    function index() public view returns ( uint ) {\\n        return balanceForGons( INDEX );\\n    }\\n\\n    function transfer( address to, uint256 value ) public override returns (bool) {\\n        uint256 gonValue = value.mul( _gonsPerFragment );\\n        _gonBalances[ msg.sender ] = _gonBalances[ msg.sender ].sub( gonValue );\\n        _gonBalances[ to ] = _gonBalances[ to ].add( gonValue );\\n        emit Transfer( msg.sender, to, value );\\n        return true;\\n    }\\n\\n    function allowance( address owner_, address spender ) public view override returns ( uint256 ) {\\n        return _allowedValue[ owner_ ][ spender ];\\n    }\\n\\n    function transferFrom( address from, address to, uint256 value ) public override returns ( bool ) {\\n       _allowedValue[ from ][ msg.sender ] = _allowedValue[ from ][ msg.sender ].sub( value );\\n       emit Approval( from, msg.sender,  _allowedValue[ from ][ msg.sender ] );\\n\\n        uint256 gonValue = gonsForBalance( value );\\n        _gonBalances[ from ] = _gonBalances[from].sub( gonValue );\\n        _gonBalances[ to ] = _gonBalances[to].add( gonValue );\\n        emit Transfer( from, to, value );\\n\\n        return true;\\n    }\\n\\n    function approve( address spender, uint256 value ) public override returns (bool) {\\n         _allowedValue[ msg.sender ][ spender ] = value;\\n         emit Approval( msg.sender, spender, value );\\n         return true;\\n    }\\n\\n    // What gets called in a permit\\n    function _approve( address owner, address spender, uint256 value ) internal override virtual {\\n        _allowedValue[owner][spender] = value;\\n        emit Approval( owner, spender, value );\\n    }\\n\\n    function increaseAllowance( address spender, uint256 addedValue ) public override returns (bool) {\\n        _allowedValue[ msg.sender ][ spender ] = _allowedValue[ msg.sender ][ spender ].add( addedValue );\\n        emit Approval( msg.sender, spender, _allowedValue[ msg.sender ][ spender ] );\\n        return true;\\n    }\\n\\n    function decreaseAllowance( address spender, uint256 subtractedValue ) public override returns (bool) {\\n        uint256 oldValue = _allowedValue[ msg.sender ][ spender ];\\n        if (subtractedValue >= oldValue) {\\n            _allowedValue[ msg.sender ][ spender ] = 0;\\n        } else {\\n            _allowedValue[ msg.sender ][ spender ] = oldValue.sub( subtractedValue );\\n        }\\n        emit Approval( msg.sender, spender, _allowedValue[ msg.sender ][ spender ] );\\n        return true;\\n    }\\n}\\n\"\n    },\n    \"src/RomeERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport \\\"./interfaces/IROME.sol\\\";\\n\\nimport \\\"./types/ERC20Permit.sol\\\";\\n\\nimport \\\"./types/RomeAccessControlled.sol\\\";\\n\\ncontract Rome is ERC20Permit, IROME, RomeAccessControlled {\\n  using SafeMath for uint256;\\n\\n    constructor(address _authority)\\n    ERC20(\\\"Rome\\\", \\\"ROME\\\", 9)\\n    ERC20Permit(\\\"Rome\\\")\\n    RomeAccessControlled(IRomeAuthority(_authority)) {}\\n\\n    function mint(address account_, uint256 amount_) external override onlyVault {\\n        _mint(account_, amount_);\\n    }\\n\\n    function burn(uint256 amount) external override {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    function burnFrom(address account_, uint256 amount_) external override {\\n        _burnFrom(account_, amount_);\\n    }\\n\\n    function _burnFrom(address account_, uint256 amount_) internal {\\n        uint256 decreasedAllowance_ = allowance(account_, msg.sender).sub(amount_, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account_, msg.sender, decreasedAllowance_);\\n        _burn(account_, amount_);\\n    }\\n}\\n\"\n    },\n    \"src/interfaces/IROME.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity >=0.7.5;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IROME is IERC20 {\\r\\n  function mint(address account_, uint256 amount_) external;\\r\\n\\r\\n  function burn(uint256 amount) external;\\r\\n\\r\\n  function burnFrom(address account_, uint256 amount_) external;\\r\\n}\\r\\n\"\n    },\n    \"src/types/RomeAccessControlled.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity >=0.7.5;\\r\\n\\r\\nimport \\\"../interfaces/IRomeAuthority.sol\\\";\\r\\n\\r\\nabstract contract RomeAccessControlled {\\r\\n\\r\\n    /* ========== EVENTS ========== */\\r\\n\\r\\n    event AuthorityUpdated(IRomeAuthority indexed authority);\\r\\n\\r\\n    string UNAUTHORIZED = \\\"UNAUTHORIZED\\\"; // save gas\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    IRomeAuthority public authority;\\r\\n\\r\\n\\r\\n    /* ========== Constructor ========== */\\r\\n\\r\\n    constructor(IRomeAuthority _authority) {\\r\\n        authority = _authority;\\r\\n        emit AuthorityUpdated(_authority);\\r\\n    }\\r\\n    \\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n    \\r\\n    modifier onlyGovernor() {\\r\\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    modifier onlyGuardian() {\\r\\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    modifier onlyPolicy() {\\r\\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyVault() {\\r\\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /* ========== GOV ONLY ========== */\\r\\n    \\r\\n    function setAuthority(IRomeAuthority _newAuthority) external onlyGovernor {\\r\\n        authority = _newAuthority;\\r\\n        emit AuthorityUpdated(_newAuthority);\\r\\n    }\\r\\n}\\r\\n\"\n    },\n    \"src/interfaces/IRomeAuthority.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity >=0.7.5;\\r\\n\\r\\ninterface IRomeAuthority {\\r\\n    /* ========== EVENTS ========== */\\r\\n    \\r\\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\r\\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \\r\\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \\r\\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \\r\\n\\r\\n    event GovernorPulled(address indexed from, address indexed to);\\r\\n    event GuardianPulled(address indexed from, address indexed to);\\r\\n    event PolicyPulled(address indexed from, address indexed to);\\r\\n    event VaultPulled(address indexed from, address indexed to);\\r\\n\\r\\n    /* ========== VIEW ========== */\\r\\n    \\r\\n    function governor() external view returns (address);\\r\\n    function guardian() external view returns (address);\\r\\n    function policy() external view returns (address);\\r\\n    function vault() external view returns (address);\\r\\n}\\r\\n\"\n    },\n    \"src/RomeAuthority.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"./interfaces/IRomeAuthority.sol\\\";\\r\\n\\r\\nimport \\\"./types/RomeAccessControlled.sol\\\";\\r\\n\\r\\ncontract RomeAuthority is IRomeAuthority, RomeAccessControlled {\\r\\n\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    address public override governor;\\r\\n\\r\\n    address public override guardian;\\r\\n\\r\\n    address public override policy;\\r\\n\\r\\n    address public override vault;\\r\\n\\r\\n    address public newGovernor;\\r\\n\\r\\n    address public newGuardian;\\r\\n\\r\\n    address public newPolicy;\\r\\n\\r\\n    address public newVault;\\r\\n\\r\\n\\r\\n    /* ========== Constructor ========== */\\r\\n\\r\\n    constructor(\\r\\n        address _governor,\\r\\n        address _guardian,\\r\\n        address _policy,\\r\\n        address _vault\\r\\n    ) RomeAccessControlled( IRomeAuthority(address(this)) ) {\\r\\n        governor = _governor;\\r\\n        emit GovernorPushed(address(0), governor, true);\\r\\n        guardian = _guardian;\\r\\n        emit GuardianPushed(address(0), guardian, true);\\r\\n        policy = _policy;\\r\\n        emit PolicyPushed(address(0), policy, true);\\r\\n        vault = _vault;\\r\\n        emit VaultPushed(address(0), vault, true);\\r\\n    }\\r\\n\\r\\n\\r\\n    /* ========== GOV ONLY ========== */\\r\\n\\r\\n    function pushGovernor(address _newGovernor, bool _effectiveImmediately) external onlyGovernor {\\r\\n        if( _effectiveImmediately ) governor = _newGovernor;\\r\\n        newGovernor = _newGovernor;\\r\\n        emit GovernorPushed(governor, newGovernor, _effectiveImmediately);\\r\\n    }\\r\\n\\r\\n    function pushGuardian(address _newGuardian, bool _effectiveImmediately) external onlyGovernor {\\r\\n        if( _effectiveImmediately ) guardian = _newGuardian;\\r\\n        newGuardian = _newGuardian;\\r\\n        emit GuardianPushed(guardian, newGuardian, _effectiveImmediately);\\r\\n    }\\r\\n\\r\\n    function pushPolicy(address _newPolicy, bool _effectiveImmediately) external onlyGovernor {\\r\\n        if( _effectiveImmediately ) policy = _newPolicy;\\r\\n        newPolicy = _newPolicy;\\r\\n        emit PolicyPushed(policy, newPolicy, _effectiveImmediately);\\r\\n    }\\r\\n\\r\\n    function pushVault(address _newVault, bool _effectiveImmediately) external onlyGovernor {\\r\\n        if( _effectiveImmediately ) vault = _newVault;\\r\\n        newVault = _newVault;\\r\\n        emit VaultPushed(vault, newVault, _effectiveImmediately);\\r\\n    }\\r\\n\\r\\n\\r\\n    /* ========== PENDING ROLE ONLY ========== */\\r\\n\\r\\n    function pullGovernor() external {\\r\\n        require(msg.sender == newGovernor, \\\"!newGovernor\\\");\\r\\n        emit GovernorPulled(governor, newGovernor);\\r\\n        governor = newGovernor;\\r\\n    }\\r\\n\\r\\n    function pullGuardian() external {\\r\\n        require(msg.sender == newGuardian, \\\"!newGuard\\\");\\r\\n        emit GuardianPulled(guardian, newGuardian);\\r\\n        guardian = newGuardian;\\r\\n    }\\r\\n\\r\\n    function pullPolicy() external {\\r\\n        require(msg.sender == newPolicy, \\\"!newPolicy\\\");\\r\\n        emit PolicyPulled(policy, newPolicy);\\r\\n        policy = newPolicy;\\r\\n    }\\r\\n\\r\\n    function pullVault() external {\\r\\n        require(msg.sender == newVault, \\\"!newVault\\\");\\r\\n        emit VaultPulled(vault, newVault);\\r\\n        vault = newVault;\\r\\n    }\\r\\n}\\r\\n\"\n    },\n    \"src/StakingWarmup.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport './interfaces/IERC20.sol';\\n\\ncontract StakingWarmup {\\n\\n    address public immutable staking;\\n    address public immutable sROME;\\n\\n    constructor ( address _staking, address _sROME ) {\\n        require( _staking != address(0) );\\n        staking = _staking;\\n        require( _sROME != address(0) );\\n        sROME = _sROME;\\n    }\\n\\n    function retrieve( address _staker, uint _amount ) external {\\n        require( msg.sender == staking );\\n        IERC20( sROME ).transfer( _staker, _amount );\\n    }\\n}\\n\"\n    },\n    \"src/StakingHelper.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport './interfaces/IERC20.sol';\\n\\ninterface IStaking {\\n    function stake( uint _amount, address _recipient ) external returns ( bool );\\n    function claim( address _recipient ) external;\\n}\\n\\ncontract StakingHelper {\\n\\n    address public immutable staking;\\n    address public immutable ROME;\\n\\n    constructor ( address _staking, address _ROME ) {\\n        require( _staking != address(0) );\\n        staking = _staking;\\n        require( _ROME != address(0) );\\n        ROME = _ROME;\\n    }\\n\\n    function stake( uint _amount , address _recipient ) external {\\n        IERC20( ROME ).transferFrom( msg.sender, address(this), _amount );\\n        IERC20( ROME ).approve( staking, _amount );\\n        IStaking( staking ).stake( _amount, _recipient );\\n        IStaking( staking ).claim( _recipient );\\n    }\\n}\\n\\n\\n\"\n    },\n    \"src/Bonds/MOVRBondDepository.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport \\\"../types/Policy.sol\\\";\\n\\nimport \\\"../types/ERC20Permit.sol\\\";\\n\\nimport \\\"../libraries/SafeERC20.sol\\\";\\n\\nimport \\\"../libraries/FixedPoint.sol\\\";\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\\ninterface ITreasury {\\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( bool );\\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\\n    function mintRewards( address _recipient, uint _amount ) external;\\n}\\n\\ninterface IBondCalculator {\\n    function valuation( address _LP, uint _amount ) external view returns ( uint );\\n    function markdown( address _LP ) external view returns ( uint );\\n}\\n\\ninterface IStaking {\\n    function stake( uint _amount, address _recipient ) external returns ( bool );\\n}\\n\\ninterface IStakingHelper {\\n    function stake( uint _amount, address _recipient ) external;\\n}\\n\\ncontract MOVRBondDepository is Policy {\\n\\n    using FixedPoint for *;\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint;\\n\\n\\n\\n\\n    /* ======== EVENTS ======== */\\n\\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\\n\\n\\n\\n\\n    /* ======== STATE VARIABLES ======== */\\n\\n    address public immutable ROME; // token given as payment for bond\\n    address public immutable principle; // token used to create bond\\n    address public immutable treasury; // mints ROME when receives principle\\n    address public immutable WARCHEST; // receives fee share from bond\\n\\n    address public immutable bondCalculator; // calculates value of LP tokens\\n\\n    AggregatorV3Interface internal priceFeed;\\n\\n    address public staking; // to auto-stake payout\\n    address public stakingHelper; // to stake and claim if no staking warmup\\n    bool public useHelper;\\n\\n    Terms public terms; // stores terms for new bonds\\n    Adjust public adjustment; // stores adjustment to BCV data\\n\\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\\n\\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\\n    uint public lastDecay; // reference block for debt decay\\n\\n\\n    /* ======== STRUCTS ======== */\\n\\n    // Info for creating new bonds\\n    struct Terms {\\n        uint controlVariable; // scaling variable for price\\n        uint vestingTerm; // in blocks\\n        uint minimumPrice; // vs principle value. 4 decimals (1500 = 0.15)\\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\n        uint fee; // as % of bond principle, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)]\\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\\n    }\\n\\n    // Info for bond holder\\n    struct Bond {\\n        uint payout; // ROME remaining to be paid\\n        uint vesting; // Blocks left to vest\\n        uint lastBlock; // Last interaction\\n        uint pricePaid; // In DAI, for front end viewing\\n    }\\n\\n    // Info for incremental adjustments to control variable \\n    struct Adjust {\\n        bool add; // addition or subtraction\\n        uint rate; // increment\\n        uint target; // BCV when adjustment finished\\n        uint buffer; // minimum length (in blocks) between adjustments\\n        uint lastBlock; // block when last adjustment made\\n    }\\n\\n\\n\\n\\n    /* ======== INITIALIZATION ======== */\\n\\n    constructor ( \\n        address _ROME,\\n        address _principle,\\n        address _treasury, \\n        address _WARCHEST,\\n        address _bondCalculator,\\n        address _feed\\n    ) {\\n        require( _ROME != address(0) );\\n        ROME = _ROME;\\n        require( _principle != address(0) );\\n        principle = _principle;\\n        require( _treasury != address(0) );\\n        treasury = _treasury;\\n        require( _WARCHEST != address(0) );\\n        WARCHEST = _WARCHEST;\\n        // bondCalculator should be address(0) if not LP bond\\n        bondCalculator = _bondCalculator;\\n        priceFeed = AggregatorV3Interface( _feed );\\n    }\\n\\n    /**\\n     *  @notice initializes bond parameters\\n     *  @param _controlVariable uint\\n     *  @param _vestingTerm uint\\n     *  @param _minimumPrice uint\\n     *  @param _maxPayout uint\\n     *  @param _maxDebt uint\\n     *  @param _initialDebt uint\\n     */\\n    function initializeBondTerms( \\n        uint _controlVariable, \\n        uint _vestingTerm,\\n        uint _minimumPrice,\\n        uint _maxPayout,\\n        uint _fee,\\n        uint _maxDebt,\\n        uint _initialDebt\\n    ) external onlyPolicy() {\\n        require( terms.controlVariable == 0, \\\"Bonds must be initialized from 0\\\" );\\n        terms = Terms ({\\n            controlVariable: _controlVariable,\\n            vestingTerm: _vestingTerm,\\n            minimumPrice: _minimumPrice,\\n            maxPayout: _maxPayout,\\n            fee: _fee,\\n            maxDebt: _maxDebt\\n        });\\n        totalDebt = _initialDebt;\\n        lastDecay = block.number;\\n    }\\n\\n\\n\\n    \\n    /* ======== POLICY FUNCTIONS ======== */\\n\\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT }\\n    /**\\n     *  @notice set parameters for new bonds\\n     *  @param _parameter PARAMETER\\n     *  @param _input uint\\n     */\\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyPolicy() {\\n        if ( _parameter == PARAMETER.VESTING ) { // 0\\n            require( _input >= 10000, \\\"Vesting must be longer than 36 hours\\\" );\\n            terms.vestingTerm = _input;\\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\\n            require( _input <= 1000, \\\"Payout cannot be above 1 percent\\\" );\\n            terms.maxPayout = _input;\\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\\n            require( _input <= 1000, \\\"WARCHEST fee cannot exceed 10 percent\\\" );\\n            terms.fee = _input;\\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\\n            terms.maxDebt = _input;\\n        }\\n    }\\n\\n    /**\\n     *  @notice set control variable adjustment\\n     *  @param _addition bool\\n     *  @param _increment uint\\n     *  @param _target uint\\n     *  @param _buffer uint\\n     */\\n    function setAdjustment ( \\n        bool _addition,\\n        uint _increment, \\n        uint _target,\\n        uint _buffer \\n    ) external onlyPolicy() {\\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \\\"Increment too large\\\" );\\n\\n        adjustment = Adjust({\\n            add: _addition,\\n            rate: _increment,\\n            target: _target,\\n            buffer: _buffer,\\n            lastBlock: block.number\\n        });\\n    }\\n\\n    /**\\n     *  @notice set contract for auto stake\\n     *  @param _staking address\\n     *  @param _helper bool\\n     */\\n    function setStaking( address _staking, bool _helper ) external onlyPolicy() {\\n        require( _staking != address(0) );\\n        if ( _helper ) {\\n            useHelper = true;\\n            stakingHelper = _staking;\\n        } else {\\n            useHelper = false;\\n            staking = _staking;\\n        }\\n    }\\n\\n\\n    \\n\\n    /* ======== USER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice deposit bond\\n     *  @param _amount uint\\n     *  @param _maxPrice uint\\n     *  @param _depositor address\\n     *  @return uint\\n     */\\n    function deposit( \\n        uint _amount, \\n        uint _maxPrice,\\n        address _depositor\\n    ) external returns ( uint ) {\\n        require( _depositor != address(0), \\\"Invalid address\\\" );\\n\\n        decayDebt();\\n        require( totalDebt <= terms.maxDebt && terms.maxDebt > 0, \\\"Max capacity reached\\\" );\\n\\n        // feees are calculated\\n        uint fee = _amount.mul( terms.fee ).div( 10000 );\\n        _amount = _amount.sub( fee );\\n\\n        if ( fee != 0 ) { // fee is transferred to warchest\\n            IERC20( principle ).safeTransfer( WARCHEST, fee );\\n        }\\n        \\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\\n        uint nativePrice = _bondPrice();\\n\\n        require( _maxPrice >= nativePrice, \\\"Slippage limit: more than max price\\\" ); // slippage protection\\n\\n        uint value = ITreasury( treasury ).valueOf( principle, _amount );\\n        uint payout = payoutFor( value ); // payout to bonder is computed\\n\\n        require( payout >= 10000000, \\\"Bond too small\\\" ); // must be > 0.01 ROME ( underflow protection )\\n        require( payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\n\\n        /**\\n            asset carries risk and is not minted against\\n            asset transfered to treasury and rewards minted as payout\\n         */\\n        IERC20( principle ).safeTransferFrom( msg.sender, treasury, _amount );\\n        ITreasury( treasury ).mintRewards( address(this), payout );\\n        \\n        // total debt is increased\\n        totalDebt = totalDebt.add( value ); \\n                \\n        // depositor info is stored\\n        bondInfo[ _depositor ] = Bond({ \\n            payout: bondInfo[ _depositor ].payout.add( payout ),\\n            vesting: terms.vestingTerm,\\n            lastBlock: block.number,\\n            pricePaid: priceInUSD\\n        });\\n\\n        // indexed events are emitted\\n        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );\\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\\n\\n        adjust(); // control variable is adjusted\\n        return payout; \\n    }\\n\\n    /** \\n     *  @notice redeem bond for user\\n     *  @param _recipient address\\n     *  @param _stake bool\\n     *  @return uint\\n     */ \\n    function redeem( address _recipient, bool _stake ) external returns ( uint ) {        \\n        Bond memory info = bondInfo[ _recipient ];\\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\\n\\n        if ( percentVested >= 10000 ) { // if fully vested\\n            delete bondInfo[ _recipient ]; // delete user info\\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\\n            return stakeOrSend( _recipient, _stake, info.payout ); // pay user everything due\\n\\n        } else { // if unfinished\\n            // calculate payout vested\\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\\n\\n            // store updated deposit info\\n            bondInfo[ _recipient ] = Bond({\\n                payout: info.payout.sub( payout ),\\n                vesting: info.vesting.sub( block.number.sub( info.lastBlock ) ),\\n                lastBlock: block.number,\\n                pricePaid: info.pricePaid\\n            });\\n\\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\\n            return stakeOrSend( _recipient, _stake, payout );\\n        }\\n    }\\n\\n\\n\\n    \\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice allow user to stake payout automatically\\n     *  @param _stake bool\\n     *  @param _amount uint\\n     *  @return uint\\n     */\\n    function stakeOrSend( address _recipient, bool _stake, uint _amount ) internal returns ( uint ) {\\n        if ( !_stake ) { // if user does not want to stake\\n            IERC20( ROME ).transfer( _recipient, _amount ); // send payout\\n        } else { // if user wants to stake\\n            if ( useHelper ) { // use if staking warmup is 0\\n                IERC20( ROME ).approve( stakingHelper, _amount );\\n                IStakingHelper( stakingHelper ).stake( _amount, _recipient );\\n            } else {\\n                IERC20( ROME ).approve( staking, _amount );\\n                IStaking( staking ).stake( _amount, _recipient );\\n            }\\n        }\\n        return _amount;\\n    }\\n\\n    /**\\n     *  @notice makes incremental adjustment to control variable\\n     */\\n    function adjust() internal {\\n        uint blockCanAdjust = adjustment.lastBlock.add( adjustment.buffer );\\n        if( adjustment.rate != 0 && block.number >= blockCanAdjust ) {\\n            uint initial = terms.controlVariable;\\n            if ( adjustment.add ) {\\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\\n                if ( terms.controlVariable >= adjustment.target ) {\\n                    adjustment.rate = 0;\\n                }\\n            } else {\\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\\n                if ( terms.controlVariable <= adjustment.target ) {\\n                    adjustment.rate = 0;\\n                }\\n            }\\n            adjustment.lastBlock = block.number;\\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\\n        }\\n    }\\n\\n    /**\\n     *  @notice reduce total debt\\n     */\\n    function decayDebt() internal {\\n        totalDebt = totalDebt.sub( debtDecay() );\\n        lastDecay = block.number;\\n    }\\n\\n\\n\\n\\n    /* ======== VIEW FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice determine maximum bond size\\n     *  @return uint\\n     */\\n    function maxPayout() public view returns ( uint ) {\\n        return IERC20( ROME ).totalSupply().mul( terms.maxPayout ).div( 100000 );\\n    }\\n\\n    /**\\n     *  @notice calculate interest due for new bond\\n     *  @param _value uint\\n     *  @return uint\\n     */\\n    function payoutFor( uint _value ) public view returns ( uint ) {\\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e14 );\\n    }\\n\\n\\n    /**\\n     *  @notice calculate current bond premium\\n     *  @return price_ uint\\n     */\\n    function bondPrice() public view returns ( uint price_ ) {        \\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\\n        if ( price_ < terms.minimumPrice ) {\\n            price_ = terms.minimumPrice;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate current bond price and remove floor if above\\n     *  @return price_ uint\\n     */\\n    function _bondPrice() internal returns ( uint price_ ) {\\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\\n        if ( price_ < terms.minimumPrice ) {\\n            price_ = terms.minimumPrice;        \\n        } else if ( terms.minimumPrice != 0 ) {\\n            terms.minimumPrice = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice get asset price from chainlink\\n     */\\n    function assetPrice() public view returns (int) {\\n        ( , int price, , , ) = priceFeed.latestRoundData();\\n        return price;\\n    }\\n\\n    /**\\n     *  @notice converts bond price to DAI value\\n     *  @return price_ uint\\n     */\\n    function bondPriceInUSD() public view returns ( uint price_ ) {\\n        if (bondCalculator == address(0)) {\\n            price_ = bondPrice().mul( uint( assetPrice() ) ).mul( 1e6 );\\n        } else {\\n            price_ = bondPrice()\\n                    .mul( IBondCalculator( bondCalculator ).markdown( principle ) )\\n                    .mul( uint( assetPrice() ) )\\n                    .div( 1e12 );\\n        }\\n    }\\n\\n\\n    /**\\n     *  @notice calculate current ratio of debt to ROME supply\\n     *  @return debtRatio_ uint\\n     */\\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \\n        debtRatio_ = FixedPoint.fraction(\\n            currentDebt().mul( 1e9 ),\\n            IERC20( ROME ).totalSupply()\\n        ).decode112with18().div( 1e18 );\\n    }\\n\\n\\n    /**\\n     *  @notice debt ratio in same terms as reserve bonds\\n     *  @return uint\\n     */\\n    function standardizedDebtRatio() external view returns ( uint ) {\\n        if (bondCalculator == address(0)) {\\n            return debtRatio().mul( uint( assetPrice() ) ).div( 1e8 ); // ETH feed is 8 decimals\\n        } else {\\n            return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate debt factoring in decay\\n     *  @return uint\\n     */\\n    function currentDebt() public view returns ( uint ) {\\n        return totalDebt.sub( debtDecay() );\\n    }\\n\\n    /**\\n     *  @notice amount to decay total debt by\\n     *  @return decay_ uint\\n     */\\n    function debtDecay() public view returns ( uint decay_ ) {\\n        uint blocksSinceLast = block.number.sub( lastDecay );\\n        decay_ = totalDebt.mul( blocksSinceLast ).div( terms.vestingTerm );\\n        if ( decay_ > totalDebt ) {\\n            decay_ = totalDebt;\\n        }\\n    }\\n\\n\\n    /**\\n     *  @notice calculate how far into vesting a depositor is\\n     *  @param _depositor address\\n     *  @return percentVested_ uint\\n     */\\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\\n        Bond memory bond = bondInfo[ _depositor ];\\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\\n        uint vesting = bond.vesting;\\n\\n        if ( vesting > 0 ) {\\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\\n        } else {\\n            percentVested_ = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate amount of ROME available for claim by depositor\\n     *  @param _depositor address\\n     *  @return pendingPayout_ uint\\n     */\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\\n        uint percentVested = percentVestedFor( _depositor );\\n        uint payout = bondInfo[ _depositor ].payout;\\n\\n        if ( percentVested >= 10000 ) {\\n            pendingPayout_ = payout;\\n        } else {\\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\\n        }\\n    }\\n\\n\\n\\n\\n    /* ======= AUXILLIARY ======= */\\n\\n    /**\\n     *  @notice allow anyone to send lost tokens (excluding principle or ROME) to the WARCHEST\\n     *  @return bool\\n     */\\n    function recoverLostToken( address _token ) external returns ( bool ) {\\n        require( _token != ROME );\\n        require( _token != principle );\\n        IERC20( _token ).safeTransfer( WARCHEST, IERC20( _token ).balanceOf( address(this) ) );\\n        return true;\\n    }\\n}\\n\"\n    },\n    \"src/Bonds/MIMBondDepository.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport \\\"../types/Policy.sol\\\";\\n\\nimport \\\"../types/ERC20Permit.sol\\\";\\n\\nimport \\\"../libraries/SafeERC20.sol\\\";\\n\\nimport \\\"../libraries/FixedPoint.sol\\\";\\n\\nimport \\\"../interfaces/IERC20Metadata.sol\\\";\\n\\ninterface ITreasury {\\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( bool );\\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\\n}\\n\\ninterface IBondCalculator {\\n    function valuation( address _LP, uint _amount ) external view returns ( uint );\\n    function markdown( address _LP ) external view returns ( uint );\\n}\\n\\ninterface IStaking {\\n    function stake( uint _amount, address _recipient ) external returns ( bool );\\n}\\n\\ninterface IStakingHelper {\\n    function stake( uint _amount, address _recipient ) external;\\n}\\n\\ncontract MIMBondDepository is Policy {\\n\\n    using FixedPoint for *;\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint;\\n\\n\\n\\n\\n    /* ======== EVENTS ======== */\\n\\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\\n\\n\\n\\n\\n    /* ======== STATE VARIABLES ======== */\\n\\n    address public immutable ROME; // token given as payment for bond\\n    address public immutable principle; // token used to create bond\\n    address public immutable treasury; // mints ROME when receives principle\\n    address public immutable WARCHEST; // receives fee from principle\\n\\n    bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\\n    address public immutable bondCalculator; // calculates value of LP tokens\\n\\n    address public staking; // to auto-stake payout\\n    address public stakingHelper; // to stake and claim if no staking warmup\\n    bool public useHelper;\\n\\n    Terms public terms; // stores terms for new bonds\\n    Adjust public adjustment; // stores adjustment to BCV data\\n\\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\\n\\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\\n    uint public lastDecay; // reference block for debt decay\\n\\n\\n\\n\\n\\n    /* ======== STRUCTS ======== */\\n\\n    // Info for creating new bonds\\n    struct Terms {\\n        uint controlVariable; // scaling variable for price\\n        uint vestingTerm; // in blocks\\n        uint minimumPrice; // vs principle value\\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\n        uint fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)]\\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\\n    }\\n\\n    // Info for bond holder\\n    struct Bond {\\n        uint payout; // ROME remaining to be paid\\n        uint vesting; // Blocks left to vest\\n        uint lastBlock; // Last interaction\\n        uint pricePaid; // In DAI, for front end viewing\\n    }\\n\\n    // Info for incremental adjustments to control variable \\n    struct Adjust {\\n        bool add; // addition or subtraction\\n        uint rate; // increment\\n        uint target; // BCV when adjustment finished\\n        uint buffer; // minimum length (in blocks) between adjustments\\n        uint lastBlock; // block when last adjustment made\\n    }\\n\\n\\n\\n\\n    /* ======== INITIALIZATION ======== */\\n\\n    constructor ( \\n        address _ROME,\\n        address _principle,\\n        address _treasury, \\n        address _WARCHEST,\\n        address _bondCalculator\\n    ) {\\n        require( _ROME != address(0) );\\n        ROME = _ROME;\\n        require( _principle != address(0) );\\n        principle = _principle;\\n        require( _treasury != address(0) );\\n        treasury = _treasury;\\n        require( _WARCHEST != address(0) );\\n        WARCHEST = _WARCHEST;\\n        // bondCalculator should be address(0) if not LP bond\\n        bondCalculator = _bondCalculator;\\n        isLiquidityBond = ( _bondCalculator != address(0) );\\n    }\\n\\n    /**\\n     *  @notice initializes bond parameters\\n     *  @param _controlVariable uint\\n     *  @param _vestingTerm uint\\n     *  @param _minimumPrice uint\\n     *  @param _maxPayout uint\\n     *  @param _fee uint\\n     *  @param _maxDebt uint\\n     *  @param _initialDebt uint\\n     */\\n    function initializeBondTerms( \\n        uint _controlVariable, \\n        uint _vestingTerm,\\n        uint _minimumPrice,\\n        uint _maxPayout,\\n        uint _fee,\\n        uint _maxDebt,\\n        uint _initialDebt\\n    ) external onlyPolicy() {\\n        require( terms.controlVariable == 0, \\\"Bonds must be initialized from 0\\\" );\\n        terms = Terms ({\\n            controlVariable: _controlVariable,\\n            vestingTerm: _vestingTerm,\\n            minimumPrice: _minimumPrice,\\n            maxPayout: _maxPayout,\\n            fee: _fee,\\n            maxDebt: _maxDebt\\n        });\\n        totalDebt = _initialDebt;\\n        lastDecay = block.number;\\n    }\\n\\n\\n\\n    \\n    /* ======== POLICY FUNCTIONS ======== */\\n\\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT }\\n    /**\\n     *  @notice set parameters for new bonds\\n     *  @param _parameter PARAMETER\\n     *  @param _input uint\\n     */\\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyPolicy() {\\n        if ( _parameter == PARAMETER.VESTING ) { // 0\\n            require( _input >= 10000, \\\"Vesting must be longer than 36 hours\\\" );\\n            terms.vestingTerm = _input;\\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\\n            require( _input <= 1000, \\\"Payout cannot be above 1 percent\\\" );\\n            terms.maxPayout = _input;\\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\\n            require( _input <= 1000, \\\"WARCHEST fee cannot exceed 10 percent\\\" );\\n            terms.fee = _input;\\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\\n            terms.maxDebt = _input;\\n        }\\n    }\\n\\n    /**\\n     *  @notice set control variable adjustment\\n     *  @param _addition bool\\n     *  @param _increment uint\\n     *  @param _target uint\\n     *  @param _buffer uint\\n     */\\n    function setAdjustment ( \\n        bool _addition,\\n        uint _increment, \\n        uint _target,\\n        uint _buffer \\n    ) external onlyPolicy() {\\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \\\"Increment too large\\\" );\\n\\n        adjustment = Adjust({\\n            add: _addition,\\n            rate: _increment,\\n            target: _target,\\n            buffer: _buffer,\\n            lastBlock: block.number\\n        });\\n    }\\n\\n    /**\\n     *  @notice set contract for auto stake\\n     *  @param _staking address\\n     *  @param _helper bool\\n     */\\n    function setStaking( address _staking, bool _helper ) external onlyPolicy() {\\n        require( _staking != address(0) );\\n        if ( _helper ) {\\n            useHelper = true;\\n            stakingHelper = _staking;\\n        } else {\\n            useHelper = false;\\n            staking = _staking;\\n        }\\n    }\\n\\n\\n    \\n\\n    /* ======== USER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice deposit bond\\n     *  @param _amount uint\\n     *  @param _maxPrice uint\\n     *  @param _depositor address\\n     *  @return uint\\n     */\\n    function deposit( \\n        uint _amount, \\n        uint _maxPrice,\\n        address _depositor\\n    ) external returns ( uint ) {\\n        require( _depositor != address(0), \\\"Invalid address\\\" );\\n\\n        decayDebt();\\n        require( totalDebt <= terms.maxDebt && terms.maxDebt > 0, \\\"Max capacity reached\\\" );\\n\\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\\n        uint nativePrice = _bondPrice();\\n\\n        require( _maxPrice >= nativePrice, \\\"Slippage limit: more than max price\\\" ); // slippage protection\\n\\n        uint value = ITreasury( treasury ).valueOf( principle, _amount );\\n        uint payout = payoutFor( value ); // payout to bonder is computed\\n\\n        require( payout >= 10000000, \\\"Bond too small\\\" ); // must be > 0.01 ROME ( underflow protection )\\n        require( payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\n\\n        // profits are calculated\\n        uint fee = payout.mul( terms.fee ).div( 10000 );\\n        uint profit = value.sub( payout ).sub( fee );\\n\\n        /**\\n            principle is transferred in\\n            approved and\\n            deposited into the treasury, returning (_amount - profit) ROME\\n         */\\n        IERC20( principle ).safeTransferFrom( msg.sender, address(this), _amount );\\n        IERC20( principle ).approve( address( treasury ), _amount );\\n        ITreasury( treasury ).deposit( _amount, principle, profit );\\n        \\n        if ( fee != 0 ) { // fee is transferred to WARCHEST\\n            IERC20( ROME ).safeTransfer( WARCHEST, fee );\\n        }\\n        \\n        // total debt is increased\\n        totalDebt = totalDebt.add( value ); \\n                \\n        // depositor info is stored\\n        bondInfo[ _depositor ] = Bond({ \\n            payout: bondInfo[ _depositor ].payout.add( payout ),\\n            vesting: terms.vestingTerm,\\n            lastBlock: block.number,\\n            pricePaid: priceInUSD\\n        });\\n\\n        // indexed events are emitted\\n        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );\\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\\n\\n        adjust(); // control variable is adjusted\\n        return payout; \\n    }\\n\\n    /** \\n     *  @notice redeem bond for user\\n     *  @param _recipient address\\n     *  @param _stake bool\\n     *  @return uint\\n     */ \\n    function redeem( address _recipient, bool _stake ) external returns ( uint ) {        \\n        Bond memory info = bondInfo[ _recipient ];\\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\\n\\n        if ( percentVested >= 10000 ) { // if fully vested\\n            delete bondInfo[ _recipient ]; // delete user info\\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\\n            return stakeOrSend( _recipient, _stake, info.payout ); // pay user everything due\\n\\n        } else { // if unfinished\\n            // calculate payout vested\\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\\n\\n            // store updated deposit info\\n            bondInfo[ _recipient ] = Bond({\\n                payout: info.payout.sub( payout ),\\n                vesting: info.vesting.sub( block.number.sub( info.lastBlock ) ),\\n                lastBlock: block.number,\\n                pricePaid: info.pricePaid\\n            });\\n\\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\\n            return stakeOrSend( _recipient, _stake, payout );\\n        }\\n    }\\n\\n\\n\\n    \\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice allow user to stake payout automatically\\n     *  @param _stake bool\\n     *  @param _amount uint\\n     *  @return uint\\n     */\\n    function stakeOrSend( address _recipient, bool _stake, uint _amount ) internal returns ( uint ) {\\n        if ( !_stake ) { // if user does not want to stake\\n            IERC20( ROME ).transfer( _recipient, _amount ); // send payout\\n        } else { // if user wants to stake\\n            if ( useHelper ) { // use if staking warmup is 0\\n                IERC20( ROME ).approve( stakingHelper, _amount );\\n                IStakingHelper( stakingHelper ).stake( _amount, _recipient );\\n            } else {\\n                IERC20( ROME ).approve( staking, _amount );\\n                IStaking( staking ).stake( _amount, _recipient );\\n            }\\n        }\\n        return _amount;\\n    }\\n\\n    /**\\n     *  @notice makes incremental adjustment to control variable\\n     */\\n    function adjust() internal {\\n        uint blockCanAdjust = adjustment.lastBlock.add( adjustment.buffer );\\n        if( adjustment.rate != 0 && block.number >= blockCanAdjust ) {\\n            uint initial = terms.controlVariable;\\n            if ( adjustment.add ) {\\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\\n                if ( terms.controlVariable >= adjustment.target ) {\\n                    adjustment.rate = 0;\\n                }\\n            } else {\\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\\n                if ( terms.controlVariable <= adjustment.target ) {\\n                    adjustment.rate = 0;\\n                }\\n            }\\n            adjustment.lastBlock = block.number;\\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\\n        }\\n    }\\n\\n    /**\\n     *  @notice reduce total debt\\n     */\\n    function decayDebt() internal {\\n        totalDebt = totalDebt.sub( debtDecay() );\\n        lastDecay = block.number;\\n    }\\n\\n\\n\\n\\n    /* ======== VIEW FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice determine maximum bond size\\n     *  @return uint\\n     */\\n    function maxPayout() public view returns ( uint ) {\\n        return IERC20( ROME ).totalSupply().mul( terms.maxPayout ).div( 100000 );\\n    }\\n\\n    /**\\n     *  @notice calculate interest due for new bond\\n     *  @param _value uint\\n     *  @return uint\\n     */\\n    function payoutFor( uint _value ) public view returns ( uint ) {\\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e16 );\\n    }\\n\\n\\n    /**\\n     *  @notice calculate current bond premium\\n     *  @return price_ uint\\n     */\\n    function bondPrice() public view returns ( uint price_ ) {        \\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\\n        if ( price_ < terms.minimumPrice ) {\\n            price_ = terms.minimumPrice;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate current bond price and remove floor if above\\n     *  @return price_ uint\\n     */\\n    function _bondPrice() internal returns ( uint price_ ) {\\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\\n        if ( price_ < terms.minimumPrice ) {\\n            price_ = terms.minimumPrice;        \\n        } else if ( terms.minimumPrice != 0 ) {\\n            terms.minimumPrice = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice converts bond price to DAI value\\n     *  @return price_ uint\\n     */\\n    function bondPriceInUSD() public view returns ( uint price_ ) {\\n        if( isLiquidityBond ) {\\n            price_ = bondPrice().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 100 );\\n        } else {\\n            price_ = bondPrice().mul( 10 ** IERC20Metadata( principle ).decimals() ).div( 100 );\\n        }\\n    }\\n\\n\\n    /**\\n     *  @notice calculate current ratio of debt to ROME supply\\n     *  @return debtRatio_ uint\\n     */\\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \\n        uint supply = IERC20( ROME ).totalSupply();\\n        debtRatio_ = FixedPoint.fraction( \\n            currentDebt().mul( 1e9 ), \\n            supply\\n        ).decode112with18().div( 1e18 );\\n    }\\n\\n    /**\\n     *  @notice debt ratio in same terms for reserve or liquidity bonds\\n     *  @return uint\\n     */\\n    function standardizedDebtRatio() external view returns ( uint ) {\\n        if ( isLiquidityBond ) {\\n            return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\\n        } else {\\n            return debtRatio();\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate debt factoring in decay\\n     *  @return uint\\n     */\\n    function currentDebt() public view returns ( uint ) {\\n        return totalDebt.sub( debtDecay() );\\n    }\\n\\n    /**\\n     *  @notice amount to decay total debt by\\n     *  @return decay_ uint\\n     */\\n    function debtDecay() public view returns ( uint decay_ ) {\\n        uint blocksSinceLast = block.number.sub( lastDecay );\\n        decay_ = totalDebt.mul( blocksSinceLast ).div( terms.vestingTerm );\\n        if ( decay_ > totalDebt ) {\\n            decay_ = totalDebt;\\n        }\\n    }\\n\\n\\n    /**\\n     *  @notice calculate how far into vesting a depositor is\\n     *  @param _depositor address\\n     *  @return percentVested_ uint\\n     */\\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\\n        Bond memory bond = bondInfo[ _depositor ];\\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\\n        uint vesting = bond.vesting;\\n\\n        if ( vesting > 0 ) {\\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\\n        } else {\\n            percentVested_ = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate amount of ROME available for claim by depositor\\n     *  @param _depositor address\\n     *  @return pendingPayout_ uint\\n     */\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\\n        uint percentVested = percentVestedFor( _depositor );\\n        uint payout = bondInfo[ _depositor ].payout;\\n\\n        if ( percentVested >= 10000 ) {\\n            pendingPayout_ = payout;\\n        } else {\\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\\n        }\\n    }\\n\\n\\n\\n\\n    /* ======= AUXILLIARY ======= */\\n\\n    /**\\n     *  @notice allow anyone to send lost tokens (excluding principle or ROME) to the WARCHEST\\n     *  @return bool\\n     */\\n    function recoverLostToken( address _token ) external returns ( bool ) {\\n        require( _token != ROME );\\n        require( _token != principle );\\n        IERC20( _token ).safeTransfer( WARCHEST, IERC20( _token ).balanceOf( address(this) ) );\\n        return true;\\n    }\\n}\\n\"\n    },\n    \"src/Bonds/FRAXBondDepository.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport \\\"../types/Policy.sol\\\";\\n\\nimport \\\"../types/ERC20Permit.sol\\\";\\n\\nimport \\\"../libraries/SafeERC20.sol\\\";\\n\\nimport \\\"../libraries/FixedPoint.sol\\\";\\n\\nimport \\\"../interfaces/IERC20Metadata.sol\\\";\\n\\ninterface ITreasury {\\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( bool );\\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\\n}\\n\\ninterface IBondCalculator {\\n    function valuation( address _LP, uint _amount ) external view returns ( uint );\\n    function markdown( address _LP ) external view returns ( uint );\\n}\\n\\ninterface IStaking {\\n    function stake( uint _amount, address _recipient ) external returns ( bool );\\n}\\n\\ninterface IStakingHelper {\\n    function stake( uint _amount, address _recipient ) external;\\n}\\n\\ncontract FRAXBondDepository is Policy {\\n\\n    using FixedPoint for *;\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint;\\n\\n\\n\\n\\n    /* ======== EVENTS ======== */\\n\\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\\n\\n\\n\\n\\n    /* ======== STATE VARIABLES ======== */\\n\\n    address public immutable ROME; // token given as payment for bond\\n    address public immutable principle; // token used to create bond\\n    address public immutable treasury; // mints ROME when receives principle\\n    address public immutable WARCHEST; // receives fee from principle\\n\\n    bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\\n    address public immutable bondCalculator; // calculates value of LP tokens\\n\\n    address public staking; // to auto-stake payout\\n    address public stakingHelper; // to stake and claim if no staking warmup\\n    bool public useHelper;\\n\\n    Terms public terms; // stores terms for new bonds\\n    Adjust public adjustment; // stores adjustment to BCV data\\n\\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\\n\\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\\n    uint public lastDecay; // reference block for debt decay\\n\\n\\n\\n    /* ======== STRUCTS ======== */\\n\\n    // Info for creating new bonds\\n    struct Terms {\\n        uint controlVariable; // scaling variable for price\\n        uint vestingTerm; // in blocks\\n        uint minimumPrice; // vs principle value\\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\n        uint fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)]\\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\\n    }\\n\\n    // Info for bond holder\\n    struct Bond {\\n        uint payout; // ROME remaining to be paid\\n        uint vesting; // Blocks left to vest\\n        uint lastBlock; // Last interaction\\n        uint pricePaid; // In DAI, for front end viewing\\n    }\\n\\n    // Info for incremental adjustments to control variable \\n    struct Adjust {\\n        bool add; // addition or subtraction\\n        uint rate; // increment\\n        uint target; // BCV when adjustment finished\\n        uint buffer; // minimum length (in blocks) between adjustments\\n        uint lastBlock; // block when last adjustment made\\n    }\\n\\n\\n\\n\\n    /* ======== INITIALIZATION ======== */\\n\\n    constructor ( \\n        address _ROME,\\n        address _principle,\\n        address _treasury, \\n        address _WARCHEST,\\n        address _bondCalculator\\n    ) {\\n        require( _ROME != address(0) );\\n        ROME = _ROME;\\n        require( _principle != address(0) );\\n        principle = _principle;\\n        require( _treasury != address(0) );\\n        treasury = _treasury;\\n        require( _WARCHEST != address(0) );\\n        WARCHEST = _WARCHEST;\\n        // bondCalculator should be address(0) if not LP bond\\n        bondCalculator = _bondCalculator;\\n        isLiquidityBond = ( _bondCalculator != address(0) );\\n    }\\n\\n    /**\\n     *  @notice initializes bond parameters\\n     *  @param _controlVariable uint\\n     *  @param _vestingTerm uint\\n     *  @param _minimumPrice uint\\n     *  @param _maxPayout uint\\n     *  @param _fee uint\\n     *  @param _maxDebt uint (1e9)\\n     *  @param _initialDebt uint (1e9)\\n     */\\n    function initializeBondTerms( \\n        uint _controlVariable, \\n        uint _vestingTerm,\\n        uint _minimumPrice,\\n        uint _maxPayout,\\n        uint _fee,\\n        uint _maxDebt,\\n        uint _initialDebt\\n    ) external onlyPolicy() {\\n        require( terms.controlVariable == 0, \\\"Bonds must be initialized from 0\\\" );\\n        terms = Terms ({\\n            controlVariable: _controlVariable,\\n            vestingTerm: _vestingTerm,\\n            minimumPrice: _minimumPrice,\\n            maxPayout: _maxPayout,\\n            fee: _fee,\\n            maxDebt: _maxDebt\\n        });\\n        totalDebt = _initialDebt;\\n        lastDecay = block.number;\\n    }\\n\\n\\n\\n    \\n    /* ======== POLICY FUNCTIONS ======== */\\n\\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT }\\n    /**\\n     *  @notice set parameters for new bonds\\n     *  @param _parameter PARAMETER\\n     *  @param _input uint\\n     */\\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyPolicy() {\\n        if ( _parameter == PARAMETER.VESTING ) { // 0\\n            require( _input >= 10000, \\\"Vesting must be longer than 36 hours\\\" );\\n            terms.vestingTerm = _input;\\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\\n            require( _input <= 1000, \\\"Payout cannot be above 1 percent\\\" );\\n            terms.maxPayout = _input;\\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\\n            require( _input <= 1000, \\\"WARCHEST fee cannot exceed 10 percent\\\" );\\n            terms.fee = _input;\\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\\n            terms.maxDebt = _input;\\n        }\\n    }\\n\\n    /**\\n     *  @notice set control variable adjustment\\n     *  @param _addition bool\\n     *  @param _increment uint\\n     *  @param _target uint\\n     *  @param _buffer uint\\n     */\\n    function setAdjustment ( \\n        bool _addition,\\n        uint _increment, \\n        uint _target,\\n        uint _buffer \\n    ) external onlyPolicy() {\\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \\\"Increment too large\\\" );\\n\\n        adjustment = Adjust({\\n            add: _addition,\\n            rate: _increment,\\n            target: _target,\\n            buffer: _buffer,\\n            lastBlock: block.number\\n        });\\n    }\\n\\n    /**\\n     *  @notice set contract for auto stake\\n     *  @param _staking address\\n     *  @param _helper bool\\n     */\\n    function setStaking( address _staking, bool _helper ) external onlyPolicy() {\\n        require( _staking != address(0) );\\n        if ( _helper ) {\\n            useHelper = true;\\n            stakingHelper = _staking;\\n        } else {\\n            useHelper = false;\\n            staking = _staking;\\n        }\\n    }\\n\\n\\n    \\n\\n    /* ======== USER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice deposit bond\\n     *  @param _amount uint\\n     *  @param _maxPrice uint\\n     *  @param _depositor address\\n     *  @return uint\\n     */\\n    function deposit( \\n        uint _amount, \\n        uint _maxPrice,\\n        address _depositor\\n    ) external returns ( uint ) {\\n        require( _depositor != address(0), \\\"Invalid address\\\" );\\n\\n        decayDebt();\\n        require( totalDebt <= terms.maxDebt && terms.maxDebt > 0, \\\"Max capacity reached\\\" );\\n\\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\\n        uint nativePrice = _bondPrice();\\n\\n        require( _maxPrice >= nativePrice, \\\"Slippage limit: more than max price\\\" ); // slippage protection\\n\\n        uint value = ITreasury( treasury ).valueOf( principle, _amount );\\n        uint payout = payoutFor( value ); // payout to bonder is computed\\n\\n        require( payout >= 10000000, \\\"Bond too small\\\" ); // must be > 0.01 ROME ( underflow protection )\\n        require( payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\n\\n        // profits are calculated\\n        uint fee = payout.mul( terms.fee ).div( 10000 );\\n        uint profit = value.sub( payout ).sub( fee );\\n\\n        /**\\n            principle is transferred in\\n            approved and\\n            deposited into the treasury, returning (_amount - profit) ROME\\n         */\\n        IERC20( principle ).safeTransferFrom( msg.sender, address(this), _amount );\\n        IERC20( principle ).approve( address( treasury ), _amount );\\n        ITreasury( treasury ).deposit( _amount, principle, profit );\\n        \\n        if ( fee != 0 ) { // fee is transferred to WARCHEST\\n            IERC20( ROME ).safeTransfer( WARCHEST, fee );\\n        }\\n        \\n        // total debt is increased\\n        totalDebt = totalDebt.add( value ); \\n                \\n        // depositor info is stored\\n        bondInfo[ _depositor ] = Bond({ \\n            payout: bondInfo[ _depositor ].payout.add( payout ),\\n            vesting: terms.vestingTerm,\\n            lastBlock: block.number,\\n            pricePaid: priceInUSD\\n        });\\n\\n        // indexed events are emitted\\n        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );\\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\\n\\n        adjust(); // control variable is adjusted\\n        return payout; \\n    }\\n\\n    /** \\n     *  @notice redeem bond for user\\n     *  @param _recipient address\\n     *  @param _stake bool\\n     *  @return uint\\n     */ \\n    function redeem( address _recipient, bool _stake ) external returns ( uint ) {        \\n        Bond memory info = bondInfo[ _recipient ];\\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\\n\\n        if ( percentVested >= 10000 ) { // if fully vested\\n            delete bondInfo[ _recipient ]; // delete user info\\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\\n            return stakeOrSend( _recipient, _stake, info.payout ); // pay user everything due\\n\\n        } else { // if unfinished\\n            // calculate payout vested\\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\\n\\n            // store updated deposit info\\n            bondInfo[ _recipient ] = Bond({\\n                payout: info.payout.sub( payout ),\\n                vesting: info.vesting.sub( block.number.sub( info.lastBlock ) ),\\n                lastBlock: block.number,\\n                pricePaid: info.pricePaid\\n            });\\n\\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\\n            return stakeOrSend( _recipient, _stake, payout );\\n        }\\n    }\\n\\n\\n\\n    \\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice allow user to stake payout automatically\\n     *  @param _stake bool\\n     *  @param _amount uint\\n     *  @return uint\\n     */\\n    function stakeOrSend( address _recipient, bool _stake, uint _amount ) internal returns ( uint ) {\\n        if ( !_stake ) { // if user does not want to stake\\n            IERC20( ROME ).transfer( _recipient, _amount ); // send payout\\n        } else { // if user wants to stake\\n            if ( useHelper ) { // use if staking warmup is 0\\n                IERC20( ROME ).approve( stakingHelper, _amount );\\n                IStakingHelper( stakingHelper ).stake( _amount, _recipient );\\n            } else {\\n                IERC20( ROME ).approve( staking, _amount );\\n                IStaking( staking ).stake( _amount, _recipient );\\n            }\\n        }\\n        return _amount;\\n    }\\n\\n    /**\\n     *  @notice makes incremental adjustment to control variable\\n     */\\n    function adjust() internal {\\n        uint blockCanAdjust = adjustment.lastBlock.add( adjustment.buffer );\\n        if( adjustment.rate != 0 && block.number >= blockCanAdjust ) {\\n            uint initial = terms.controlVariable;\\n            if ( adjustment.add ) {\\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\\n                if ( terms.controlVariable >= adjustment.target ) {\\n                    adjustment.rate = 0;\\n                }\\n            } else {\\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\\n                if ( terms.controlVariable <= adjustment.target ) {\\n                    adjustment.rate = 0;\\n                }\\n            }\\n            adjustment.lastBlock = block.number;\\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\\n        }\\n    }\\n\\n    /**\\n     *  @notice reduce total debt\\n     */\\n    function decayDebt() internal {\\n        totalDebt = totalDebt.sub( debtDecay() );\\n        lastDecay = block.number;\\n    }\\n\\n\\n\\n\\n    /* ======== VIEW FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice determine maximum bond size\\n     *  @return uint\\n     */\\n    function maxPayout() public view returns ( uint ) {\\n        return IERC20( ROME ).totalSupply().mul( terms.maxPayout ).div( 100000 );\\n    }\\n\\n    /**\\n     *  @notice calculate interest due for new bond\\n     *  @param _value uint\\n     *  @return uint\\n     */\\n    function payoutFor( uint _value ) public view returns ( uint ) {\\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e16 );\\n    }\\n\\n\\n    /**\\n     *  @notice calculate current bond premium\\n     *  @return price_ uint\\n     */\\n    function bondPrice() public view returns ( uint price_ ) {        \\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\\n        if ( price_ < terms.minimumPrice ) {\\n            price_ = terms.minimumPrice;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate current bond price and remove floor if above\\n     *  @return price_ uint\\n     *  @dev 2 decimals\\n     */\\n    function _bondPrice() internal returns ( uint price_ ) {\\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\\n        if ( price_ < terms.minimumPrice ) {\\n            price_ = terms.minimumPrice;        \\n        } else if ( terms.minimumPrice != 0 ) {\\n            terms.minimumPrice = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice converts bond price to DAI value\\n     *  @return price_ uint\\n     */\\n    function bondPriceInUSD() public view returns ( uint price_ ) {\\n        if( isLiquidityBond ) {\\n            price_ = bondPrice().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 100 );\\n        } else {\\n            price_ = bondPrice().mul( 10 ** IERC20Metadata( principle ).decimals() ).div( 100 );\\n        }\\n    }\\n\\n\\n    /**\\n     *  @notice calculate current ratio of debt to ROME supply\\n     *  @return debtRatio_ uint\\n     *  @dev 9 decimals\\n     */\\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \\n        uint supply = IERC20( ROME ).totalSupply();\\n        debtRatio_ = FixedPoint.fraction( \\n            currentDebt().mul( 1e9 ), \\n            supply\\n        ).decode112with18().div( 1e18 );\\n    }\\n\\n    /**\\n     *  @notice debt ratio in same terms for reserve or liquidity bonds\\n     *  @return uint\\n     */\\n    function standardizedDebtRatio() external view returns ( uint ) {\\n        if ( isLiquidityBond ) {\\n            return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\\n        } else {\\n            return debtRatio();\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate debt factoring in decay\\n     *  @return uint\\n     */\\n    function currentDebt() public view returns ( uint ) {\\n        return totalDebt.sub( debtDecay() );\\n    }\\n\\n    /**\\n     *  @notice amount to decay total debt by\\n     *  @return decay_ uint\\n     */\\n    function debtDecay() public view returns ( uint decay_ ) {\\n        uint blocksSinceLast = block.number.sub( lastDecay );\\n        decay_ = totalDebt.mul( blocksSinceLast ).div( terms.vestingTerm );\\n        if ( decay_ > totalDebt ) {\\n            decay_ = totalDebt;\\n        }\\n    }\\n\\n\\n    /**\\n     *  @notice calculate how far into vesting a depositor is\\n     *  @param _depositor address\\n     *  @return percentVested_ uint\\n     */\\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\\n        Bond memory bond = bondInfo[ _depositor ];\\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\\n        uint vesting = bond.vesting;\\n\\n        if ( vesting > 0 ) {\\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\\n        } else {\\n            percentVested_ = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate amount of ROME available for claim by depositor\\n     *  @param _depositor address\\n     *  @return pendingPayout_ uint\\n     */\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\\n        uint percentVested = percentVestedFor( _depositor );\\n        uint payout = bondInfo[ _depositor ].payout;\\n\\n        if ( percentVested >= 10000 ) {\\n            pendingPayout_ = payout;\\n        } else {\\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\\n        }\\n    }\\n\\n\\n\\n\\n    /* ======= AUXILLIARY ======= */\\n\\n    /**\\n     *  @notice allow anyone to send lost tokens (excluding principle or ROME) to the WARCHEST\\n     *  @return bool\\n     */\\n    function recoverLostToken( address _token ) external returns ( bool ) {\\n        require( _token != ROME );\\n        require( _token != principle );\\n        IERC20( _token ).safeTransfer( WARCHEST, IERC20( _token ).balanceOf( address(this) ) );\\n        return true;\\n    }\\n}\\n\"\n    },\n    \"src/RedeemHelper.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport \\\"./types/Policy.sol\\\";\\n\\ninterface IBond {\\n    function redeem( address _recipient, bool _stake ) external returns ( uint );\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ );\\n}\\n\\ncontract RedeemHelper is Policy {\\n\\n    address[] public bonds;\\n\\n    function redeemAll( address _recipient, bool _stake ) external {\\n        for( uint i = 0; i < bonds.length; i++ ) {\\n            if ( bonds[i] != address(0) ) {\\n                if ( IBond( bonds[i] ).pendingPayoutFor( _recipient ) > 0 ) {\\n                    IBond( bonds[i] ).redeem( _recipient, _stake );\\n                }\\n            }\\n        }\\n    }\\n\\n    function addBondContract( address _bond ) external onlyPolicy() {\\n        require( _bond != address(0) );\\n        bonds.push( _bond );\\n    }\\n\\n    function removeBondContract( uint _index ) external onlyPolicy() {\\n        bonds[ _index ] = address(0);\\n    }\\n}\\n\"\n    }\n  },\n  \"settings\": {\n    \"optimizer\": {\n      \"enabled\": true,\n      \"runs\": 9999\n    },\n    \"outputSelection\": {\n      \"*\": {\n        \"*\": [\n          \"abi\",\n          \"evm.bytecode\",\n          \"evm.deployedBytecode\",\n          \"evm.methodIdentifiers\",\n          \"metadata\",\n          \"devdoc\",\n          \"userdoc\",\n          \"storageLayout\",\n          \"evm.gasEstimates\"\n        ],\n        \"\": [\n          \"ast\"\n        ]\n      }\n    },\n    \"metadata\": {\n      \"useLiteralContent\": true\n    }\n  }\n}",
      "solcInputHash": "216d08a10c5feee05bff696487973d2a",
      "transactionHash": "0x6cddecd7d30197dc6a54bd2da9fb3e02606f5fc0aeda12dafa6ffbc34e1928b9",
      "args": [
        "0x7c21291D033E88bd6A22bA8f3D0716bDD47C9F2e",
        "0x8927346dC98C292E829cAb8A05aE3f8Edbe6Fca4",
        "0xeA10713B180d2eCe3da631B7BF7b4AC0c18e4166",
        "0x0000000000000000000000000000000000000000"
      ]
    },
    "rawTx": "0xf913aa0184773594008311036b8080b9135660c0604052600c60808190526b15539055551213d49256915160a21b60a09081526200002f916000919062000248565b503480156200003d57600080fd5b50604051620012d6380380620012d6833981810160405260808110156200006357600080fd5b5080516020820151604080840151606090940151600180546001600160a01b0319163090811790915591519394929390919081907f2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad90600090a250600280546001600160a01b038087166001600160a01b031990921691909117918290556040805160018152905192909116916000917f4f337dcbb2512f18373c1f72d990a2f0a6ee5024b04007c52afd01eb73374a89919081900360200190a3600380546001600160a01b038086166001600160a01b031990921691909117918290556040805160018152905192909116916000917fde655975891e8f09671597b37bd4d663bcc5c21dc6d7641b33cdf85fbe15d08b919081900360200190a3600480546001600160a01b038085166001600160a01b031990921691909117918290556040805160018152905192909116916000917f90a5902a45c24aae553d5aff384ca16d6560f08d74c9784a4fbd2796d9e13f2b919081900360200190a3600580546001600160a01b038084166001600160a01b031990921691909117918290556040805160018152905192909116916000917f05a80f5053574d6a62733e1692e8cbcfaf927dc82df0a7267ea2e489a7cc18ff919081900360200190a350505050620002f4565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282620002805760008555620002cb565b82601f106200029b57805160ff1916838001178555620002cb565b82800160010185558215620002cb579182015b82811115620002cb578251825591602001919060010190620002ae565b50620002d9929150620002dd565b5090565b5b80821115620002d95760008155600101620002de565b610fd280620003046000396000f3fe608060405234801561001057600080fd5b50600436106101365760003560e01c80635beede08116100b25780638fd2057711610081578063bf7e214f11610066578063bf7e214f14610287578063d8a042121461028f578063fbfa77cf1461029757610136565b80638fd2057714610277578063be11f1dd1461027f57610136565b80635beede08146102135780636fe72c141461021b5780637a9e5e4b1461024957806388aaf0c81461026f57610136565b8063215e92bc11610109578063452a9320116100ee578063452a9320146101af57806352759694146101b757806354e3d703146101e557610136565b8063215e92bc1461019f5780633bf90c28146101a757610136565b80630505c8c91461013b5780630c340a241461015f57806319859847146101675780631afe87141461016f575b600080fd5b61014361029f565b604080516001600160a01b039092168252519081900360200190f35b6101436102ae565b6101436102bd565b61019d6004803603604081101561018557600080fd5b506001600160a01b03813516906020013515156102cc565b005b61019d6104c7565b6101436105bb565b6101436105ca565b61019d600480360360408110156101cd57600080fd5b506001600160a01b03813516906020013515156105d9565b61019d600480360360408110156101fb57600080fd5b506001600160a01b038135169060200135151561079a565b61019d61095b565b61019d6004803603604081101561023157600080fd5b506001600160a01b0381351690602001351515610a4f565b61019d6004803603602081101561025f57600080fd5b50356001600160a01b0316610c10565b610143610d78565b610143610d87565b61019d610d96565b610143610e8a565b61019d610e99565b610143610f8d565b6004546001600160a01b031681565b6002546001600160a01b031681565b6007546001600160a01b031681565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b15801561031a57600080fd5b505afa15801561032e573d6000803e3d6000fd5b505050506040513d602081101561034457600080fd5b50516000906001600160a01b0316331461040b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b820191906000526020600020905b8154815290600101906020018083116103df57829003601f168201915b50509250505060405180910390fd5b50801561044657600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600780546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560035460408051851515815290519383169391909216917fde655975891e8f09671597b37bd4d663bcc5c21dc6d7641b33cdf85fbe15d08b919081900360200190a35050565b6009546001600160a01b0316331461054057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f216e65775661756c740000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6009546005546040516001600160a01b0392831692909116907f3d08e01e3b8340be6ca709db7a9321448661a1f490da4d7f3eb03d84fe73095390600090a3600954600580547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b6008546001600160a01b031681565b6003546001600160a01b031681565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b15801561062757600080fd5b505afa15801561063b573d6000803e3d6000fd5b505050506040513d602081101561065157600080fd5b50516000906001600160a01b031633146106de576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b50801561071957600280547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600680546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560025460408051851515815290519383169391909216917f4f337dcbb2512f18373c1f72d990a2f0a6ee5024b04007c52afd01eb73374a89919081900360200190a35050565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b1580156107e857600080fd5b505afa1580156107fc573d6000803e3d6000fd5b505050506040513d602081101561081257600080fd5b50516000906001600160a01b0316331461089f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b5080156108da57600480547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600880546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560045460408051851515815290519383169391909216917f90a5902a45c24aae553d5aff384ca16d6560f08d74c9784a4fbd2796d9e13f2b919081900360200190a35050565b6008546001600160a01b031633146109d457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f216e6577506f6c69637900000000000000000000000000000000000000000000604482015290519081900360640190fd5b6008546004546040516001600160a01b0392831692909116907f64d2fa522b403ca222efff0c7ad07d2ef45472a45e5770918bdfa9a2845d29a890600090a3600854600480547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b158015610a9d57600080fd5b505afa158015610ab1573d6000803e3d6000fd5b505050506040513d6020811015610ac757600080fd5b50516000906001600160a01b03163314610b54576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b508015610b8f57600580547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790555b600980546001600160a01b038085167fffffffffffffffffffffffff0000000000000000000000000000000000000000909216919091179182905560055460408051851515815290519383169391909216917f05a80f5053574d6a62733e1692e8cbcfaf927dc82df0a7267ea2e489a7cc18ff919081900360200190a35050565b600160009054906101000a90046001600160a01b03166001600160a01b0316630c340a246040518163ffffffff1660e01b815260040160206040518083038186803b158015610c5e57600080fd5b505afa158015610c72573d6000803e3d6000fd5b505050506040513d6020811015610c8857600080fd5b50516000906001600160a01b03163314610d15576040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482019081528254600260001961010060018416150201909116046024830181905290918291604490910190849080156103fc5780601f106103d1576101008083540402835291602001916103fc565b50600180547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0383169081179091556040517f2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad90600090a250565b6009546001600160a01b031681565b6006546001600160a01b031681565b6007546001600160a01b03163314610e0f57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f216e657747756172640000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6007546003546040516001600160a01b0392831692909116907f0960fb9900fb8096216606c4f7fc2fce5d08cc0c82da55cec8619b66b523848190600090a3600754600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b6001546001600160a01b031681565b6006546001600160a01b03163314610f1257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f216e6577476f7665726e6f720000000000000000000000000000000000000000604482015290519081900360640190fd5b6006546002546040516001600160a01b0392831692909116907fffd6fed33fe8ec1016718bdd5d04ae6fecd9aba0da6578807daaaa7fc3d1682690600090a3600654600280547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b6005546001600160a01b03168156fea2646970667358221220a33e88bd9811578012ad7813bdb3873418713dcd698aa1f936bec475f2a3f14d64736f6c634300070500330000000000000000000000007c21291d033e88bd6a22ba8f3d0716bdd47c9f2e0000000000000000000000008927346dc98c292e829cab8a05ae3f8edbe6fca4000000000000000000000000ea10713b180d2ece3da631b7bf7b4ac0c18e41660000000000000000000000000000000000000000000000000000000000000000820a32a0962e7fd2695d585d2b75adbcf2f885712fc9b28b72b1a76305c0b11562fb7391a00a7140d25d3d85f0c2d7ce6df5615420385b6b8ea32b5d84358b6fd2dfbb1984"
  }
}