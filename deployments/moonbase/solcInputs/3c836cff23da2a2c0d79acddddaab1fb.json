{
  "language": "Solidity",
  "sources": {
    "src/mocks/FRAX.sol": {
      "content": "pragma solidity 0.7.5;\r\n\r\n\r\ncontract LibNote {\r\n  event LogNote(\r\n    bytes4   indexed  sig,\r\n    address  indexed  usr,\r\n    bytes32  indexed  arg1,\r\n    bytes32  indexed  arg2,\r\n    bytes             data\r\n  ) anonymous;\r\n\r\n  modifier note {\r\n    _;\r\n    // assembly {\r\n    //     // log an 'anonymous' event with a constant 6 words of calldata\r\n    //     // and four indexed topics: selector, caller, arg1 and arg2\r\n    //     let mark := msize()                         // end of memory ensures zero\r\n    //     mstore(0x40, add(mark, 288))              // update free memory pointer\r\n    //     mstore(mark, 0x20)                        // bytes type data offset\r\n    //     mstore(add(mark, 0x20), 224)              // bytes size (padded)\r\n    //     calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\r\n    //     log4(mark, 288,                           // calldata\r\n    //          shl(224, shr(224, calldataload(0))), // msg.sig\r\n    //          caller(),                              // msg.sender\r\n    //          calldataload(4),                     // arg1\r\n    //          calldataload(36)                     // arg2\r\n    //         )\r\n    // }\r\n  }\r\n}\r\n\r\ninterface IFRAX {\r\n\r\n\r\n    // --- Auth ---\r\n  function wards() external returns ( uint256 );\r\n\r\n  function rely(address guy) external;\r\n\r\n  function deny(address guy) external;\r\n\r\n    // --- Token ---\r\n  function transfer(address dst, uint wad) external returns (bool);\r\n\r\n  function transferFrom(address src, address dst, uint wad) external returns (bool);\r\n\r\n  function mint(address usr, uint wad) external;\r\n\r\n  function burn(address usr, uint wad) external;\r\n\r\n  function approve(address usr, uint wad) external returns (bool);\r\n\r\n    // --- Alias ---\r\n  function push(address usr, uint wad) external;\r\n\r\n  function pull(address usr, uint wad) external;\r\n\r\n  function move(address src, address dst, uint wad) external;\r\n\r\n    // --- Approve by signature ---\r\n  function permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n////// /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/FRAX.sol\r\n// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity 0.5.12; */\r\n\r\n/* import \"./lib.sol\"; */\r\n\r\ncontract mockFRAX is LibNote {\r\n  \r\n  event Approval(address indexed src, address indexed guy, uint wad);\r\n  event Transfer(address indexed src, address indexed dst, uint wad);\r\n  \r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n\r\n    function rely(address guy) external note auth { wards[guy] = 1; }\r\n\r\n    function deny(address guy) external note auth { wards[guy] = 0; }\r\n\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"FRAX/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- ERC20 Data ---\r\n    string  public constant name     = \"FRAX Stablecoin\";\r\n    string  public constant symbol   = \"FRAX\";\r\n    string  public constant version  = \"1\";\r\n    uint8   public constant decimals = 18;\r\n    uint256 public totalSupply;\r\n    uint public FRAXlyFRAXLimit;\r\n\r\n    mapping (address => uint)                      public balanceOf;\r\n    mapping (address => mapping (address => uint)) private allowances;\r\n    mapping (address => uint)                      public nonces;\r\n    mapping (address => uint)                      public lastMintRestart;\r\n    mapping (address => uint)                      public FRAXMintedToday;\r\n\r\n    // event Approval(address indexed src, address indexed guy, uint wad);\r\n    // event Transfer(address indexed src, address indexed dst, uint wad);\r\n\r\n    // --- Math ---\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    // --- EIP712 niceties ---\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\r\n\r\n    constructor() {\r\n        wards[msg.sender] = 1;\r\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n            keccak256(bytes(name)),\r\n            keccak256(bytes(version)),\r\n            address(this)\r\n        ));\r\n        FRAXlyFRAXLimit = 10000000000000000000000;\r\n    }\r\n\r\n    function allowance( address account_, address sender_ ) external view returns ( uint ) {\r\n      return _allowance( account_, sender_ );\r\n    }\r\n\r\n    function _allowance( address account_, address sender_ ) internal view returns ( uint ) {\r\n      \r\n      return allowances[account_][sender_];\r\n    }\r\n\r\n    // --- Token ---\r\n    function transfer(address dst, uint wad) external returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad) public returns (bool) {\r\n      \r\n      \r\n      require(balanceOf[src] >= wad, \"FRAX/insufficient-balance\");\r\n        if (src != msg.sender && _allowance( src, msg.sender ) != uint(-1)) {\r\n            require(_allowance( src, msg.sender ) >= wad, \"FRAX/insufficient-allowance\");\r\n            allowances[src][msg.sender] = sub(_allowance( src, msg.sender ), wad);\r\n        }\r\n        balanceOf[src] = sub(balanceOf[src], wad);\r\n        balanceOf[dst] = add(balanceOf[dst], wad);\r\n        emit Transfer(src, dst, wad);\r\n        return true;\r\n    }\r\n\r\n    function addAuth(address usr) external auth {\r\n        wards[usr] = 1;\r\n    }\r\n\r\n    function adjustFRAXlyFRAXLimit(uint _limit) external auth {\r\n        FRAXlyFRAXLimit = _limit;\r\n    }\r\n\r\n    function mint(address usr, uint wad) external {\r\n\r\n      if(wards[msg.sender] == 0) {\r\n        require(add(wad, FRAXMintedToday[msg.sender]) <= FRAXlyFRAXLimit || sub(block.number, lastMintRestart[msg.sender]) >= 6500 && wad <= FRAXlyFRAXLimit, \"Over FRAXly FRAX Limit\");\r\n        if( sub(block.number, lastMintRestart[msg.sender]) >= 6500 ) {\r\n            FRAXMintedToday[msg.sender] = wad;\r\n            lastMintRestart[msg.sender] = block.number;\r\n        } else {\r\n            FRAXMintedToday[msg.sender] = add(FRAXMintedToday[msg.sender], wad);\r\n        }\r\n      }\r\n      \r\n      balanceOf[usr] = add(balanceOf[usr], wad);\r\n      \r\n      totalSupply    = add(totalSupply, wad);\r\n      \r\n      \r\n      emit Transfer(address(0), usr, wad);\r\n    }\r\n\r\n    function burn(address usr, uint wad) external {\r\n        require(balanceOf[usr] >= wad, \"FRAX/insufficient-balance\");\r\n        if (usr != msg.sender && _allowance( usr, msg.sender ) != uint(-1)) {\r\n            require(_allowance( usr, msg.sender ) >= wad, \"FRAX/insufficient-allowance\");\r\n            allowances[usr][msg.sender] = sub(_allowance( usr, msg.sender ), wad);\r\n        }\r\n        balanceOf[usr] = sub(balanceOf[usr], wad);\r\n        totalSupply    = sub(totalSupply, wad);\r\n        emit Transfer(usr, address(0), wad);\r\n    }\r\n\r\n    function _approve(address usr, uint wad) internal returns (bool) {\r\n      \r\n      allowances[msg.sender][usr] = wad;\r\n      \r\n      emit Approval(msg.sender, usr, wad);\r\n      return true;\r\n    }\r\n\r\n    function approve(address usr_, uint wad_ ) external returns (bool) {\r\n      \r\n      return _approve( usr_, wad_ ) ;\r\n    }\r\n\r\n    // --- Alias ---\r\n    function push(address usr, uint wad) external {\r\n        transferFrom(msg.sender, usr, wad);\r\n    }\r\n\r\n    function pull(address usr, uint wad) external {\r\n        transferFrom(usr, msg.sender, wad);\r\n    }\r\n\r\n    function move(address src, address dst, uint wad) external {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n\r\n    // --- Approve by signature ---\r\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\r\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) external\r\n    {\r\n        bytes32 digest =\r\n            keccak256(abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH,\r\n                                     holder,\r\n                                     spender,\r\n                                     nonce,\r\n                                     expiry,\r\n                                     allowed))\r\n        ));\r\n\r\n        require(holder != address(0), \"FRAX/invalid-address-0\");\r\n        require(holder == ecrecover(digest, v, r, s), \"FRAX/invalid-permit\");\r\n        require(expiry == 0 || block.timestamp <= expiry, \"FRAX/permit-expired\");\r\n        require(nonce == nonces[holder]++, \"FRAX/invalid-nonce\");\r\n        uint wad = allowed ? uint(-1) : 0;\r\n        allowances[holder][spender] = wad;\r\n        emit Approval(holder, spender, wad);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 9999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}