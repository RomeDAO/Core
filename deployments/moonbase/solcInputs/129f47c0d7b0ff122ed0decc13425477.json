{
  "language": "Solidity",
  "sources": {
    "src/aRomeERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"./types/ERC20Permit.sol\";\n\nimport \"./types/Policy.sol\";\n\ncontract PresaleOwned is Policy {\n    \n  address internal _presale;\n\n  function setPresale( address presale_ ) external onlyPolicy() returns ( bool ) {\n    _presale = presale_;\n\n    return true;\n  }\n\n  /**\n   * @dev Returns the address of the current vault.\n   */\n  function presale() public view returns (address) {\n    return _presale;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the vault.\n   */\n  modifier onlyPresale() {\n    require( _presale == msg.sender, \"PresaleOwned: caller is not the Presale\" );\n    _;\n  }\n\n}\n\ncontract aRome is ERC20Permit, PresaleOwned {\n\n  using SafeMath for uint256;\n\n    constructor()\n    ERC20(\"Alpha Rome\", \"aROME\", 9)\n    ERC20Permit(\"Alpha Rome\"){}\n\n    function mint(address account_, uint256 amount_) external onlyPresale() {\n        _mint(account_, amount_);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n    }\n\n    /*\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n     \n    function burnFrom(address account_, uint256 amount_) public virtual {\n        _burnFrom(account_, amount_);\n    }\n\n    function _burnFrom(address account_, uint256 amount_) public virtual {\n        uint256 decreasedAllowance_ =\n            allowance(account_, msg.sender).sub(\n                amount_,\n                \"ERC20: burn amount exceeds allowance\"\n            );\n\n        _approve(account_, msg.sender, decreasedAllowance_);\n        _burn(account_, amount_);\n    }\n}\n"
    },
    "src/types/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.5;\n\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./ERC20.sol\";\nimport \"../cryptography/EIP712.sol\";\nimport \"../cryptography/ECDSA.sol\";\nimport \"../libraries/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "src/types/Policy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\ninterface IPolicy {\n  function policy() external view returns (address);\n\n  function renouncePolicy() external;\n\n  function pushPolicy( address newOwner_ ) external;\n\n  function pullPolicy() external;\n}\n\ncontract Policy is IPolicy {\n\n    address internal _owner;\n    address internal _newOwner;\n\n    event OwnershipPushed(address indexed previousOwner, address indexed newOwner);\n    event OwnershipPulled(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipPushed( address(0), _owner );\n    }\n\n    function policy() public view override returns (address) {\n        return _owner;\n    }\n\n    modifier onlyPolicy() {\n        require( _owner == msg.sender, \"Ownable: caller is not the owner\" );\n        _;\n    }\n\n    function renouncePolicy() public virtual override onlyPolicy() {\n        emit OwnershipPushed( _owner, address(0) );\n        _owner = address(0);\n    }\n\n    function pushPolicy( address newOwner_ ) public virtual override onlyPolicy() {\n        require( newOwner_ != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipPushed( _owner, newOwner_ );\n        _newOwner = newOwner_;\n    }\n\n    function pullPolicy() public virtual override {\n        require( msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n        emit OwnershipPulled( _owner, _newOwner );\n        _owner = _newOwner;\n    }\n}\n"
    },
    "src/interfaces/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.5;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "src/types/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\nimport \"../libraries/SafeMath.sol\";\n\nimport \"../interfaces/IERC20.sol\";\n\n\nabstract contract ERC20 is IERC20 {\n\n    using SafeMath for uint256;\n\n    // TODO comment actual hash value.\n    bytes32 constant private ERC20TOKEN_ERC1820_INTERFACE_ID = keccak256( \"ERC20Token\" );\n\n    mapping (address => uint256) internal _balances;\n\n    mapping (address => mapping (address => uint256)) internal _allowances;\n\n    uint256 internal _totalSupply;\n\n    string internal _name;\n\n    string internal _symbol;\n\n    uint8 internal immutable _decimals;\n\n    constructor (string memory name_, string memory symbol_, uint8 decimals_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account_, uint256 ammount_) internal virtual {\n        require(account_ != address(0), \"ERC20: mint to the zero address\");\n        _beforeTokenTransfer(address(0), account_, ammount_);\n        _totalSupply = _totalSupply.add(ammount_);\n        _balances[account_] = _balances[account_].add(ammount_);\n        emit Transfer(address(0), account_, ammount_);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n  function _beforeTokenTransfer( address from_, address to_, uint256 amount_ ) internal virtual { }\n}\n"
    },
    "src/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.5;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n\n        uint256 chainID;\n        assembly {\n            chainID := chainid()\n        }\n\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = chainID;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n\n        uint256 chainID;\n        assembly {\n            chainID := chainid()\n        }\n\n        if (chainID == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        uint256 chainID;\n        assembly {\n            chainID := chainid()\n        }\n\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, chainID, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "src/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.5;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "src/libraries/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./SafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "src/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/*\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n    // Only used in the  BondingCalculator.sol\n    function sqrrt(uint256 a) internal pure returns (uint c) {\n        if (a > 3) {\n            c = a;\n            uint b = add( div( a, 2), 1 );\n            while (b < c) {\n                c = b;\n                b = div( add( div( a, b ), b), 2 );\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n}\n"
    },
    "src/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "src/Treasury.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport './libraries/SafeERC20.sol';\n\nimport './types/Policy.sol';\n\nimport \"./interfaces/IERC20Metadata.sol\";\n\ninterface IROMEERC20 {\n    function burnFrom(address account_, uint256 amount_) external;\n    function mint( uint256 amount_ ) external;\n    function mint( address account_, uint256 ammount_ ) external;\n}\n\ninterface IBondCalculator {\n  function valuation( address pair_, uint amount_ ) external view returns ( uint _value );\n}\n\ncontract RomeTreasury is Policy {\n\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    event Deposit( address indexed token, uint amount, uint value );\n    event Withdrawal( address indexed token, uint amount, uint value );\n    event CreateDebt( address indexed debtor, address indexed token, uint amount, uint value );\n    event RepayDebt( address indexed debtor, address indexed token, uint amount, uint value );\n    event ReservesManaged( address indexed token, uint amount );\n    event ReservesUpdated( uint indexed totalReserves );\n    event ReservesAudited( uint indexed totalReserves );\n    event RewardsMinted( address indexed caller, address indexed recipient, uint amount );\n    event ChangeQueued( MANAGING indexed managing, address queued );\n    event ChangeActivated( MANAGING indexed managing, address activated, bool result );\n\n    enum MANAGING { RESERVEDEPOSITOR, RESERVESPENDER, RESERVETOKEN, RESERVEMANAGER, LIQUIDITYDEPOSITOR, LIQUIDITYTOKEN, LIQUIDITYMANAGER, DEBTOR, REWARDMANAGER, SROME }\n\n    address public immutable ROME;\n    uint public immutable blocksNeededForQueue;\n\n    address[] public reserveTokens; // Push only, beware false-positives.\n    mapping( address => bool ) public isReserveToken;\n    mapping( address => uint ) public reserveTokenQueue; // Delays changes to mapping.\n\n    address[] public reserveDepositors; // Push only, beware false-positives. Only for viewing.\n    mapping( address => bool ) public isReserveDepositor;\n    mapping( address => uint ) public reserveDepositorQueue; // Delays changes to mapping.\n\n    address[] public reserveSpenders; // Push only, beware false-positives. Only for viewing.\n    mapping( address => bool ) public isReserveSpender;\n    mapping( address => uint ) public reserveSpenderQueue; // Delays changes to mapping.\n\n    address[] public liquidityTokens; // Push only, beware false-positives.\n    mapping( address => bool ) public isLiquidityToken;\n    mapping( address => uint ) public LiquidityTokenQueue; // Delays changes to mapping.\n\n    address[] public liquidityDepositors; // Push only, beware false-positives. Only for viewing.\n    mapping( address => bool ) public isLiquidityDepositor;\n    mapping( address => uint ) public LiquidityDepositorQueue; // Delays changes to mapping.\n\n    mapping( address => address ) public bondCalculator; // bond calculator for liquidity token\n\n    address[] public reserveManagers; // Push only, beware false-positives. Only for viewing.\n    mapping( address => bool ) public isReserveManager;\n    mapping( address => uint ) public ReserveManagerQueue; // Delays changes to mapping.\n\n    address[] public liquidityManagers; // Push only, beware false-positives. Only for viewing.\n    mapping( address => bool ) public isLiquidityManager;\n    mapping( address => uint ) public LiquidityManagerQueue; // Delays changes to mapping.\n\n    address[] public debtors; // Push only, beware false-positives. Only for viewing.\n    mapping( address => bool ) public isDebtor;\n    mapping( address => uint ) public debtorQueue; // Delays changes to mapping.\n    mapping( address => uint ) public debtorBalance;\n\n    address[] public rewardManagers; // Push only, beware false-positives. Only for viewing.\n    mapping( address => bool ) public isRewardManager;\n    mapping( address => uint ) public rewardManagerQueue; // Delays changes to mapping.\n\n    address public sROME;\n    uint public sROMEQueue; // Delays change to sROME address\n    \n    uint public totalReserves; // Risk-free value of all assets\n    uint public totalDebt;\n\n    constructor (\n        address _ROME,\n        address _DAI,\n        address _MIM,\n        address _FRAX,\n        address _ROMEFRAX,\n        address _bondCalculator,\n        address _DAO,\n        uint _blocksNeededForQueue\n    ) {\n        require( _ROME != address(0) );\n        ROME = _ROME;\n\n        isReserveToken[ _DAI ] = true;\n        reserveTokens.push( _DAI );\n\n        isReserveToken[ _MIM ] = true;\n        reserveTokens.push( _MIM );\n\n        isReserveToken[ _FRAX ] = true;\n        reserveTokens.push( _FRAX );\n\n        isLiquidityToken[ _ROMEFRAX ] = true;\n        liquidityTokens.push( _ROMEFRAX );\n        bondCalculator[ _ROMEFRAX ] = _bondCalculator;\n\n        isReserveDepositor[ _DAO ] = true;\n        reserveDepositors.push(_DAO);\n\n        blocksNeededForQueue = _blocksNeededForQueue;\n    }\n\n    /**\n        @notice allow approved address to deposit an asset for ROME\n        @param _amount uint\n        @param _token address\n        @param _profit uint\n        @return send_ uint\n     */\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( uint send_ ) {\n        require( isReserveToken[ _token ] || isLiquidityToken[ _token ], \"Not accepted\" );\n        IERC20( _token ).safeTransferFrom( msg.sender, address(this), _amount );\n\n        if ( isReserveToken[ _token ] ) {\n            require( isReserveDepositor[ msg.sender ], \"Not approved\" );\n        } else {\n            require( isLiquidityDepositor[ msg.sender ], \"Not approved\" );\n        }\n\n        uint value = valueOf( _token, _amount );\n        // mint ROME needed and store amount of rewards for distribution\n        send_ = value.sub( _profit );\n        IROMEERC20( ROME ).mint( msg.sender, send_ );\n\n        totalReserves = totalReserves.add( value );\n        emit ReservesUpdated( totalReserves );\n\n        emit Deposit( _token, _amount, value );\n    }\n\n    /**\n        @notice allow approved address to burn ROME for reserves\n        @param _amount uint\n        @param _token address\n     */\n    function withdraw( uint _amount, address _token ) external {\n        require( isReserveToken[ _token ], \"Not accepted\" ); // Only reserves can be used for redemptions\n        require( isReserveSpender[ msg.sender ] == true, \"Not approved\" );\n\n        uint value = valueOf( _token, _amount );\n        IROMEERC20( ROME ).burnFrom( msg.sender, value );\n\n        totalReserves = totalReserves.sub( value );\n        emit ReservesUpdated( totalReserves );\n\n        IERC20( _token ).safeTransfer( msg.sender, _amount );\n\n        emit Withdrawal( _token, _amount, value );\n    }\n\n    /**\n        @notice allow approved address to borrow reserves\n        @param _amount uint\n        @param _token address\n     */\n    function incurDebt( uint _amount, address _token ) external {\n        require( isDebtor[ msg.sender ], \"Not approved\" );\n        require( isReserveToken[ _token ], \"Not accepted\" );\n\n        uint value = valueOf( _token, _amount );\n\n        uint maximumDebt = IERC20( sROME ).balanceOf( msg.sender ); // Can only borrow against sROME held\n        uint availableDebt = maximumDebt.sub( debtorBalance[ msg.sender ] );\n        require( value <= availableDebt, \"Exceeds debt limit\" );\n\n        debtorBalance[ msg.sender ] = debtorBalance[ msg.sender ].add( value );\n        totalDebt = totalDebt.add( value );\n\n        totalReserves = totalReserves.sub( value );\n        emit ReservesUpdated( totalReserves );\n\n        IERC20( _token ).transfer( msg.sender, _amount );\n        \n        emit CreateDebt( msg.sender, _token, _amount, value );\n    }\n\n    /**\n        @notice allow approved address to repay borrowed reserves with reserves\n        @param _amount uint\n        @param _token address\n     */\n    function repayDebtWithReserve( uint _amount, address _token ) external {\n        require( isDebtor[ msg.sender ], \"Not approved\" );\n        require( isReserveToken[ _token ], \"Not accepted\" );\n\n        IERC20( _token ).safeTransferFrom( msg.sender, address(this), _amount );\n\n        uint value = valueOf( _token, _amount );\n        debtorBalance[ msg.sender ] = debtorBalance[ msg.sender ].sub( value );\n        totalDebt = totalDebt.sub( value );\n\n        totalReserves = totalReserves.add( value );\n        emit ReservesUpdated( totalReserves );\n\n        emit RepayDebt( msg.sender, _token, _amount, value );\n    }\n\n    /**\n        @notice allow approved address to repay borrowed reserves with ROME\n        @param _amount uint\n     */\n    function repayDebtWithROME( uint _amount ) external {\n        require( isDebtor[ msg.sender ], \"Not approved\" );\n\n        IROMEERC20( ROME ).burnFrom( msg.sender, _amount );\n\n        debtorBalance[ msg.sender ] = debtorBalance[ msg.sender ].sub( _amount );\n        totalDebt = totalDebt.sub( _amount );\n\n        emit RepayDebt( msg.sender, ROME, _amount, _amount );\n    }\n\n    /**\n        @notice allow approved address to withdraw assets\n        @param _token address\n        @param _amount uint\n     */\n    function manage( address _token, uint _amount ) external {\n        if( isLiquidityToken[ _token ] ) {\n            require( isLiquidityManager[ msg.sender ], \"Not approved\" );\n        } else {\n            require( isReserveManager[ msg.sender ], \"Not approved\" );\n        }\n\n        uint value = valueOf( _token, _amount );\n        require( value <= excessReserves(), \"Insufficient reserves\" );\n\n        totalReserves = totalReserves.sub( value );\n        emit ReservesUpdated( totalReserves );\n\n        IERC20( _token ).safeTransfer( msg.sender, _amount );\n\n        emit ReservesManaged( _token, _amount );\n    }\n\n    /**\n        @notice send epoch reward to staking contract\n     */\n    function mintRewards( address _recipient, uint _amount ) external {\n        require( isRewardManager[ msg.sender ], \"Not approved\" );\n        require( _amount <= excessReserves(), \"Insufficient reserves\" );\n\n        IROMEERC20( ROME ).mint( _recipient, _amount );\n\n        emit RewardsMinted( msg.sender, _recipient, _amount );\n    } \n\n    /**\n        @notice returns excess reserves not backing tokens\n        @return uint\n     */\n    function excessReserves() public view returns ( uint ) {\n        return totalReserves.sub( IERC20( ROME ).totalSupply().sub( totalDebt ) );\n    }\n\n    /**\n        @notice takes inventory of all tracked assets\n        @notice always consolidate to recognized reserves before audit\n     */\n    function auditReserves() external onlyPolicy() {\n        uint reserves;\n        for( uint i = 0; i < reserveTokens.length; i++ ) {\n            reserves = reserves.add ( \n                valueOf( reserveTokens[ i ], IERC20( reserveTokens[ i ] ).balanceOf( address(this) ) )\n            );\n        }\n        for( uint i = 0; i < liquidityTokens.length; i++ ) {\n            reserves = reserves.add (\n                valueOf( liquidityTokens[ i ], IERC20( liquidityTokens[ i ] ).balanceOf( address(this) ) )\n            );\n        }\n        totalReserves = reserves;\n        emit ReservesUpdated( reserves );\n        emit ReservesAudited( reserves );\n    }\n\n    /**\n        @notice returns ROME valuation of asset\n        @param _token address\n        @param _amount uint\n        @return value_ uint\n     */\n    function valueOf( address _token, uint _amount ) public view returns ( uint value_ ) {\n        if ( isReserveToken[ _token ] ) {\n            // convert amount to match ROME decimals\n            value_ = _amount.mul( 10 ** IERC20Metadata( ROME ).decimals() ).div( 10 ** IERC20Metadata( _token ).decimals() );\n        } else if ( isLiquidityToken[ _token ] ) {\n            value_ = IBondCalculator( bondCalculator[ _token ] ).valuation( _token, _amount );\n        }\n    }\n\n    /**\n        @notice queue address to change boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @return bool\n     */\n    function queue( MANAGING _managing, address _address ) external onlyPolicy() returns ( bool ) {\n        require( _address != address(0) );\n        if ( _managing == MANAGING.RESERVEDEPOSITOR ) { // 0\n            reserveDepositorQueue[ _address ] = block.number.add( blocksNeededForQueue );\n        } else if ( _managing == MANAGING.RESERVESPENDER ) { // 1\n            reserveSpenderQueue[ _address ] = block.number.add( blocksNeededForQueue );\n        } else if ( _managing == MANAGING.RESERVETOKEN ) { // 2\n            reserveTokenQueue[ _address ] = block.number.add( blocksNeededForQueue );\n        } else if ( _managing == MANAGING.RESERVEMANAGER ) { // 3\n            ReserveManagerQueue[ _address ] = block.number.add( blocksNeededForQueue.mul( 2 ) );\n        } else if ( _managing == MANAGING.LIQUIDITYDEPOSITOR ) { // 4\n            LiquidityDepositorQueue[ _address ] = block.number.add( blocksNeededForQueue );\n        } else if ( _managing == MANAGING.LIQUIDITYTOKEN ) { // 5\n            LiquidityTokenQueue[ _address ] = block.number.add( blocksNeededForQueue );\n        } else if ( _managing == MANAGING.LIQUIDITYMANAGER ) { // 6\n            LiquidityManagerQueue[ _address ] = block.number.add( blocksNeededForQueue.mul( 2 ) );\n        } else if ( _managing == MANAGING.DEBTOR ) { // 7\n            debtorQueue[ _address ] = block.number.add( blocksNeededForQueue );\n        } else if ( _managing == MANAGING.REWARDMANAGER ) { // 8\n            rewardManagerQueue[ _address ] = block.number.add( blocksNeededForQueue );\n        } else if ( _managing == MANAGING.SROME ) { // 9\n            sROMEQueue = block.number.add( blocksNeededForQueue );\n        } else return false;\n\n        emit ChangeQueued( _managing, _address );\n        return true;\n    }\n\n    /**\n        @notice verify queue then set boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @param _calculator address\n        @return bool\n     */\n    function toggle( MANAGING _managing, address _address, address _calculator ) external onlyPolicy() returns ( bool ) {\n        require( _address != address(0) );\n        bool result;\n        if ( _managing == MANAGING.RESERVEDEPOSITOR ) { // 0\n            if ( requirements( reserveDepositorQueue, isReserveDepositor, _address ) ) {\n                reserveDepositorQueue[ _address ] = 0;\n                if( !listContains( reserveDepositors, _address ) ) {\n                    reserveDepositors.push( _address );\n                }\n            }\n            result = !isReserveDepositor[ _address ];\n            isReserveDepositor[ _address ] = result;\n            \n        } else if ( _managing == MANAGING.RESERVESPENDER ) { // 1\n            if ( requirements( reserveSpenderQueue, isReserveSpender, _address ) ) {\n                reserveSpenderQueue[ _address ] = 0;\n                if( !listContains( reserveSpenders, _address ) ) {\n                    reserveSpenders.push( _address );\n                }\n            }\n            result = !isReserveSpender[ _address ];\n            isReserveSpender[ _address ] = result;\n\n        } else if ( _managing == MANAGING.RESERVETOKEN ) { // 2\n            if ( requirements( reserveTokenQueue, isReserveToken, _address ) ) {\n                reserveTokenQueue[ _address ] = 0;\n                if( !listContains( reserveTokens, _address ) ) {\n                    reserveTokens.push( _address );\n                }\n            }\n            result = !isReserveToken[ _address ];\n            isReserveToken[ _address ] = result;\n\n        } else if ( _managing == MANAGING.RESERVEMANAGER ) { // 3\n            if ( requirements( ReserveManagerQueue, isReserveManager, _address ) ) {\n                reserveManagers.push( _address );\n                ReserveManagerQueue[ _address ] = 0;\n                if( !listContains( reserveManagers, _address ) ) {\n                    reserveManagers.push( _address );\n                }\n            }\n            result = !isReserveManager[ _address ];\n            isReserveManager[ _address ] = result;\n\n        } else if ( _managing == MANAGING.LIQUIDITYDEPOSITOR ) { // 4\n            if ( requirements( LiquidityDepositorQueue, isLiquidityDepositor, _address ) ) {\n                liquidityDepositors.push( _address );\n                LiquidityDepositorQueue[ _address ] = 0;\n                if( !listContains( liquidityDepositors, _address ) ) {\n                    liquidityDepositors.push( _address );\n                }\n            }\n            result = !isLiquidityDepositor[ _address ];\n            isLiquidityDepositor[ _address ] = result;\n\n        } else if ( _managing == MANAGING.LIQUIDITYTOKEN ) { // 5\n            if ( requirements( LiquidityTokenQueue, isLiquidityToken, _address ) ) {\n                LiquidityTokenQueue[ _address ] = 0;\n                if( !listContains( liquidityTokens, _address ) ) {\n                    liquidityTokens.push( _address );\n                }\n            }\n            result = !isLiquidityToken[ _address ];\n            isLiquidityToken[ _address ] = result;\n            bondCalculator[ _address ] = _calculator;\n\n        } else if ( _managing == MANAGING.LIQUIDITYMANAGER ) { // 6\n            if ( requirements( LiquidityManagerQueue, isLiquidityManager, _address ) ) {\n                LiquidityManagerQueue[ _address ] = 0;\n                if( !listContains( liquidityManagers, _address ) ) {\n                    liquidityManagers.push( _address );\n                }\n            }\n            result = !isLiquidityManager[ _address ];\n            isLiquidityManager[ _address ] = result;\n\n        } else if ( _managing == MANAGING.DEBTOR ) { // 7\n            if ( requirements( debtorQueue, isDebtor, _address ) ) {\n                debtorQueue[ _address ] = 0;\n                if( !listContains( debtors, _address ) ) {\n                    debtors.push( _address );\n                }\n            }\n            result = !isDebtor[ _address ];\n            isDebtor[ _address ] = result;\n\n        } else if ( _managing == MANAGING.REWARDMANAGER ) { // 8\n            if ( requirements( rewardManagerQueue, isRewardManager, _address ) ) {\n                rewardManagerQueue[ _address ] = 0;\n                if( !listContains( rewardManagers, _address ) ) {\n                    rewardManagers.push( _address );\n                }\n            }\n            result = !isRewardManager[ _address ];\n            isRewardManager[ _address ] = result;\n\n        } else if ( _managing == MANAGING.SROME ) { // 9\n            sROMEQueue = 0;\n            sROME = _address;\n            result = true;\n\n        } else return false;\n\n        emit ChangeActivated( _managing, _address, result );\n        return true;\n    }\n\n    /**\n        @notice checks requirements and returns altered structs\n        @param queue_ mapping( address => uint )\n        @param status_ mapping( address => bool )\n        @param _address address\n        @return bool \n     */\n    function requirements( \n        mapping( address => uint ) storage queue_, \n        mapping( address => bool ) storage status_, \n        address _address \n    ) internal view returns ( bool ) {\n        if ( !status_[ _address ] ) {\n            require( queue_[ _address ] != 0, \"Must queue\" );\n            require( queue_[ _address ] <= block.number, \"Queue not expired\" );\n            return true;\n        } return false;\n    }\n\n    /**\n        @notice checks array to ensure against duplicate\n        @param _list address[]\n        @param _token address\n        @return bool\n     */\n    function listContains( address[] storage _list, address _token ) internal view returns ( bool ) {\n        for( uint i = 0; i < _list.length; i++ ) {\n            if( _list[ i ] == _token ) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "src/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "src/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IERC20Metadata is IERC20 {\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.7.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    function addressToString(address _address) internal pure returns(string memory) {\n        bytes32 _bytes = bytes32(uint256(_address));\n        bytes memory HEX = \"0123456789abcdef\";\n        bytes memory _addr = new bytes(42);\n\n        _addr[0] = '0';\n        _addr[1] = 'x';\n\n        for(uint256 i = 0; i < 20; i++) {\n            _addr[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\n            _addr[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\n        }\n\n        return string(_addr);\n\n    }\n}\n"
    },
    "src/bonds/ROMEMIMBondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"../types/Policy.sol\";\n\nimport \"../types/ERC20Permit.sol\";\n\nimport \"../libraries/SafeERC20.sol\";\n\nimport \"../libraries/FixedPoint.sol\";\n\nimport \"../interfaces/IERC20Metadata.sol\";\n\ninterface ITreasury {\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( bool );\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\n}\n\ninterface IBondCalculator {\n    function valuation( address _LP, uint _amount ) external view returns ( uint );\n    function markdown( address _LP ) external view returns ( uint );\n}\n\ninterface IStaking {\n    function stake( uint _amount, address _recipient ) external returns ( bool );\n}\n\ninterface IStakingHelper {\n    function stake( uint _amount, address _recipient ) external;\n}\n\ncontract ROMEMIMBondDepository is Policy {\n\n    using FixedPoint for *;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n\n\n\n    /* ======== EVENTS ======== */\n\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\n\n\n\n\n    /* ======== STATE VARIABLES ======== */\n\n    address public immutable ROME; // token given as payment for bond\n    address public immutable principle; // token used to create bond\n    address public immutable treasury; // mints ROME when receives principle\n    address public immutable WARCHEST; // receives fee from principle\n\n    bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\n    address public immutable bondCalculator; // calculates value of LP tokens\n\n    address public staking; // to auto-stake payout\n    address public stakingHelper; // to stake and claim if no staking warmup\n    bool public useHelper;\n\n    Terms public terms; // stores terms for new bonds\n    Adjust public adjustment; // stores adjustment to BCV data\n\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\n\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\n    uint public lastDecay; // reference block for debt decay\n\n    bool public isInitialized; // bool to prevent deposits before initialization\n\n\n\n\n    /* ======== STRUCTS ======== */\n\n    // Info for creating new bonds\n    struct Terms {\n        uint controlVariable; // scaling variable for price\n        uint vestingTerm; // in blocks\n        uint minimumPrice; // vs principle value\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n        uint fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)]\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n    }\n\n    // Info for bond holder\n    struct Bond {\n        uint payout; // ROME remaining to be paid\n        uint vesting; // Blocks left to vest\n        uint lastBlock; // Last interaction\n        uint pricePaid; // In DAI, for front end viewing\n    }\n\n    // Info for incremental adjustments to control variable \n    struct Adjust {\n        bool add; // addition or subtraction\n        uint rate; // increment\n        uint target; // BCV when adjustment finished\n        uint buffer; // minimum length (in blocks) between adjustments\n        uint lastBlock; // block when last adjustment made\n    }\n\n\n\n\n    /* ======== INITIALIZATION ======== */\n\n    constructor ( \n        address _ROME,\n        address _principle,\n        address _treasury, \n        address _WARCHEST,\n        address _bondCalculator\n    ) {\n        require( _ROME != address(0) );\n        ROME = _ROME;\n        require( _principle != address(0) );\n        principle = _principle;\n        require( _treasury != address(0) );\n        treasury = _treasury;\n        require( _WARCHEST != address(0) );\n        WARCHEST = _WARCHEST;\n        // bondCalculator should be address(0) if not LP bond\n        bondCalculator = _bondCalculator;\n        isLiquidityBond = ( _bondCalculator != address(0) );\n    }\n\n    /**\n     *  @notice initializes bond parameters\n     *  @param _controlVariable uint\n     *  @param _vestingTerm uint\n     *  @param _minimumPrice uint\n     *  @param _maxPayout uint\n     *  @param _fee uint\n     *  @param _maxDebt uint\n     *  @param _initialDebt uint\n     */\n    function initializeBondTerms( \n        uint _controlVariable, \n        uint _vestingTerm,\n        uint _minimumPrice,\n        uint _maxPayout,\n        uint _fee,\n        uint _maxDebt,\n        uint _initialDebt\n    ) external onlyPolicy() {\n        require( terms.controlVariable == 0, \"Bonds must be initialized from 0\" );\n        terms = Terms ({\n            controlVariable: _controlVariable,\n            vestingTerm: _vestingTerm,\n            minimumPrice: _minimumPrice,\n            maxPayout: _maxPayout,\n            fee: _fee,\n            maxDebt: _maxDebt\n        });\n        totalDebt = _initialDebt;\n        lastDecay = block.number;\n        isInitialized = true;\n    }\n\n\n\n    \n    /* ======== POLICY FUNCTIONS ======== */\n\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT }\n    /**\n     *  @notice set parameters for new bonds\n     *  @param _parameter PARAMETER\n     *  @param _input uint\n     */\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyPolicy() {\n        if ( _parameter == PARAMETER.VESTING ) { // 0\n            require( _input >= 10000, \"Vesting must be longer than 36 hours\" );\n            terms.vestingTerm = _input;\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\n            require( _input <= 1000, \"Payout cannot be above 1 percent\" );\n            terms.maxPayout = _input;\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\n            require( _input <= 10000, \"WARCHEST fee cannot exceed payout\" );\n            terms.fee = _input;\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\n            terms.maxDebt = _input;\n        }\n    }\n\n    /**\n     *  @notice set control variable adjustment\n     *  @param _addition bool\n     *  @param _increment uint\n     *  @param _target uint\n     *  @param _buffer uint\n     */\n    function setAdjustment ( \n        bool _addition,\n        uint _increment, \n        uint _target,\n        uint _buffer \n    ) external onlyPolicy() {\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \"Increment too large\" );\n\n        adjustment = Adjust({\n            add: _addition,\n            rate: _increment,\n            target: _target,\n            buffer: _buffer,\n            lastBlock: block.number\n        });\n    }\n\n    /**\n     *  @notice set contract for auto stake\n     *  @param _staking address\n     *  @param _helper bool\n     */\n    function setStaking( address _staking, bool _helper ) external onlyPolicy() {\n        require( _staking != address(0) );\n        if ( _helper ) {\n            useHelper = true;\n            stakingHelper = _staking;\n        } else {\n            useHelper = false;\n            staking = _staking;\n        }\n    }\n\n\n    \n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice deposit bond\n     *  @param _amount uint\n     *  @param _maxPrice uint\n     *  @param _depositor address\n     *  @return uint\n     */\n    function deposit( \n        uint _amount, \n        uint _maxPrice,\n        address _depositor\n    ) external returns ( uint ) {\n        require(isInitialized, \"Bonds Not Initalized\");\n        require( _depositor != address(0), \"Invalid address\" );\n\n        decayDebt();\n        require( totalDebt <= terms.maxDebt, \"Max capacity reached\" );\n\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\n        uint nativePrice = _bondPrice();\n\n        require( _maxPrice >= nativePrice, \"Slippage limit: more than max price\" ); // slippage protection\n\n        uint value = ITreasury( treasury ).valueOf( principle, _amount );\n        uint payout = payoutFor( value ); // payout to bonder is computed\n\n        require( payout >= 10000000, \"Bond too small\" ); // must be > 0.01 ROME ( underflow protection )\n        require( payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n        // profits are calculated\n        uint fee = payout.mul( terms.fee ).div( 10000 );\n        uint profit = value.sub( payout ).sub( fee );\n\n        /**\n            principle is transferred in\n            approved and\n            deposited into the treasury, returning (_amount - profit) ROME\n         */\n        IERC20( principle ).safeTransferFrom( msg.sender, address(this), _amount );\n        IERC20( principle ).approve( address( treasury ), _amount );\n        ITreasury( treasury ).deposit( _amount, principle, profit );\n        \n        if ( fee != 0 ) { // fee is transferred to WARCHEST\n            IERC20( ROME ).safeTransfer( WARCHEST, fee );\n        }\n        \n        // total debt is increased\n        totalDebt = totalDebt.add( value ); \n                \n        // depositor info is stored\n        bondInfo[ _depositor ] = Bond({ \n            payout: bondInfo[ _depositor ].payout.add( payout ),\n            vesting: terms.vestingTerm,\n            lastBlock: block.number,\n            pricePaid: priceInUSD\n        });\n\n        // indexed events are emitted\n        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\n\n        adjust(); // control variable is adjusted\n        return payout; \n    }\n\n    /** \n     *  @notice redeem bond for user\n     *  @param _recipient address\n     *  @param _stake bool\n     *  @return uint\n     */ \n    function redeem( address _recipient, bool _stake ) external returns ( uint ) {        \n        Bond memory info = bondInfo[ _recipient ];\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\n\n        if ( percentVested >= 10000 ) { // if fully vested\n            delete bondInfo[ _recipient ]; // delete user info\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\n            return stakeOrSend( _recipient, _stake, info.payout ); // pay user everything due\n\n        } else { // if unfinished\n            // calculate payout vested\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\n\n            // store updated deposit info\n            bondInfo[ _recipient ] = Bond({\n                payout: info.payout.sub( payout ),\n                vesting: info.vesting.sub( block.number.sub( info.lastBlock ) ),\n                lastBlock: block.number,\n                pricePaid: info.pricePaid\n            });\n\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\n            return stakeOrSend( _recipient, _stake, payout );\n        }\n    }\n\n\n\n    \n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n    /**\n     *  @notice allow user to stake payout automatically\n     *  @param _stake bool\n     *  @param _amount uint\n     *  @return uint\n     */\n    function stakeOrSend( address _recipient, bool _stake, uint _amount ) internal returns ( uint ) {\n        if ( !_stake ) { // if user does not want to stake\n            IERC20( ROME ).transfer( _recipient, _amount ); // send payout\n        } else { // if user wants to stake\n            if ( useHelper ) { // use if staking warmup is 0\n                IERC20( ROME ).approve( stakingHelper, _amount );\n                IStakingHelper( stakingHelper ).stake( _amount, _recipient );\n            } else {\n                IERC20( ROME ).approve( staking, _amount );\n                IStaking( staking ).stake( _amount, _recipient );\n            }\n        }\n        return _amount;\n    }\n\n    /**\n     *  @notice makes incremental adjustment to control variable\n     */\n    function adjust() internal {\n        uint blockCanAdjust = adjustment.lastBlock.add( adjustment.buffer );\n        if( adjustment.rate != 0 && block.number >= blockCanAdjust ) {\n            uint initial = terms.controlVariable;\n            if ( adjustment.add ) {\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\n                if ( terms.controlVariable >= adjustment.target ) {\n                    adjustment.rate = 0;\n                }\n            } else {\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\n                if ( terms.controlVariable <= adjustment.target ) {\n                    adjustment.rate = 0;\n                }\n            }\n            adjustment.lastBlock = block.number;\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\n        }\n    }\n\n    /**\n     *  @notice reduce total debt\n     */\n    function decayDebt() internal {\n        totalDebt = totalDebt.sub( debtDecay() );\n        lastDecay = block.number;\n    }\n\n\n\n\n    /* ======== VIEW FUNCTIONS ======== */\n\n    /**\n     *  @notice determine maximum bond size\n     *  @return uint\n     */\n    function maxPayout() public view returns ( uint ) {\n        return IERC20( ROME ).totalSupply().mul( terms.maxPayout ).div( 100000 );\n    }\n\n    /**\n     *  @notice calculate interest due for new bond\n     *  @param _value uint\n     *  @return uint\n     */\n    function payoutFor( uint _value ) public view returns ( uint ) {\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e16 );\n    }\n\n\n    /**\n     *  @notice calculate current bond premium\n     *  @return price_ uint\n     */\n    function bondPrice() public view returns ( uint price_ ) {        \n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\n        if ( price_ < terms.minimumPrice ) {\n            price_ = terms.minimumPrice;\n        }\n    }\n\n    /**\n     *  @notice calculate current bond price and remove floor if above\n     *  @return price_ uint\n     */\n    function _bondPrice() internal returns ( uint price_ ) {\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\n        if ( price_ < terms.minimumPrice ) {\n            price_ = terms.minimumPrice;        \n        } else if ( terms.minimumPrice != 0 ) {\n            terms.minimumPrice = 0;\n        }\n    }\n\n    /**\n     *  @notice converts bond price to DAI value\n     *  @return price_ uint\n     */\n    function bondPriceInUSD() public view returns ( uint price_ ) {\n        if( isLiquidityBond ) {\n            price_ = bondPrice().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 100 );\n        } else {\n            price_ = bondPrice().mul( 10 ** IERC20Metadata( principle ).decimals() ).div( 100 );\n        }\n    }\n\n\n    /**\n     *  @notice calculate current ratio of debt to ROME supply\n     *  @return debtRatio_ uint\n     */\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \n        uint supply = IERC20( ROME ).totalSupply();\n        debtRatio_ = FixedPoint.fraction( \n            currentDebt().mul( 1e9 ), \n            supply\n        ).decode112with18().div( 1e18 );\n    }\n\n    /**\n     *  @notice debt ratio in same terms for reserve or liquidity bonds\n     *  @return uint\n     */\n    function standardizedDebtRatio() external view returns ( uint ) {\n        if ( isLiquidityBond ) {\n            return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\n        } else {\n            return debtRatio();\n        }\n    }\n\n    /**\n     *  @notice calculate debt factoring in decay\n     *  @return uint\n     */\n    function currentDebt() public view returns ( uint ) {\n        return totalDebt.sub( debtDecay() );\n    }\n\n    /**\n     *  @notice amount to decay total debt by\n     *  @return decay_ uint\n     */\n    function debtDecay() public view returns ( uint decay_ ) {\n        uint blocksSinceLast = block.number.sub( lastDecay );\n        decay_ = totalDebt.mul( blocksSinceLast ).div( terms.vestingTerm );\n        if ( decay_ > totalDebt ) {\n            decay_ = totalDebt;\n        }\n    }\n\n\n    /**\n     *  @notice calculate how far into vesting a depositor is\n     *  @param _depositor address\n     *  @return percentVested_ uint\n     */\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\n        Bond memory bond = bondInfo[ _depositor ];\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\n        uint vesting = bond.vesting;\n\n        if ( vesting > 0 ) {\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\n        } else {\n            percentVested_ = 0;\n        }\n    }\n\n    /**\n     *  @notice calculate amount of ROME available for claim by depositor\n     *  @param _depositor address\n     *  @return pendingPayout_ uint\n     */\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\n        uint percentVested = percentVestedFor( _depositor );\n        uint payout = bondInfo[ _depositor ].payout;\n\n        if ( percentVested >= 10000 ) {\n            pendingPayout_ = payout;\n        } else {\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\n        }\n    }\n\n\n\n\n    /* ======= AUXILLIARY ======= */\n\n    /**\n     *  @notice allow anyone to send lost tokens (excluding principle or ROME) to the WARCHEST\n     *  @return bool\n     */\n    function recoverLostToken( address _token ) external returns ( bool ) {\n        require( _token != ROME );\n        require( _token != principle );\n        IERC20( _token ).safeTransfer( WARCHEST, IERC20( _token ).balanceOf( address(this) ) );\n        return true;\n    }\n}\n"
    },
    "src/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & -d;\n        d /= pow2;\n        l /= pow2;\n        l += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n        require(h < d, 'FullMath::mulDiv: overflow');\n        return fullDiv(l, h, d);\n    }\n}\n\nlibrary FixedPoint {\n\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\n\n        return uint(self._x) / 5192296858534827;\n    }\n\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= uint144(-1)) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        }\n    }\n}\n"
    },
    "src/bonds/ROMEMOVRBondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"../types/Policy.sol\";\n\nimport \"../types/ERC20Permit.sol\";\n\nimport \"../libraries/SafeERC20.sol\";\n\nimport \"../libraries/FixedPoint.sol\";\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n\ninterface ITreasury {\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( bool );\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\n    function mintRewards( address _recipient, uint _amount ) external;\n}\n\ninterface IBondCalculator {\n    function valuation( address _LP, uint _amount ) external view returns ( uint );\n    function markdown( address _LP ) external view returns ( uint );\n}\n\ninterface IStaking {\n    function stake( uint _amount, address _recipient ) external returns ( bool );\n}\n\ninterface IStakingHelper {\n    function stake( uint _amount, address _recipient ) external;\n}\n\ncontract ROMEMOVRBondDepository is Policy {\n\n    using FixedPoint for *;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n\n\n\n    /* ======== EVENTS ======== */\n\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\n\n\n\n\n    /* ======== STATE VARIABLES ======== */\n\n    address public immutable ROME; // token given as payment for bond\n    address public immutable principle; // token used to create bond\n    address public immutable treasury; // mints ROME when receives principle\n    address public immutable WARCHEST; // receives fee share from bond\n\n    address public immutable bondCalculator; // calculates value of LP tokens\n\n    AggregatorV3Interface internal priceFeed;\n\n    address public staking; // to auto-stake payout\n    address public stakingHelper; // to stake and claim if no staking warmup\n    bool public useHelper;\n\n    Terms public terms; // stores terms for new bonds\n    Adjust public adjustment; // stores adjustment to BCV data\n\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\n\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\n    uint public lastDecay; // reference block for debt decay\n\n    bool public isInitialized; // bool to prevent deposits before initialization\n\n\n    /* ======== STRUCTS ======== */\n\n    // Info for creating new bonds\n    struct Terms {\n        uint controlVariable; // scaling variable for price\n        uint vestingTerm; // in blocks\n        uint minimumPrice; // vs principle value. 4 decimals (1500 = 0.15)\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n        uint fee; // as % of bond principle, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)]\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n    }\n\n    // Info for bond holder\n    struct Bond {\n        uint payout; // ROME remaining to be paid\n        uint vesting; // Blocks left to vest\n        uint lastBlock; // Last interaction\n        uint pricePaid; // In DAI, for front end viewing\n    }\n\n    // Info for incremental adjustments to control variable \n    struct Adjust {\n        bool add; // addition or subtraction\n        uint rate; // increment\n        uint target; // BCV when adjustment finished\n        uint buffer; // minimum length (in blocks) between adjustments\n        uint lastBlock; // block when last adjustment made\n    }\n\n\n\n\n    /* ======== INITIALIZATION ======== */\n\n    constructor ( \n        address _ROME,\n        address _principle,\n        address _treasury, \n        address _WARCHEST,\n        address _bondCalculator,\n        address _feed\n    ) {\n        require( _ROME != address(0) );\n        ROME = _ROME;\n        require( _principle != address(0) );\n        principle = _principle;\n        require( _treasury != address(0) );\n        treasury = _treasury;\n        require( _WARCHEST != address(0) );\n        WARCHEST = _WARCHEST;\n        // bondCalculator should be address(0) if not LP bond\n        bondCalculator = _bondCalculator;\n        priceFeed = AggregatorV3Interface( _feed );\n    }\n\n    /**\n     *  @notice initializes bond parameters\n     *  @param _controlVariable uint\n     *  @param _vestingTerm uint\n     *  @param _minimumPrice uint\n     *  @param _maxPayout uint\n     *  @param _maxDebt uint\n     *  @param _initialDebt uint\n     */\n    function initializeBondTerms( \n        uint _controlVariable, \n        uint _vestingTerm,\n        uint _minimumPrice,\n        uint _maxPayout,\n        uint _fee,\n        uint _maxDebt,\n        uint _initialDebt\n    ) external onlyPolicy() {\n        require( terms.controlVariable == 0, \"Bonds must be initialized from 0\" );\n        terms = Terms ({\n            controlVariable: _controlVariable,\n            vestingTerm: _vestingTerm,\n            minimumPrice: _minimumPrice,\n            maxPayout: _maxPayout,\n            fee: _fee,\n            maxDebt: _maxDebt\n        });\n        totalDebt = _initialDebt;\n        lastDecay = block.number;\n        isInitialized = true;\n    }\n\n\n\n    \n    /* ======== POLICY FUNCTIONS ======== */\n\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT }\n    /**\n     *  @notice set parameters for new bonds\n     *  @param _parameter PARAMETER\n     *  @param _input uint\n     */\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyPolicy() {\n        if ( _parameter == PARAMETER.VESTING ) { // 0\n            require( _input >= 10000, \"Vesting must be longer than 36 hours\" );\n            terms.vestingTerm = _input;\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\n            require( _input <= 1000, \"Payout cannot be above 1 percent\" );\n            terms.maxPayout = _input;\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\n            require( _input <= 10000, \"WARCHEST fee cannot exceed payout\" );\n            terms.fee = _input;\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\n            terms.maxDebt = _input;\n        }\n    }\n\n    /**\n     *  @notice set control variable adjustment\n     *  @param _addition bool\n     *  @param _increment uint\n     *  @param _target uint\n     *  @param _buffer uint\n     */\n    function setAdjustment ( \n        bool _addition,\n        uint _increment, \n        uint _target,\n        uint _buffer \n    ) external onlyPolicy() {\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \"Increment too large\" );\n\n        adjustment = Adjust({\n            add: _addition,\n            rate: _increment,\n            target: _target,\n            buffer: _buffer,\n            lastBlock: block.number\n        });\n    }\n\n    /**\n     *  @notice set contract for auto stake\n     *  @param _staking address\n     *  @param _helper bool\n     */\n    function setStaking( address _staking, bool _helper ) external onlyPolicy() {\n        require( _staking != address(0) );\n        if ( _helper ) {\n            useHelper = true;\n            stakingHelper = _staking;\n        } else {\n            useHelper = false;\n            staking = _staking;\n        }\n    }\n\n\n    \n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice deposit bond\n     *  @param _amount uint\n     *  @param _maxPrice uint\n     *  @param _depositor address\n     *  @return uint\n     */\n    function deposit( \n        uint _amount, \n        uint _maxPrice,\n        address _depositor\n    ) external returns ( uint ) {\n        require(isInitialized, \"Bonds Not Initalized\");\n        require( _depositor != address(0), \"Invalid address\" );\n\n        decayDebt();\n        require( totalDebt <= terms.maxDebt, \"Max capacity reached\" );\n\n        // feees are calculated\n        uint fee = _amount.mul( terms.fee ).div( 10000 );\n        _amount = _amount.sub( fee );\n\n        if ( fee != 0 ) { // fee is transferred to warchest\n            IERC20( principle ).safeTransfer( WARCHEST, fee );\n        }\n        \n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\n        uint nativePrice = _bondPrice();\n\n        require( _maxPrice >= nativePrice, \"Slippage limit: more than max price\" ); // slippage protection\n\n        uint value = ITreasury( treasury ).valueOf( principle, _amount );\n        uint payout = payoutFor( value ); // payout to bonder is computed\n\n        require( payout >= 10000000, \"Bond too small\" ); // must be > 0.01 ROME ( underflow protection )\n        require( payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n        /**\n            asset carries risk and is not minted against\n            asset transfered to treasury and rewards minted as payout\n         */\n        IERC20( principle ).safeTransferFrom( msg.sender, treasury, _amount );\n        ITreasury( treasury ).mintRewards( address(this), payout );\n        \n        // total debt is increased\n        totalDebt = totalDebt.add( value ); \n                \n        // depositor info is stored\n        bondInfo[ _depositor ] = Bond({ \n            payout: bondInfo[ _depositor ].payout.add( payout ),\n            vesting: terms.vestingTerm,\n            lastBlock: block.number,\n            pricePaid: priceInUSD\n        });\n\n        // indexed events are emitted\n        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\n\n        adjust(); // control variable is adjusted\n        return payout; \n    }\n\n    /** \n     *  @notice redeem bond for user\n     *  @param _recipient address\n     *  @param _stake bool\n     *  @return uint\n     */ \n    function redeem( address _recipient, bool _stake ) external returns ( uint ) {        \n        Bond memory info = bondInfo[ _recipient ];\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\n\n        if ( percentVested >= 10000 ) { // if fully vested\n            delete bondInfo[ _recipient ]; // delete user info\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\n            return stakeOrSend( _recipient, _stake, info.payout ); // pay user everything due\n\n        } else { // if unfinished\n            // calculate payout vested\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\n\n            // store updated deposit info\n            bondInfo[ _recipient ] = Bond({\n                payout: info.payout.sub( payout ),\n                vesting: info.vesting.sub( block.number.sub( info.lastBlock ) ),\n                lastBlock: block.number,\n                pricePaid: info.pricePaid\n            });\n\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\n            return stakeOrSend( _recipient, _stake, payout );\n        }\n    }\n\n\n\n    \n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n    /**\n     *  @notice allow user to stake payout automatically\n     *  @param _stake bool\n     *  @param _amount uint\n     *  @return uint\n     */\n    function stakeOrSend( address _recipient, bool _stake, uint _amount ) internal returns ( uint ) {\n        if ( !_stake ) { // if user does not want to stake\n            IERC20( ROME ).transfer( _recipient, _amount ); // send payout\n        } else { // if user wants to stake\n            if ( useHelper ) { // use if staking warmup is 0\n                IERC20( ROME ).approve( stakingHelper, _amount );\n                IStakingHelper( stakingHelper ).stake( _amount, _recipient );\n            } else {\n                IERC20( ROME ).approve( staking, _amount );\n                IStaking( staking ).stake( _amount, _recipient );\n            }\n        }\n        return _amount;\n    }\n\n    /**\n     *  @notice makes incremental adjustment to control variable\n     */\n    function adjust() internal {\n        uint blockCanAdjust = adjustment.lastBlock.add( adjustment.buffer );\n        if( adjustment.rate != 0 && block.number >= blockCanAdjust ) {\n            uint initial = terms.controlVariable;\n            if ( adjustment.add ) {\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\n                if ( terms.controlVariable >= adjustment.target ) {\n                    adjustment.rate = 0;\n                }\n            } else {\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\n                if ( terms.controlVariable <= adjustment.target ) {\n                    adjustment.rate = 0;\n                }\n            }\n            adjustment.lastBlock = block.number;\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\n        }\n    }\n\n    /**\n     *  @notice reduce total debt\n     */\n    function decayDebt() internal {\n        totalDebt = totalDebt.sub( debtDecay() );\n        lastDecay = block.number;\n    }\n\n\n\n\n    /* ======== VIEW FUNCTIONS ======== */\n\n    /**\n     *  @notice determine maximum bond size\n     *  @return uint\n     */\n    function maxPayout() public view returns ( uint ) {\n        return IERC20( ROME ).totalSupply().mul( terms.maxPayout ).div( 100000 );\n    }\n\n    /**\n     *  @notice calculate interest due for new bond\n     *  @param _value uint\n     *  @return uint\n     */\n    function payoutFor( uint _value ) public view returns ( uint ) {\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e14 );\n    }\n\n\n    /**\n     *  @notice calculate current bond premium\n     *  @return price_ uint\n     */\n    function bondPrice() public view returns ( uint price_ ) {        \n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\n        if ( price_ < terms.minimumPrice ) {\n            price_ = terms.minimumPrice;\n        }\n    }\n\n    /**\n     *  @notice calculate current bond price and remove floor if above\n     *  @return price_ uint\n     */\n    function _bondPrice() internal returns ( uint price_ ) {\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\n        if ( price_ < terms.minimumPrice ) {\n            price_ = terms.minimumPrice;        \n        } else if ( terms.minimumPrice != 0 ) {\n            terms.minimumPrice = 0;\n        }\n    }\n\n    /**\n     *  @notice get asset price from chainlink\n     */\n    function assetPrice() public view returns (int) {\n        ( , int price, , , ) = priceFeed.latestRoundData();\n        return price;\n    }\n\n    /**\n     *  @notice converts bond price to DAI value\n     *  @return price_ uint\n     */\n    function bondPriceInUSD() public view returns ( uint price_ ) {\n        if (bondCalculator == address(0)) {\n            price_ = bondPrice().mul( uint( assetPrice() ) ).mul( 1e6 );\n        } else {\n            price_ = bondPrice()\n                    .mul( IBondCalculator( bondCalculator ).markdown( principle ) )\n                    .mul( uint( assetPrice() ) )\n                    .div( 1e12 );\n        }\n    }\n\n\n    /**\n     *  @notice calculate current ratio of debt to ROME supply\n     *  @return debtRatio_ uint\n     */\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \n        debtRatio_ = FixedPoint.fraction(\n            currentDebt().mul( 1e9 ),\n            IERC20( ROME ).totalSupply()\n        ).decode112with18().div( 1e18 );\n    }\n\n\n    /**\n     *  @notice debt ratio in same terms as reserve bonds\n     *  @return uint\n     */\n    function standardizedDebtRatio() external view returns ( uint ) {\n        if (bondCalculator == address(0)) {\n            return debtRatio().mul( uint( assetPrice() ) ).div( 1e8 ); // ETH feed is 8 decimals\n        } else {\n            return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\n        }\n    }\n\n    /**\n     *  @notice calculate debt factoring in decay\n     *  @return uint\n     */\n    function currentDebt() public view returns ( uint ) {\n        return totalDebt.sub( debtDecay() );\n    }\n\n    /**\n     *  @notice amount to decay total debt by\n     *  @return decay_ uint\n     */\n    function debtDecay() public view returns ( uint decay_ ) {\n        uint blocksSinceLast = block.number.sub( lastDecay );\n        decay_ = totalDebt.mul( blocksSinceLast ).div( terms.vestingTerm );\n        if ( decay_ > totalDebt ) {\n            decay_ = totalDebt;\n        }\n    }\n\n\n    /**\n     *  @notice calculate how far into vesting a depositor is\n     *  @param _depositor address\n     *  @return percentVested_ uint\n     */\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\n        Bond memory bond = bondInfo[ _depositor ];\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\n        uint vesting = bond.vesting;\n\n        if ( vesting > 0 ) {\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\n        } else {\n            percentVested_ = 0;\n        }\n    }\n\n    /**\n     *  @notice calculate amount of ROME available for claim by depositor\n     *  @param _depositor address\n     *  @return pendingPayout_ uint\n     */\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\n        uint percentVested = percentVestedFor( _depositor );\n        uint payout = bondInfo[ _depositor ].payout;\n\n        if ( percentVested >= 10000 ) {\n            pendingPayout_ = payout;\n        } else {\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\n        }\n    }\n\n\n\n\n    /* ======= AUXILLIARY ======= */\n\n    /**\n     *  @notice allow anyone to send lost tokens (excluding principle or ROME) to the WARCHEST\n     *  @return bool\n     */\n    function recoverLostToken( address _token ) external returns ( bool ) {\n        require( _token != ROME );\n        require( _token != principle );\n        IERC20( _token ).safeTransfer( WARCHEST, IERC20( _token ).balanceOf( address(this) ) );\n        return true;\n    }\n}\n"
    },
    "src/Staking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"./libraries/SafeERC20.sol\";\n\nimport \"./types/Policy.sol\";\nimport \"hardhat/console.sol\";\n\ninterface IsROME {\n    function rebase(uint256 romeProfit_, uint256 epoch_) external returns (uint256);\n\n    function circulatingSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function gonsForBalance(uint256 amount) external view returns (uint256);\n\n    function balanceForGons(uint256 gons) external view returns (uint256);\n\n    function index() external view returns (uint256);\n}\n\ninterface IWarmup {\n    function retrieve(address staker_, uint256 amount_) external;\n}\n\ninterface IDistributor {\n    function distribute() external returns (bool);\n}\n\ncontract RomeStaking is Policy {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address public immutable ROME;\n    address public immutable sROME;\n\n    struct Epoch {\n        uint256 length;\n        uint256 number;\n        uint256 endBlock;\n        uint256 distribute;\n    }\n    Epoch public epoch;\n\n    address public distributor;\n\n    address public locker;\n    uint256 public totalBonus;\n\n    address public warmupContract;\n    uint256 public warmupPeriod;\n\n    constructor(\n        address _ROME,\n        address _sROME,\n        uint256 _epochLength,\n        uint256 _firstEpochNumber,\n        uint256 _firstEpochBlock\n    ) {\n        require(_ROME != address(0));\n        ROME = _ROME;\n        require(_sROME != address(0));\n        sROME = _sROME;\n\n        epoch = Epoch({length: _epochLength, number: _firstEpochNumber, endBlock: _firstEpochBlock, distribute: 0});\n    }\n\n    struct Claim {\n        uint256 deposit;\n        uint256 gons;\n        uint256 expiry;\n        bool lock; // prevents malicious delays\n    }\n    mapping(address => Claim) public warmupInfo;\n\n    /**\n        @notice stake ROME to enter warmup\n        @param _amount uint\n        @return bool\n     */\n    function stake(uint256 _amount, address _recipient) external returns (bool) {\n        console.log(\"balance before rebasing ==> %s\", contractBalance());\n\n        rebase();\n\n        console.log(\"balance after rebasing ==> %s\", contractBalance());\n\n        IERC20(ROME).safeTransferFrom(msg.sender, address(this), _amount);\n\n        Claim memory info = warmupInfo[_recipient];\n        require(!info.lock, \"Deposits for account are locked\");\n\n        warmupInfo[_recipient] = Claim({\n            deposit: info.deposit.add(_amount),\n            gons: info.gons.add(IsROME(sROME).gonsForBalance(_amount)),\n            expiry: epoch.number.add(warmupPeriod),\n            lock: false\n        });\n\n        IERC20(sROME).safeTransfer(warmupContract, _amount);\n        return true;\n    }\n\n    /**\n        @notice retrieve sROME from warmup\n        @param _recipient address\n     */\n    function claim(address _recipient) public {\n        Claim memory info = warmupInfo[_recipient];\n        if (epoch.number >= info.expiry && info.expiry != 0) {\n            delete warmupInfo[_recipient];\n            IWarmup(warmupContract).retrieve(_recipient, IsROME(sROME).balanceForGons(info.gons));\n        }\n    }\n\n    /**\n        @notice forfeit sROME in warmup and retrieve ROME\n     */\n    function forfeit() external {\n        Claim memory info = warmupInfo[msg.sender];\n        delete warmupInfo[msg.sender];\n\n        IWarmup(warmupContract).retrieve(address(this), IsROME(sROME).balanceForGons(info.gons));\n        IERC20(ROME).safeTransfer(msg.sender, info.deposit);\n    }\n\n    /**\n        @notice prevent new deposits to address (protection from malicious activity)\n     */\n    function toggleDepositLock() external {\n        warmupInfo[msg.sender].lock = !warmupInfo[msg.sender].lock;\n    }\n\n    /**\n        @notice redeem sROME for ROME\n        @param _amount uint\n        @param _trigger bool\n     */\n    function unstake(uint256 _amount, bool _trigger) external {\n        console.log(\"entering unstaking\");\n\n        if (_trigger) {\n            console.log(\"entering rebase trigger\");\n            rebase();\n        }\n\n        console.log(\"entering transfering sROME\");\n        IERC20(sROME).safeTransferFrom(msg.sender, address(this), _amount);\n\n        console.log(\"entering transfering ROME\");\n        IERC20(ROME).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n        @notice returns the sROME index, which tracks rebase growth\n        @return uint\n     */\n    function index() public view returns (uint256) {\n        return IsROME(sROME).index();\n    }\n\n    /**\n        @notice trigger rebase if epoch over\n     */\n    function rebase() public {\n        if (epoch.endBlock <= block.number) {\n            console.log(\"check 1 Staking\");\n            IsROME(sROME).rebase(epoch.distribute, epoch.number);\n\n            epoch.endBlock = epoch.endBlock.add(epoch.length);\n            epoch.number++;\n\n            if (distributor != address(0)) {\n                IDistributor(distributor).distribute();\n            }\n\n            console.log(\"check 2 Staking\");\n            uint256 balance = contractBalance();\n            console.log(\"balance Staking ==> %s\", balance);\n            console.log(\"check 3 Staking\");\n            uint256 staked = IsROME(sROME).circulatingSupply();\n            console.log(\"staked Staking ==> %s\", balance);\n\n            console.log(\"balance => %s\", balance);\n            console.log(\"staked => %s\", staked);\n\n            if (balance <= staked) {\n                epoch.distribute = 0;\n            } else {\n                epoch.distribute = balance.sub(staked);\n            }\n        }\n    }\n\n    /**\n        @notice returns contract ROME holdings, including bonuses provided\n        @return uint\n     */\n    function contractBalance() public view returns (uint256) {\n        return IERC20(ROME).balanceOf(address(this)).add(totalBonus);\n    }\n\n    /**\n        @notice provide bonus to locked staking contract\n        @param _amount uint\n     */\n    function giveLockBonus(uint256 _amount) external {\n        require(msg.sender == locker);\n        totalBonus = totalBonus.add(_amount);\n        IERC20(sROME).safeTransfer(locker, _amount);\n    }\n\n    /**\n        @notice reclaim bonus from locked staking contract\n        @param _amount uint\n     */\n    function returnLockBonus(uint256 _amount) external {\n        require(msg.sender == locker);\n        totalBonus = totalBonus.sub(_amount);\n        IERC20(sROME).safeTransferFrom(locker, address(this), _amount);\n    }\n\n    enum CONTRACTS {\n        DISTRIBUTOR,\n        WARMUP,\n        LOCKER\n    }\n\n    /**\n        @notice sets the contract address for LP staking\n        @param _contract address\n     */\n    function setContract(CONTRACTS _contract, address _address) external onlyPolicy {\n        if (_contract == CONTRACTS.DISTRIBUTOR) {\n            // 0\n            distributor = _address;\n        } else if (_contract == CONTRACTS.WARMUP) {\n            // 1\n            require(warmupContract == address(0), \"Warmup cannot be set more than once\");\n            warmupContract = _address;\n        } else if (_contract == CONTRACTS.LOCKER) {\n            // 2\n            require(locker == address(0), \"Locker cannot be set more than once\");\n            locker = _address;\n        }\n    }\n\n    /**\n     * @notice set warmup period for new stakers\n     * @param _warmupPeriod uint\n     */\n    function setWarmup(uint256 _warmupPeriod) external onlyPolicy {\n        warmupPeriod = _warmupPeriod;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "src/sRomeERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"./types/ERC20Permit.sol\";\n\nimport \"./types/Policy.sol\";\nimport \"hardhat/console.sol\";\n\ncontract sRome is ERC20Permit, Policy {\n    using SafeMath for uint256;\n\n    modifier onlyStakingContract() {\n        require(msg.sender == stakingContract);\n        _;\n    }\n\n    address public stakingContract;\n    address public initializer;\n\n    event LogSupply(uint256 indexed epoch, uint256 timestamp, uint256 totalSupply);\n    event LogRebase(uint256 indexed epoch, uint256 rebase, uint256 index);\n    event LogStakingContractUpdated(address stakingContract);\n\n    struct Rebase {\n        uint256 epoch;\n        uint256 rebase; // 18 decimals\n        uint256 totalStakedBefore;\n        uint256 totalStakedAfter;\n        uint256 amountRebased;\n        uint256 index;\n        uint256 blockNumberOccured;\n    }\n    Rebase[] public rebases;\n\n    uint256 public INDEX;\n\n    uint256 private constant MAX_UINT256 = ~uint256(0);\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 5000000 * 10**9;\n\n    // TOTAL_GONS is a multiple of INITIAL_FRAGMENTS_SUPPLY so that _gonsPerFragment is an integer.\n    // Use the highest value that fits in a uint256 for max granularity.\n    uint256 private constant TOTAL_GONS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\n\n    // MAX_SUPPLY = maximum integer < (sqrt(4*TOTAL_GONS + 1) - 1) / 2\n    uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1\n\n    uint256 private _gonsPerFragment;\n    mapping(address => uint256) private _gonBalances;\n\n    mapping(address => mapping(address => uint256)) private _allowedValue;\n\n    constructor() ERC20(\"Staked Rome\", \"sROME\", 9) ERC20Permit(\"Staked Rome\") {\n        initializer = msg.sender;\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\n    }\n\n    function initialize(address stakingContract_) external returns (bool) {\n        require(msg.sender == initializer);\n        require(stakingContract_ != address(0));\n        stakingContract = stakingContract_;\n        _gonBalances[stakingContract] = TOTAL_GONS;\n\n        emit Transfer(address(0x0), stakingContract, _totalSupply);\n        emit LogStakingContractUpdated(stakingContract_);\n\n        initializer = address(0);\n        return true;\n    }\n\n    function setIndex(uint256 _INDEX) external onlyPolicy returns (bool) {\n        require(INDEX == 0);\n        INDEX = gonsForBalance(_INDEX);\n        return true;\n    }\n\n    /**\n        @notice increases sROME supply to increase staking balances relative to profit_\n        @param profit_ uint256\n        @return uint256\n     */\n    function rebase(uint256 profit_, uint256 epoch_) public onlyStakingContract returns (uint256) {\n        console.log(\"check 1 sROME\");\n        uint256 rebaseAmount;\n        uint256 circulatingSupply_ = circulatingSupply();\n\n        console.log(\"check 2 sROME\");\n        if (profit_ == 0) {\n            emit LogSupply(epoch_, block.timestamp, _totalSupply);\n            emit LogRebase(epoch_, 0, index());\n            return _totalSupply;\n        } else if (circulatingSupply_ > 0) {\n            rebaseAmount = profit_.mul(_totalSupply).div(circulatingSupply_);\n        } else {\n            rebaseAmount = profit_;\n        }\n\n        console.log(\"check 3 sROME\");\n        _totalSupply = _totalSupply.add(rebaseAmount);\n\n        if (_totalSupply > MAX_SUPPLY) {\n            _totalSupply = MAX_SUPPLY;\n        }\n\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\n\n        console.log(\"check 4 sROME\");\n        _storeRebase(circulatingSupply_, profit_, epoch_);\n\n        return _totalSupply;\n    }\n\n    /**\n        @notice emits event with data about rebase\n        @param previousCirculating_ uint\n        @param profit_ uint\n        @param epoch_ uint\n        @return bool\n     */\n    function _storeRebase(\n        uint256 previousCirculating_,\n        uint256 profit_,\n        uint256 epoch_\n    ) internal returns (bool) {\n        uint256 rebasePercent = profit_.mul(1e18).div(previousCirculating_);\n\n        rebases.push(\n            Rebase({\n                epoch: epoch_,\n                rebase: rebasePercent, // 18 decimals\n                totalStakedBefore: previousCirculating_,\n                totalStakedAfter: circulatingSupply(),\n                amountRebased: profit_,\n                index: index(),\n                blockNumberOccured: block.number\n            })\n        );\n\n        emit LogSupply(epoch_, block.timestamp, _totalSupply);\n        emit LogRebase(epoch_, rebasePercent, index());\n\n        return true;\n    }\n\n    function balanceOf(address who) public view override returns (uint256) {\n        return _gonBalances[who].div(_gonsPerFragment);\n    }\n\n    function gonsForBalance(uint256 amount) public view returns (uint256) {\n        return amount.mul(_gonsPerFragment);\n    }\n\n    function balanceForGons(uint256 gons) public view returns (uint256) {\n        return gons.div(_gonsPerFragment);\n    }\n\n    // Staking contract holds excess sROME\n    function circulatingSupply() public view returns (uint256) {\n        return _totalSupply.sub(balanceOf(stakingContract));\n    }\n\n    function index() public view returns (uint256) {\n        return balanceForGons(INDEX);\n    }\n\n    function transfer(address to, uint256 value) public override returns (bool) {\n        uint256 gonValue = value.mul(_gonsPerFragment);\n        _gonBalances[msg.sender] = _gonBalances[msg.sender].sub(gonValue);\n        _gonBalances[to] = _gonBalances[to].add(gonValue);\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function allowance(address owner_, address spender) public view override returns (uint256) {\n        return _allowedValue[owner_][spender];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public override returns (bool) {\n        console.log(\"entering substracting allowedValue\");\n        _allowedValue[from][msg.sender] = _allowedValue[from][msg.sender].sub(value);\n        emit Approval(from, msg.sender, _allowedValue[from][msg.sender]);\n\n        uint256 gonValue = gonsForBalance(value);\n        console.log(\"entering substracting gons\");\n        _gonBalances[from] = _gonBalances[from].sub(gonValue);\n        _gonBalances[to] = _gonBalances[to].add(gonValue);\n        emit Transfer(from, to, value);\n\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public override returns (bool) {\n        _allowedValue[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    // What gets called in a permit\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal virtual override {\n        _allowedValue[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public override returns (bool) {\n        _allowedValue[msg.sender][spender] = _allowedValue[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowedValue[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public override returns (bool) {\n        uint256 oldValue = _allowedValue[msg.sender][spender];\n        if (subtractedValue >= oldValue) {\n            _allowedValue[msg.sender][spender] = 0;\n        } else {\n            _allowedValue[msg.sender][spender] = oldValue.sub(subtractedValue);\n        }\n        emit Approval(msg.sender, spender, _allowedValue[msg.sender][spender]);\n        return true;\n    }\n}\n"
    },
    "src/RomeERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.7.5;\n\nimport \"./interfaces/IROME.sol\";\n\nimport \"./types/ERC20Permit.sol\";\n\nimport \"./types/RomeAccessControlled.sol\";\n\ncontract Rome is ERC20Permit, IROME, RomeAccessControlled {\n  using SafeMath for uint256;\n\n    constructor(address _authority)\n    ERC20(\"Rome\", \"ROME\", 9)\n    ERC20Permit(\"Rome\")\n    RomeAccessControlled(IRomeAuthority(_authority)) {}\n\n    function mint(address account_, uint256 amount_) external override onlyVault {\n        _mint(account_, amount_);\n    }\n\n    function burn(uint256 amount) external override {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account_, uint256 amount_) external override {\n        _burnFrom(account_, amount_);\n    }\n\n    function _burnFrom(address account_, uint256 amount_) internal {\n        uint256 decreasedAllowance_ = allowance(account_, msg.sender).sub(amount_, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account_, msg.sender, decreasedAllowance_);\n        _burn(account_, amount_);\n    }\n}\n"
    },
    "src/interfaces/IROME.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IROME is IERC20 {\n  function mint(address account_, uint256 amount_) external;\n\n  function burn(uint256 amount) external;\n\n  function burnFrom(address account_, uint256 amount_) external;\n}\n"
    },
    "src/types/RomeAccessControlled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\nimport \"../interfaces/IRomeAuthority.sol\";\n\nabstract contract RomeAccessControlled {\n\n    /* ========== EVENTS ========== */\n\n    event AuthorityUpdated(IRomeAuthority indexed authority);\n\n    string UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\n\n    /* ========== STATE VARIABLES ========== */\n\n    IRomeAuthority public authority;\n\n\n    /* ========== Constructor ========== */\n\n    constructor(IRomeAuthority _authority) {\n        authority = _authority;\n        emit AuthorityUpdated(_authority);\n    }\n    \n\n    /* ========== MODIFIERS ========== */\n    \n    modifier onlyGovernor() {\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\n        _;\n    }\n    \n    modifier onlyGuardian() {\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\n        _;\n    }\n    \n    modifier onlyPolicy() {\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\n        _;\n    }\n    \n    /* ========== GOV ONLY ========== */\n    \n    function setAuthority(IRomeAuthority _newAuthority) external onlyGovernor {\n        authority = _newAuthority;\n        emit AuthorityUpdated(_newAuthority);\n    }\n}\n"
    },
    "src/interfaces/IRomeAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\ninterface IRomeAuthority {\n    /* ========== EVENTS ========== */\n    \n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \n\n    event GovernorPulled(address indexed from, address indexed to);\n    event GuardianPulled(address indexed from, address indexed to);\n    event PolicyPulled(address indexed from, address indexed to);\n    event VaultPulled(address indexed from, address indexed to);\n\n    /* ========== VIEW ========== */\n    \n    function governor() external view returns (address);\n    function guardian() external view returns (address);\n    function policy() external view returns (address);\n    function vault() external view returns (address);\n}\n"
    },
    "src/StakingWarmup.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport './interfaces/IERC20.sol';\n\ncontract StakingWarmup {\n\n    address public immutable staking;\n    address public immutable sROME;\n\n    constructor ( address _staking, address _sROME ) {\n        require( _staking != address(0) );\n        staking = _staking;\n        require( _sROME != address(0) );\n        sROME = _sROME;\n    }\n\n    function retrieve( address _staker, uint _amount ) external {\n        require( msg.sender == staking );\n        IERC20( sROME ).transfer( _staker, _amount );\n    }\n}\n"
    },
    "src/StakingHelper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"./interfaces/IERC20.sol\";\n\ninterface IStaking {\n    function stake(uint256 _amount, address _recipient) external returns (bool);\n\n    function claim(address _recipient) external;\n}\n\ncontract StakingHelper {\n    address public immutable staking;\n    address public immutable ROME;\n\n    constructor(address _staking, address _ROME) {\n        require(_staking != address(0));\n        staking = _staking;\n        require(_ROME != address(0));\n        ROME = _ROME;\n    }\n\n    function stake(uint256 _amount, address _recipient) external {\n        IERC20(ROME).transferFrom(msg.sender, address(this), _amount);\n        IERC20(ROME).approve(staking, _amount);\n        IStaking(staking).stake(_amount, _recipient);\n        IStaking(staking).claim(_recipient);\n    }\n}\n"
    },
    "src/bonds/ROMEFRAXBondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"../types/Policy.sol\";\n\nimport \"../types/ERC20Permit.sol\";\n\nimport \"../libraries/SafeERC20.sol\";\n\nimport \"../libraries/FixedPoint.sol\";\n\nimport \"../interfaces/IERC20Metadata.sol\";\n\ninterface ITreasury {\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( bool );\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\n}\n\ninterface IBondCalculator {\n    function valuation( address _LP, uint _amount ) external view returns ( uint );\n    function markdown( address _LP ) external view returns ( uint );\n}\n\ninterface IStaking {\n    function stake( uint _amount, address _recipient ) external returns ( bool );\n}\n\ninterface IStakingHelper {\n    function stake( uint _amount, address _recipient ) external;\n}\n\ncontract ROMEFRAXBondDepository is Policy {\n\n    using FixedPoint for *;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n\n\n\n    /* ======== EVENTS ======== */\n\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\n\n\n\n\n    /* ======== STATE VARIABLES ======== */\n\n    address public immutable ROME; // token given as payment for bond\n    address public immutable principle; // token used to create bond\n    address public immutable treasury; // mints ROME when receives principle\n    address public immutable WARCHEST; // receives fee from principle\n\n    bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\n    address public immutable bondCalculator; // calculates value of LP tokens\n\n    address public staking; // to auto-stake payout\n    address public stakingHelper; // to stake and claim if no staking warmup\n    bool public useHelper;\n\n    Terms public terms; // stores terms for new bonds\n    Adjust public adjustment; // stores adjustment to BCV data\n\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\n\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\n    uint public lastDecay; // reference block for debt decay\n\n    bool public isInitialized; // bool to prevent deposits before initialization\n\n\n\n\n    /* ======== STRUCTS ======== */\n\n    // Info for creating new bonds\n    struct Terms {\n        uint controlVariable; // scaling variable for price\n        uint vestingTerm; // in blocks\n        uint minimumPrice; // vs principle value\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n        uint fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)]\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n    }\n\n    // Info for bond holder\n    struct Bond {\n        uint payout; // ROME remaining to be paid\n        uint vesting; // Blocks left to vest\n        uint lastBlock; // Last interaction\n        uint pricePaid; // In DAI, for front end viewing\n    }\n\n    // Info for incremental adjustments to control variable \n    struct Adjust {\n        bool add; // addition or subtraction\n        uint rate; // increment\n        uint target; // BCV when adjustment finished\n        uint buffer; // minimum length (in blocks) between adjustments\n        uint lastBlock; // block when last adjustment made\n    }\n\n\n\n\n    /* ======== INITIALIZATION ======== */\n\n    constructor ( \n        address _ROME,\n        address _principle,\n        address _treasury, \n        address _WARCHEST,\n        address _bondCalculator\n    ) {\n        require( _ROME != address(0) );\n        ROME = _ROME;\n        require( _principle != address(0) );\n        principle = _principle;\n        require( _treasury != address(0) );\n        treasury = _treasury;\n        require( _WARCHEST != address(0) );\n        WARCHEST = _WARCHEST;\n        // bondCalculator should be address(0) if not LP bond\n        bondCalculator = _bondCalculator;\n        isLiquidityBond = ( _bondCalculator != address(0) );\n    }\n\n    /**\n     *  @notice initializes bond parameters\n     *  @param _controlVariable uint\n     *  @param _vestingTerm uint\n     *  @param _minimumPrice uint\n     *  @param _maxPayout uint\n     *  @param _fee uint\n     *  @param _maxDebt uint\n     *  @param _initialDebt uint\n     */\n    function initializeBondTerms( \n        uint _controlVariable, \n        uint _vestingTerm,\n        uint _minimumPrice,\n        uint _maxPayout,\n        uint _fee,\n        uint _maxDebt,\n        uint _initialDebt\n    ) external onlyPolicy() {\n        require( terms.controlVariable == 0, \"Bonds must be initialized from 0\" );\n        terms = Terms ({\n            controlVariable: _controlVariable,\n            vestingTerm: _vestingTerm,\n            minimumPrice: _minimumPrice,\n            maxPayout: _maxPayout,\n            fee: _fee,\n            maxDebt: _maxDebt\n        });\n        totalDebt = _initialDebt;\n        lastDecay = block.number;\n        isInitialized = true;\n    }\n\n\n\n    \n    /* ======== POLICY FUNCTIONS ======== */\n\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT }\n    /**\n     *  @notice set parameters for new bonds\n     *  @param _parameter PARAMETER\n     *  @param _input uint\n     */\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyPolicy() {\n        if ( _parameter == PARAMETER.VESTING ) { // 0\n            require( _input >= 10000, \"Vesting must be longer than 36 hours\" );\n            terms.vestingTerm = _input;\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\n            require( _input <= 1000, \"Payout cannot be above 1 percent\" );\n            terms.maxPayout = _input;\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\n            require( _input <= 10000, \"WARCHEST fee cannot exceed payout\" );\n            terms.fee = _input;\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\n            terms.maxDebt = _input;\n        }\n    }\n\n    /**\n     *  @notice set control variable adjustment\n     *  @param _addition bool\n     *  @param _increment uint\n     *  @param _target uint\n     *  @param _buffer uint\n     */\n    function setAdjustment ( \n        bool _addition,\n        uint _increment, \n        uint _target,\n        uint _buffer \n    ) external onlyPolicy() {\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \"Increment too large\" );\n\n        adjustment = Adjust({\n            add: _addition,\n            rate: _increment,\n            target: _target,\n            buffer: _buffer,\n            lastBlock: block.number\n        });\n    }\n\n    /**\n     *  @notice set contract for auto stake\n     *  @param _staking address\n     *  @param _helper bool\n     */\n    function setStaking( address _staking, bool _helper ) external onlyPolicy() {\n        require( _staking != address(0) );\n        if ( _helper ) {\n            useHelper = true;\n            stakingHelper = _staking;\n        } else {\n            useHelper = false;\n            staking = _staking;\n        }\n    }\n\n\n    \n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice deposit bond\n     *  @param _amount uint\n     *  @param _maxPrice uint\n     *  @param _depositor address\n     *  @return uint\n     */\n    function deposit( \n        uint _amount, \n        uint _maxPrice,\n        address _depositor\n    ) external returns ( uint ) {\n        require(isInitialized, \"Bonds Not Initalized\");\n        require( _depositor != address(0), \"Invalid address\" );\n\n        decayDebt();\n        require( totalDebt <= terms.maxDebt, \"Max capacity reached\" );\n\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\n        uint nativePrice = _bondPrice();\n\n        require( _maxPrice >= nativePrice, \"Slippage limit: more than max price\" ); // slippage protection\n\n        uint value = ITreasury( treasury ).valueOf( principle, _amount );\n        uint payout = payoutFor( value ); // payout to bonder is computed\n\n        require( payout >= 10000000, \"Bond too small\" ); // must be > 0.01 ROME ( underflow protection )\n        require( payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n        // profits are calculated\n        uint fee = payout.mul( terms.fee ).div( 10000 );\n        uint profit = value.sub( payout ).sub( fee );\n\n        /**\n            principle is transferred in\n            approved and\n            deposited into the treasury, returning (_amount - profit) ROME\n         */\n        IERC20( principle ).safeTransferFrom( msg.sender, address(this), _amount );\n        IERC20( principle ).approve( address( treasury ), _amount );\n        ITreasury( treasury ).deposit( _amount, principle, profit );\n        \n        if ( fee != 0 ) { // fee is transferred to WARCHEST\n            IERC20( ROME ).safeTransfer( WARCHEST, fee );\n        }\n        \n        // total debt is increased\n        totalDebt = totalDebt.add( value ); \n                \n        // depositor info is stored\n        bondInfo[ _depositor ] = Bond({ \n            payout: bondInfo[ _depositor ].payout.add( payout ),\n            vesting: terms.vestingTerm,\n            lastBlock: block.number,\n            pricePaid: priceInUSD\n        });\n\n        // indexed events are emitted\n        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\n\n        adjust(); // control variable is adjusted\n        return payout; \n    }\n\n    /** \n     *  @notice redeem bond for user\n     *  @param _recipient address\n     *  @param _stake bool\n     *  @return uint\n     */ \n    function redeem( address _recipient, bool _stake ) external returns ( uint ) {        \n        Bond memory info = bondInfo[ _recipient ];\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\n\n        if ( percentVested >= 10000 ) { // if fully vested\n            delete bondInfo[ _recipient ]; // delete user info\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\n            return stakeOrSend( _recipient, _stake, info.payout ); // pay user everything due\n\n        } else { // if unfinished\n            // calculate payout vested\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\n\n            // store updated deposit info\n            bondInfo[ _recipient ] = Bond({\n                payout: info.payout.sub( payout ),\n                vesting: info.vesting.sub( block.number.sub( info.lastBlock ) ),\n                lastBlock: block.number,\n                pricePaid: info.pricePaid\n            });\n\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\n            return stakeOrSend( _recipient, _stake, payout );\n        }\n    }\n\n\n\n    \n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n    /**\n     *  @notice allow user to stake payout automatically\n     *  @param _stake bool\n     *  @param _amount uint\n     *  @return uint\n     */\n    function stakeOrSend( address _recipient, bool _stake, uint _amount ) internal returns ( uint ) {\n        if ( !_stake ) { // if user does not want to stake\n            IERC20( ROME ).transfer( _recipient, _amount ); // send payout\n        } else { // if user wants to stake\n            if ( useHelper ) { // use if staking warmup is 0\n                IERC20( ROME ).approve( stakingHelper, _amount );\n                IStakingHelper( stakingHelper ).stake( _amount, _recipient );\n            } else {\n                IERC20( ROME ).approve( staking, _amount );\n                IStaking( staking ).stake( _amount, _recipient );\n            }\n        }\n        return _amount;\n    }\n\n    /**\n     *  @notice makes incremental adjustment to control variable\n     */\n    function adjust() internal {\n        uint blockCanAdjust = adjustment.lastBlock.add( adjustment.buffer );\n        if( adjustment.rate != 0 && block.number >= blockCanAdjust ) {\n            uint initial = terms.controlVariable;\n            if ( adjustment.add ) {\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\n                if ( terms.controlVariable >= adjustment.target ) {\n                    adjustment.rate = 0;\n                }\n            } else {\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\n                if ( terms.controlVariable <= adjustment.target ) {\n                    adjustment.rate = 0;\n                }\n            }\n            adjustment.lastBlock = block.number;\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\n        }\n    }\n\n    /**\n     *  @notice reduce total debt\n     */\n    function decayDebt() internal {\n        totalDebt = totalDebt.sub( debtDecay() );\n        lastDecay = block.number;\n    }\n\n\n\n\n    /* ======== VIEW FUNCTIONS ======== */\n\n    /**\n     *  @notice determine maximum bond size\n     *  @return uint\n     */\n    function maxPayout() public view returns ( uint ) {\n        return IERC20( ROME ).totalSupply().mul( terms.maxPayout ).div( 100000 );\n    }\n\n    /**\n     *  @notice calculate interest due for new bond\n     *  @param _value uint\n     *  @return uint\n     */\n    function payoutFor( uint _value ) public view returns ( uint ) {\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e16 );\n    }\n\n\n    /**\n     *  @notice calculate current bond premium\n     *  @return price_ uint\n     */\n    function bondPrice() public view returns ( uint price_ ) {        \n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\n        if ( price_ < terms.minimumPrice ) {\n            price_ = terms.minimumPrice;\n        }\n    }\n\n    /**\n     *  @notice calculate current bond price and remove floor if above\n     *  @return price_ uint\n     */\n    function _bondPrice() internal returns ( uint price_ ) {\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\n        if ( price_ < terms.minimumPrice ) {\n            price_ = terms.minimumPrice;        \n        } else if ( terms.minimumPrice != 0 ) {\n            terms.minimumPrice = 0;\n        }\n    }\n\n    /**\n     *  @notice converts bond price to DAI value\n     *  @return price_ uint\n     */\n    function bondPriceInUSD() public view returns ( uint price_ ) {\n        if( isLiquidityBond ) {\n            price_ = bondPrice().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 100 );\n        } else {\n            price_ = bondPrice().mul( 10 ** IERC20Metadata( principle ).decimals() ).div( 100 );\n        }\n    }\n\n\n    /**\n     *  @notice calculate current ratio of debt to ROME supply\n     *  @return debtRatio_ uint\n     */\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \n        uint supply = IERC20( ROME ).totalSupply();\n        debtRatio_ = FixedPoint.fraction( \n            currentDebt().mul( 1e9 ), \n            supply\n        ).decode112with18().div( 1e18 );\n    }\n\n    /**\n     *  @notice debt ratio in same terms for reserve or liquidity bonds\n     *  @return uint\n     */\n    function standardizedDebtRatio() external view returns ( uint ) {\n        if ( isLiquidityBond ) {\n            return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\n        } else {\n            return debtRatio();\n        }\n    }\n\n    /**\n     *  @notice calculate debt factoring in decay\n     *  @return uint\n     */\n    function currentDebt() public view returns ( uint ) {\n        return totalDebt.sub( debtDecay() );\n    }\n\n    /**\n     *  @notice amount to decay total debt by\n     *  @return decay_ uint\n     */\n    function debtDecay() public view returns ( uint decay_ ) {\n        uint blocksSinceLast = block.number.sub( lastDecay );\n        decay_ = totalDebt.mul( blocksSinceLast ).div( terms.vestingTerm );\n        if ( decay_ > totalDebt ) {\n            decay_ = totalDebt;\n        }\n    }\n\n\n    /**\n     *  @notice calculate how far into vesting a depositor is\n     *  @param _depositor address\n     *  @return percentVested_ uint\n     */\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\n        Bond memory bond = bondInfo[ _depositor ];\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\n        uint vesting = bond.vesting;\n\n        if ( vesting > 0 ) {\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\n        } else {\n            percentVested_ = 0;\n        }\n    }\n\n    /**\n     *  @notice calculate amount of ROME available for claim by depositor\n     *  @param _depositor address\n     *  @return pendingPayout_ uint\n     */\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\n        uint percentVested = percentVestedFor( _depositor );\n        uint payout = bondInfo[ _depositor ].payout;\n\n        if ( percentVested >= 10000 ) {\n            pendingPayout_ = payout;\n        } else {\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\n        }\n    }\n\n\n\n\n    /* ======= AUXILLIARY ======= */\n\n    /**\n     *  @notice allow anyone to send lost tokens (excluding principle or ROME) to the WARCHEST\n     *  @return bool\n     */\n    function recoverLostToken( address _token ) external returns ( bool ) {\n        require( _token != ROME );\n        require( _token != principle );\n        IERC20( _token ).safeTransfer( WARCHEST, IERC20( _token ).balanceOf( address(this) ) );\n        return true;\n    }\n}\n"
    },
    "src/bonds/MOVRBondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"../types/Policy.sol\";\n\nimport \"../types/ERC20Permit.sol\";\n\nimport \"../libraries/SafeERC20.sol\";\n\nimport \"../libraries/FixedPoint.sol\";\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n\ninterface ITreasury {\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( bool );\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\n    function mintRewards( address _recipient, uint _amount ) external;\n}\n\ninterface IBondCalculator {\n    function valuation( address _LP, uint _amount ) external view returns ( uint );\n    function markdown( address _LP ) external view returns ( uint );\n}\n\ninterface IStaking {\n    function stake( uint _amount, address _recipient ) external returns ( bool );\n}\n\ninterface IStakingHelper {\n    function stake( uint _amount, address _recipient ) external;\n}\n\ncontract MOVRBondDepository is Policy {\n\n    using FixedPoint for *;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n\n\n\n    /* ======== EVENTS ======== */\n\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\n\n\n\n\n    /* ======== STATE VARIABLES ======== */\n\n    address public immutable ROME; // token given as payment for bond\n    address public immutable principle; // token used to create bond\n    address public immutable treasury; // mints ROME when receives principle\n    address public immutable WARCHEST; // receives fee share from bond\n\n    address public immutable bondCalculator; // calculates value of LP tokens\n\n    AggregatorV3Interface internal priceFeed;\n\n    address public staking; // to auto-stake payout\n    address public stakingHelper; // to stake and claim if no staking warmup\n    bool public useHelper;\n\n    Terms public terms; // stores terms for new bonds\n    Adjust public adjustment; // stores adjustment to BCV data\n\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\n\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\n    uint public lastDecay; // reference block for debt decay\n\n    bool public isInitialized; // bool to prevent deposits before initialization\n\n\n    /* ======== STRUCTS ======== */\n\n    // Info for creating new bonds\n    struct Terms {\n        uint controlVariable; // scaling variable for price\n        uint vestingTerm; // in blocks\n        uint minimumPrice; // vs principle value. 4 decimals (1500 = 0.15)\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n        uint fee; // as % of bond principle, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)]\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n    }\n\n    // Info for bond holder\n    struct Bond {\n        uint payout; // ROME remaining to be paid\n        uint vesting; // Blocks left to vest\n        uint lastBlock; // Last interaction\n        uint pricePaid; // In DAI, for front end viewing\n    }\n\n    // Info for incremental adjustments to control variable \n    struct Adjust {\n        bool add; // addition or subtraction\n        uint rate; // increment\n        uint target; // BCV when adjustment finished\n        uint buffer; // minimum length (in blocks) between adjustments\n        uint lastBlock; // block when last adjustment made\n    }\n\n\n\n\n    /* ======== INITIALIZATION ======== */\n\n    constructor ( \n        address _ROME,\n        address _principle,\n        address _treasury, \n        address _WARCHEST,\n        address _bondCalculator,\n        address _feed\n    ) {\n        require( _ROME != address(0) );\n        ROME = _ROME;\n        require( _principle != address(0) );\n        principle = _principle;\n        require( _treasury != address(0) );\n        treasury = _treasury;\n        require( _WARCHEST != address(0) );\n        WARCHEST = _WARCHEST;\n        // bondCalculator should be address(0) if not LP bond\n        bondCalculator = _bondCalculator;\n        priceFeed = AggregatorV3Interface( _feed );\n    }\n\n    /**\n     *  @notice initializes bond parameters\n     *  @param _controlVariable uint\n     *  @param _vestingTerm uint\n     *  @param _minimumPrice uint\n     *  @param _maxPayout uint\n     *  @param _maxDebt uint\n     *  @param _initialDebt uint\n     */\n    function initializeBondTerms( \n        uint _controlVariable, \n        uint _vestingTerm,\n        uint _minimumPrice,\n        uint _maxPayout,\n        uint _fee,\n        uint _maxDebt,\n        uint _initialDebt\n    ) external onlyPolicy() {\n        require( terms.controlVariable == 0, \"Bonds must be initialized from 0\" );\n        terms = Terms ({\n            controlVariable: _controlVariable,\n            vestingTerm: _vestingTerm,\n            minimumPrice: _minimumPrice,\n            maxPayout: _maxPayout,\n            fee: _fee,\n            maxDebt: _maxDebt\n        });\n        totalDebt = _initialDebt;\n        lastDecay = block.number;\n        isInitialized = true;\n    }\n\n\n\n    \n    /* ======== POLICY FUNCTIONS ======== */\n\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT }\n    /**\n     *  @notice set parameters for new bonds\n     *  @param _parameter PARAMETER\n     *  @param _input uint\n     */\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyPolicy() {\n        if ( _parameter == PARAMETER.VESTING ) { // 0\n            require( _input >= 10000, \"Vesting must be longer than 36 hours\" );\n            terms.vestingTerm = _input;\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\n            require( _input <= 1000, \"Payout cannot be above 1 percent\" );\n            terms.maxPayout = _input;\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\n            require( _input <= 10000, \"WARCHEST fee cannot exceed payout\" );\n            terms.fee = _input;\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\n            terms.maxDebt = _input;\n        }\n    }\n\n    /**\n     *  @notice set control variable adjustment\n     *  @param _addition bool\n     *  @param _increment uint\n     *  @param _target uint\n     *  @param _buffer uint\n     */\n    function setAdjustment ( \n        bool _addition,\n        uint _increment, \n        uint _target,\n        uint _buffer \n    ) external onlyPolicy() {\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \"Increment too large\" );\n\n        adjustment = Adjust({\n            add: _addition,\n            rate: _increment,\n            target: _target,\n            buffer: _buffer,\n            lastBlock: block.number\n        });\n    }\n\n    /**\n     *  @notice set contract for auto stake\n     *  @param _staking address\n     *  @param _helper bool\n     */\n    function setStaking( address _staking, bool _helper ) external onlyPolicy() {\n        require( _staking != address(0) );\n        if ( _helper ) {\n            useHelper = true;\n            stakingHelper = _staking;\n        } else {\n            useHelper = false;\n            staking = _staking;\n        }\n    }\n\n\n    \n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice deposit bond\n     *  @param _amount uint\n     *  @param _maxPrice uint\n     *  @param _depositor address\n     *  @return uint\n     */\n    function deposit( \n        uint _amount, \n        uint _maxPrice,\n        address _depositor\n    ) external returns ( uint ) {\n        require(isInitialized, \"Bonds Not Initalized\");\n        require( _depositor != address(0), \"Invalid address\" );\n\n        decayDebt();\n        require( totalDebt <= terms.maxDebt, \"Max capacity reached\" );\n\n        // feees are calculated\n        uint fee = _amount.mul( terms.fee ).div( 10000 );\n        _amount = _amount.sub( fee );\n\n        if ( fee != 0 ) { // fee is transferred to warchest\n            IERC20( principle ).safeTransfer( WARCHEST, fee );\n        }\n        \n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\n        uint nativePrice = _bondPrice();\n\n        require( _maxPrice >= nativePrice, \"Slippage limit: more than max price\" ); // slippage protection\n\n        uint value = ITreasury( treasury ).valueOf( principle, _amount );\n        uint payout = payoutFor( value ); // payout to bonder is computed\n\n        require( payout >= 10000000, \"Bond too small\" ); // must be > 0.01 ROME ( underflow protection )\n        require( payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n        /**\n            asset carries risk and is not minted against\n            asset transfered to treasury and rewards minted as payout\n         */\n        IERC20( principle ).safeTransferFrom( msg.sender, treasury, _amount );\n        ITreasury( treasury ).mintRewards( address(this), payout );\n        \n        // total debt is increased\n        totalDebt = totalDebt.add( value ); \n                \n        // depositor info is stored\n        bondInfo[ _depositor ] = Bond({ \n            payout: bondInfo[ _depositor ].payout.add( payout ),\n            vesting: terms.vestingTerm,\n            lastBlock: block.number,\n            pricePaid: priceInUSD\n        });\n\n        // indexed events are emitted\n        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\n\n        adjust(); // control variable is adjusted\n        return payout; \n    }\n\n    /** \n     *  @notice redeem bond for user\n     *  @param _recipient address\n     *  @param _stake bool\n     *  @return uint\n     */ \n    function redeem( address _recipient, bool _stake ) external returns ( uint ) {        \n        Bond memory info = bondInfo[ _recipient ];\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\n\n        if ( percentVested >= 10000 ) { // if fully vested\n            delete bondInfo[ _recipient ]; // delete user info\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\n            return stakeOrSend( _recipient, _stake, info.payout ); // pay user everything due\n\n        } else { // if unfinished\n            // calculate payout vested\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\n\n            // store updated deposit info\n            bondInfo[ _recipient ] = Bond({\n                payout: info.payout.sub( payout ),\n                vesting: info.vesting.sub( block.number.sub( info.lastBlock ) ),\n                lastBlock: block.number,\n                pricePaid: info.pricePaid\n            });\n\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\n            return stakeOrSend( _recipient, _stake, payout );\n        }\n    }\n\n\n\n    \n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n    /**\n     *  @notice allow user to stake payout automatically\n     *  @param _stake bool\n     *  @param _amount uint\n     *  @return uint\n     */\n    function stakeOrSend( address _recipient, bool _stake, uint _amount ) internal returns ( uint ) {\n        if ( !_stake ) { // if user does not want to stake\n            IERC20( ROME ).transfer( _recipient, _amount ); // send payout\n        } else { // if user wants to stake\n            if ( useHelper ) { // use if staking warmup is 0\n                IERC20( ROME ).approve( stakingHelper, _amount );\n                IStakingHelper( stakingHelper ).stake( _amount, _recipient );\n            } else {\n                IERC20( ROME ).approve( staking, _amount );\n                IStaking( staking ).stake( _amount, _recipient );\n            }\n        }\n        return _amount;\n    }\n\n    /**\n     *  @notice makes incremental adjustment to control variable\n     */\n    function adjust() internal {\n        uint blockCanAdjust = adjustment.lastBlock.add( adjustment.buffer );\n        if( adjustment.rate != 0 && block.number >= blockCanAdjust ) {\n            uint initial = terms.controlVariable;\n            if ( adjustment.add ) {\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\n                if ( terms.controlVariable >= adjustment.target ) {\n                    adjustment.rate = 0;\n                }\n            } else {\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\n                if ( terms.controlVariable <= adjustment.target ) {\n                    adjustment.rate = 0;\n                }\n            }\n            adjustment.lastBlock = block.number;\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\n        }\n    }\n\n    /**\n     *  @notice reduce total debt\n     */\n    function decayDebt() internal {\n        totalDebt = totalDebt.sub( debtDecay() );\n        lastDecay = block.number;\n    }\n\n\n\n\n    /* ======== VIEW FUNCTIONS ======== */\n\n    /**\n     *  @notice determine maximum bond size\n     *  @return uint\n     */\n    function maxPayout() public view returns ( uint ) {\n        return IERC20( ROME ).totalSupply().mul( terms.maxPayout ).div( 100000 );\n    }\n\n    /**\n     *  @notice calculate interest due for new bond\n     *  @param _value uint\n     *  @return uint\n     */\n    function payoutFor( uint _value ) public view returns ( uint ) {\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e14 );\n    }\n\n\n    /**\n     *  @notice calculate current bond premium\n     *  @return price_ uint\n     */\n    function bondPrice() public view returns ( uint price_ ) {        \n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\n        if ( price_ < terms.minimumPrice ) {\n            price_ = terms.minimumPrice;\n        }\n    }\n\n    /**\n     *  @notice calculate current bond price and remove floor if above\n     *  @return price_ uint\n     */\n    function _bondPrice() internal returns ( uint price_ ) {\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\n        if ( price_ < terms.minimumPrice ) {\n            price_ = terms.minimumPrice;        \n        } else if ( terms.minimumPrice != 0 ) {\n            terms.minimumPrice = 0;\n        }\n    }\n\n    /**\n     *  @notice get asset price from chainlink\n     */\n    function assetPrice() public view returns (int) {\n        ( , int price, , , ) = priceFeed.latestRoundData();\n        return price;\n    }\n\n    /**\n     *  @notice converts bond price to DAI value\n     *  @return price_ uint\n     */\n    function bondPriceInUSD() public view returns ( uint price_ ) {\n        if (bondCalculator == address(0)) {\n            price_ = bondPrice().mul( uint( assetPrice() ) ).mul( 1e6 );\n        } else {\n            price_ = bondPrice()\n                    .mul( IBondCalculator( bondCalculator ).markdown( principle ) )\n                    .mul( uint( assetPrice() ) )\n                    .div( 1e12 );\n        }\n    }\n\n\n    /**\n     *  @notice calculate current ratio of debt to ROME supply\n     *  @return debtRatio_ uint\n     */\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \n        debtRatio_ = FixedPoint.fraction(\n            currentDebt().mul( 1e9 ),\n            IERC20( ROME ).totalSupply()\n        ).decode112with18().div( 1e18 );\n    }\n\n\n    /**\n     *  @notice debt ratio in same terms as reserve bonds\n     *  @return uint\n     */\n    function standardizedDebtRatio() external view returns ( uint ) {\n        if (bondCalculator == address(0)) {\n            return debtRatio().mul( uint( assetPrice() ) ).div( 1e8 ); // ETH feed is 8 decimals\n        } else {\n            return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\n        }\n    }\n\n    /**\n     *  @notice calculate debt factoring in decay\n     *  @return uint\n     */\n    function currentDebt() public view returns ( uint ) {\n        return totalDebt.sub( debtDecay() );\n    }\n\n    /**\n     *  @notice amount to decay total debt by\n     *  @return decay_ uint\n     */\n    function debtDecay() public view returns ( uint decay_ ) {\n        uint blocksSinceLast = block.number.sub( lastDecay );\n        decay_ = totalDebt.mul( blocksSinceLast ).div( terms.vestingTerm );\n        if ( decay_ > totalDebt ) {\n            decay_ = totalDebt;\n        }\n    }\n\n\n    /**\n     *  @notice calculate how far into vesting a depositor is\n     *  @param _depositor address\n     *  @return percentVested_ uint\n     */\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\n        Bond memory bond = bondInfo[ _depositor ];\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\n        uint vesting = bond.vesting;\n\n        if ( vesting > 0 ) {\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\n        } else {\n            percentVested_ = 0;\n        }\n    }\n\n    /**\n     *  @notice calculate amount of ROME available for claim by depositor\n     *  @param _depositor address\n     *  @return pendingPayout_ uint\n     */\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\n        uint percentVested = percentVestedFor( _depositor );\n        uint payout = bondInfo[ _depositor ].payout;\n\n        if ( percentVested >= 10000 ) {\n            pendingPayout_ = payout;\n        } else {\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\n        }\n    }\n\n\n\n\n    /* ======= AUXILLIARY ======= */\n\n    /**\n     *  @notice allow anyone to send lost tokens (excluding principle or ROME) to the WARCHEST\n     *  @return bool\n     */\n    function recoverLostToken( address _token ) external returns ( bool ) {\n        require( _token != ROME );\n        require( _token != principle );\n        IERC20( _token ).safeTransfer( WARCHEST, IERC20( _token ).balanceOf( address(this) ) );\n        return true;\n    }\n}\n"
    },
    "src/bonds/MIMBondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"../types/Policy.sol\";\n\nimport \"../types/ERC20Permit.sol\";\n\nimport \"../libraries/SafeERC20.sol\";\n\nimport \"../libraries/FixedPoint.sol\";\n\nimport \"../interfaces/IERC20Metadata.sol\";\n\ninterface ITreasury {\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( bool );\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\n}\n\ninterface IBondCalculator {\n    function valuation( address _LP, uint _amount ) external view returns ( uint );\n    function markdown( address _LP ) external view returns ( uint );\n}\n\ninterface IStaking {\n    function stake( uint _amount, address _recipient ) external returns ( bool );\n}\n\ninterface IStakingHelper {\n    function stake( uint _amount, address _recipient ) external;\n}\n\ncontract MIMBondDepository is Policy {\n\n    using FixedPoint for *;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n\n\n\n    /* ======== EVENTS ======== */\n\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\n\n\n\n\n    /* ======== STATE VARIABLES ======== */\n\n    address public immutable ROME; // token given as payment for bond\n    address public immutable principle; // token used to create bond\n    address public immutable treasury; // mints ROME when receives principle\n    address public immutable WARCHEST; // receives fee from principle\n\n    bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\n    address public immutable bondCalculator; // calculates value of LP tokens\n\n    address public staking; // to auto-stake payout\n    address public stakingHelper; // to stake and claim if no staking warmup\n    bool public useHelper;\n\n    Terms public terms; // stores terms for new bonds\n    Adjust public adjustment; // stores adjustment to BCV data\n\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\n\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\n    uint public lastDecay; // reference block for debt decay\n\n    bool public isInitialized; // bool to prevent deposits before initialization\n\n\n\n\n    /* ======== STRUCTS ======== */\n\n    // Info for creating new bonds\n    struct Terms {\n        uint controlVariable; // scaling variable for price\n        uint vestingTerm; // in blocks\n        uint minimumPrice; // vs principle value\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n        uint fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)]\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n    }\n\n    // Info for bond holder\n    struct Bond {\n        uint payout; // ROME remaining to be paid\n        uint vesting; // Blocks left to vest\n        uint lastBlock; // Last interaction\n        uint pricePaid; // In DAI, for front end viewing\n    }\n\n    // Info for incremental adjustments to control variable \n    struct Adjust {\n        bool add; // addition or subtraction\n        uint rate; // increment\n        uint target; // BCV when adjustment finished\n        uint buffer; // minimum length (in blocks) between adjustments\n        uint lastBlock; // block when last adjustment made\n    }\n\n\n\n\n    /* ======== INITIALIZATION ======== */\n\n    constructor ( \n        address _ROME,\n        address _principle,\n        address _treasury, \n        address _WARCHEST,\n        address _bondCalculator\n    ) {\n        require( _ROME != address(0) );\n        ROME = _ROME;\n        require( _principle != address(0) );\n        principle = _principle;\n        require( _treasury != address(0) );\n        treasury = _treasury;\n        require( _WARCHEST != address(0) );\n        WARCHEST = _WARCHEST;\n        // bondCalculator should be address(0) if not LP bond\n        bondCalculator = _bondCalculator;\n        isLiquidityBond = ( _bondCalculator != address(0) );\n    }\n\n    /**\n     *  @notice initializes bond parameters\n     *  @param _controlVariable uint\n     *  @param _vestingTerm uint\n     *  @param _minimumPrice uint\n     *  @param _maxPayout uint\n     *  @param _fee uint\n     *  @param _maxDebt uint\n     *  @param _initialDebt uint\n     */\n    function initializeBondTerms( \n        uint _controlVariable, \n        uint _vestingTerm,\n        uint _minimumPrice,\n        uint _maxPayout,\n        uint _fee,\n        uint _maxDebt,\n        uint _initialDebt\n    ) external onlyPolicy() {\n        require( terms.controlVariable == 0, \"Bonds must be initialized from 0\" );\n        terms = Terms ({\n            controlVariable: _controlVariable,\n            vestingTerm: _vestingTerm,\n            minimumPrice: _minimumPrice,\n            maxPayout: _maxPayout,\n            fee: _fee,\n            maxDebt: _maxDebt\n        });\n        totalDebt = _initialDebt;\n        lastDecay = block.number;\n        isInitialized = true;\n    }\n\n\n\n    \n    /* ======== POLICY FUNCTIONS ======== */\n\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT }\n    /**\n     *  @notice set parameters for new bonds\n     *  @param _parameter PARAMETER\n     *  @param _input uint\n     */\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyPolicy() {\n        if ( _parameter == PARAMETER.VESTING ) { // 0\n            require( _input >= 10000, \"Vesting must be longer than 36 hours\" );\n            terms.vestingTerm = _input;\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\n            require( _input <= 1000, \"Payout cannot be above 1 percent\" );\n            terms.maxPayout = _input;\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\n            require( _input <= 10000, \"WARCHEST fee cannot exceed payout\" );\n            terms.fee = _input;\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\n            terms.maxDebt = _input;\n        }\n    }\n\n    /**\n     *  @notice set control variable adjustment\n     *  @param _addition bool\n     *  @param _increment uint\n     *  @param _target uint\n     *  @param _buffer uint\n     */\n    function setAdjustment ( \n        bool _addition,\n        uint _increment, \n        uint _target,\n        uint _buffer \n    ) external onlyPolicy() {\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \"Increment too large\" );\n\n        adjustment = Adjust({\n            add: _addition,\n            rate: _increment,\n            target: _target,\n            buffer: _buffer,\n            lastBlock: block.number\n        });\n    }\n\n    /**\n     *  @notice set contract for auto stake\n     *  @param _staking address\n     *  @param _helper bool\n     */\n    function setStaking( address _staking, bool _helper ) external onlyPolicy() {\n        require( _staking != address(0) );\n        if ( _helper ) {\n            useHelper = true;\n            stakingHelper = _staking;\n        } else {\n            useHelper = false;\n            staking = _staking;\n        }\n    }\n\n\n    \n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice deposit bond\n     *  @param _amount uint\n     *  @param _maxPrice uint\n     *  @param _depositor address\n     *  @return uint\n     */\n    function deposit( \n        uint _amount, \n        uint _maxPrice,\n        address _depositor\n    ) external returns ( uint ) {\n        require(isInitialized, \"Bonds Not Initalized\");\n        require( _depositor != address(0), \"Invalid address\" );\n\n        decayDebt();\n        require( totalDebt <= terms.maxDebt, \"Max capacity reached\" );\n\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\n        uint nativePrice = _bondPrice();\n\n        require( _maxPrice >= nativePrice, \"Slippage limit: more than max price\" ); // slippage protection\n\n        uint value = ITreasury( treasury ).valueOf( principle, _amount );\n        uint payout = payoutFor( value ); // payout to bonder is computed\n\n        require( payout >= 10000000, \"Bond too small\" ); // must be > 0.01 ROME ( underflow protection )\n        require( payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n        // profits are calculated\n        uint fee = payout.mul( terms.fee ).div( 10000 );\n        uint profit = value.sub( payout ).sub( fee );\n\n        /**\n            principle is transferred in\n            approved and\n            deposited into the treasury, returning (_amount - profit) ROME\n         */\n        IERC20( principle ).safeTransferFrom( msg.sender, address(this), _amount );\n        IERC20( principle ).approve( address( treasury ), _amount );\n        ITreasury( treasury ).deposit( _amount, principle, profit );\n        \n        if ( fee != 0 ) { // fee is transferred to WARCHEST\n            IERC20( ROME ).safeTransfer( WARCHEST, fee );\n        }\n        \n        // total debt is increased\n        totalDebt = totalDebt.add( value ); \n                \n        // depositor info is stored\n        bondInfo[ _depositor ] = Bond({ \n            payout: bondInfo[ _depositor ].payout.add( payout ),\n            vesting: terms.vestingTerm,\n            lastBlock: block.number,\n            pricePaid: priceInUSD\n        });\n\n        // indexed events are emitted\n        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\n\n        adjust(); // control variable is adjusted\n        return payout; \n    }\n\n    /** \n     *  @notice redeem bond for user\n     *  @param _recipient address\n     *  @param _stake bool\n     *  @return uint\n     */ \n    function redeem( address _recipient, bool _stake ) external returns ( uint ) {        \n        Bond memory info = bondInfo[ _recipient ];\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\n\n        if ( percentVested >= 10000 ) { // if fully vested\n            delete bondInfo[ _recipient ]; // delete user info\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\n            return stakeOrSend( _recipient, _stake, info.payout ); // pay user everything due\n\n        } else { // if unfinished\n            // calculate payout vested\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\n\n            // store updated deposit info\n            bondInfo[ _recipient ] = Bond({\n                payout: info.payout.sub( payout ),\n                vesting: info.vesting.sub( block.number.sub( info.lastBlock ) ),\n                lastBlock: block.number,\n                pricePaid: info.pricePaid\n            });\n\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\n            return stakeOrSend( _recipient, _stake, payout );\n        }\n    }\n\n\n\n    \n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n    /**\n     *  @notice allow user to stake payout automatically\n     *  @param _stake bool\n     *  @param _amount uint\n     *  @return uint\n     */\n    function stakeOrSend( address _recipient, bool _stake, uint _amount ) internal returns ( uint ) {\n        if ( !_stake ) { // if user does not want to stake\n            IERC20( ROME ).transfer( _recipient, _amount ); // send payout\n        } else { // if user wants to stake\n            if ( useHelper ) { // use if staking warmup is 0\n                IERC20( ROME ).approve( stakingHelper, _amount );\n                IStakingHelper( stakingHelper ).stake( _amount, _recipient );\n            } else {\n                IERC20( ROME ).approve( staking, _amount );\n                IStaking( staking ).stake( _amount, _recipient );\n            }\n        }\n        return _amount;\n    }\n\n    /**\n     *  @notice makes incremental adjustment to control variable\n     */\n    function adjust() internal {\n        uint blockCanAdjust = adjustment.lastBlock.add( adjustment.buffer );\n        if( adjustment.rate != 0 && block.number >= blockCanAdjust ) {\n            uint initial = terms.controlVariable;\n            if ( adjustment.add ) {\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\n                if ( terms.controlVariable >= adjustment.target ) {\n                    adjustment.rate = 0;\n                }\n            } else {\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\n                if ( terms.controlVariable <= adjustment.target ) {\n                    adjustment.rate = 0;\n                }\n            }\n            adjustment.lastBlock = block.number;\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\n        }\n    }\n\n    /**\n     *  @notice reduce total debt\n     */\n    function decayDebt() internal {\n        totalDebt = totalDebt.sub( debtDecay() );\n        lastDecay = block.number;\n    }\n\n\n\n\n    /* ======== VIEW FUNCTIONS ======== */\n\n    /**\n     *  @notice determine maximum bond size\n     *  @return uint\n     */\n    function maxPayout() public view returns ( uint ) {\n        return IERC20( ROME ).totalSupply().mul( terms.maxPayout ).div( 100000 );\n    }\n\n    /**\n     *  @notice calculate interest due for new bond\n     *  @param _value uint\n     *  @return uint\n     */\n    function payoutFor( uint _value ) public view returns ( uint ) {\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e16 );\n    }\n\n\n    /**\n     *  @notice calculate current bond premium\n     *  @return price_ uint\n     */\n    function bondPrice() public view returns ( uint price_ ) {        \n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\n        if ( price_ < terms.minimumPrice ) {\n            price_ = terms.minimumPrice;\n        }\n    }\n\n    /**\n     *  @notice calculate current bond price and remove floor if above\n     *  @return price_ uint\n     */\n    function _bondPrice() internal returns ( uint price_ ) {\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\n        if ( price_ < terms.minimumPrice ) {\n            price_ = terms.minimumPrice;        \n        } else if ( terms.minimumPrice != 0 ) {\n            terms.minimumPrice = 0;\n        }\n    }\n\n    /**\n     *  @notice converts bond price to DAI value\n     *  @return price_ uint\n     */\n    function bondPriceInUSD() public view returns ( uint price_ ) {\n        if( isLiquidityBond ) {\n            price_ = bondPrice().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 100 );\n        } else {\n            price_ = bondPrice().mul( 10 ** IERC20Metadata( principle ).decimals() ).div( 100 );\n        }\n    }\n\n\n    /**\n     *  @notice calculate current ratio of debt to ROME supply\n     *  @return debtRatio_ uint\n     */\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \n        uint supply = IERC20( ROME ).totalSupply();\n        debtRatio_ = FixedPoint.fraction( \n            currentDebt().mul( 1e9 ), \n            supply\n        ).decode112with18().div( 1e18 );\n    }\n\n    /**\n     *  @notice debt ratio in same terms for reserve or liquidity bonds\n     *  @return uint\n     */\n    function standardizedDebtRatio() external view returns ( uint ) {\n        if ( isLiquidityBond ) {\n            return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\n        } else {\n            return debtRatio();\n        }\n    }\n\n    /**\n     *  @notice calculate debt factoring in decay\n     *  @return uint\n     */\n    function currentDebt() public view returns ( uint ) {\n        return totalDebt.sub( debtDecay() );\n    }\n\n    /**\n     *  @notice amount to decay total debt by\n     *  @return decay_ uint\n     */\n    function debtDecay() public view returns ( uint decay_ ) {\n        uint blocksSinceLast = block.number.sub( lastDecay );\n        decay_ = totalDebt.mul( blocksSinceLast ).div( terms.vestingTerm );\n        if ( decay_ > totalDebt ) {\n            decay_ = totalDebt;\n        }\n    }\n\n\n    /**\n     *  @notice calculate how far into vesting a depositor is\n     *  @param _depositor address\n     *  @return percentVested_ uint\n     */\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\n        Bond memory bond = bondInfo[ _depositor ];\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\n        uint vesting = bond.vesting;\n\n        if ( vesting > 0 ) {\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\n        } else {\n            percentVested_ = 0;\n        }\n    }\n\n    /**\n     *  @notice calculate amount of ROME available for claim by depositor\n     *  @param _depositor address\n     *  @return pendingPayout_ uint\n     */\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\n        uint percentVested = percentVestedFor( _depositor );\n        uint payout = bondInfo[ _depositor ].payout;\n\n        if ( percentVested >= 10000 ) {\n            pendingPayout_ = payout;\n        } else {\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\n        }\n    }\n\n\n\n\n    /* ======= AUXILLIARY ======= */\n\n    /**\n     *  @notice allow anyone to send lost tokens (excluding principle or ROME) to the WARCHEST\n     *  @return bool\n     */\n    function recoverLostToken( address _token ) external returns ( bool ) {\n        require( _token != ROME );\n        require( _token != principle );\n        IERC20( _token ).safeTransfer( WARCHEST, IERC20( _token ).balanceOf( address(this) ) );\n        return true;\n    }\n}\n"
    },
    "src/bonds/FRAXBondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"../types/Policy.sol\";\n\nimport \"../types/ERC20Permit.sol\";\n\nimport \"../libraries/SafeERC20.sol\";\n\nimport \"../libraries/FixedPoint.sol\";\n\nimport \"../interfaces/IERC20Metadata.sol\";\n\nimport \"hardhat/console.sol\";\n\ninterface ITreasury {\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (bool);\n\n    function valueOf(address _token, uint256 _amount) external view returns (uint256 value_);\n}\n\ninterface IBondCalculator {\n    function valuation(address _LP, uint256 _amount) external view returns (uint256);\n\n    function markdown(address _LP) external view returns (uint256);\n}\n\ninterface IStaking {\n    function stake(uint256 _amount, address _recipient) external returns (bool);\n}\n\ninterface IStakingHelper {\n    function stake(uint256 _amount, address _recipient) external;\n}\n\ncontract FRAXBondDepository is Policy {\n    using FixedPoint for *;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /* ======== EVENTS ======== */\n\n    event BondCreated(uint256 deposit, uint256 indexed payout, uint256 indexed expires, uint256 indexed priceInUSD);\n    event BondRedeemed(address indexed recipient, uint256 payout, uint256 remaining);\n    event BondPriceChanged(uint256 indexed priceInUSD, uint256 indexed internalPrice, uint256 indexed debtRatio);\n    event ControlVariableAdjustment(uint256 initialBCV, uint256 newBCV, uint256 adjustment, bool addition);\n\n    /* ======== STATE VARIABLES ======== */\n\n    address public immutable ROME; // token given as payment for bond\n    address public immutable principle; // token used to create bond\n    address public immutable treasury; // mints ROME when receives principle\n    address public immutable WARCHEST; // receives fee from principle\n\n    bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\n    address public immutable bondCalculator; // calculates value of LP tokens\n\n    address public staking; // to auto-stake payout\n    address public stakingHelper; // to stake and claim if no staking warmup\n    bool public useHelper;\n\n    Terms public terms; // stores terms for new bonds\n    Adjust public adjustment; // stores adjustment to BCV data\n\n    mapping(address => Bond) public bondInfo; // stores bond information for depositors\n\n    uint256 public totalDebt; // total value of outstanding bonds; used for pricing\n    uint256 public lastDecay; // reference block for debt decay\n\n    bool public isInitialized; // bool to prevent deposits before initialization\n\n    /* ======== STRUCTS ======== */\n\n    // Info for creating new bonds\n    struct Terms {\n        uint256 controlVariable; // scaling variable for price\n        uint256 vestingTerm; // in blocks\n        uint256 minimumPrice; // vs principle value\n        uint256 maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n        uint256 fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)]\n        uint256 maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n    }\n\n    // Info for bond holder\n    struct Bond {\n        uint256 payout; // ROME remaining to be paid\n        uint256 vesting; // Blocks left to vest\n        uint256 lastBlock; // Last interaction\n        uint256 pricePaid; // In DAI, for front end viewing\n    }\n\n    // Info for incremental adjustments to control variable\n    struct Adjust {\n        bool add; // addition or subtraction\n        uint256 rate; // increment\n        uint256 target; // BCV when adjustment finished\n        uint256 buffer; // minimum length (in blocks) between adjustments\n        uint256 lastBlock; // block when last adjustment made\n    }\n\n    /* ======== INITIALIZATION ======== */\n\n    constructor(\n        address _ROME,\n        address _principle,\n        address _treasury,\n        address _WARCHEST,\n        address _bondCalculator\n    ) {\n        require(_ROME != address(0));\n        ROME = _ROME;\n        require(_principle != address(0));\n        principle = _principle;\n        require(_treasury != address(0));\n        treasury = _treasury;\n        require(_WARCHEST != address(0));\n        WARCHEST = _WARCHEST;\n        // bondCalculator should be address(0) if not LP bond\n        bondCalculator = _bondCalculator;\n        isLiquidityBond = (_bondCalculator != address(0));\n    }\n\n    /**\n     *  @notice initializes bond parameters\n     *  @param _controlVariable uint\n     *  @param _vestingTerm uint\n     *  @param _minimumPrice uint\n     *  @param _maxPayout uint\n     *  @param _fee uint\n     *  @param _maxDebt uint\n     *  @param _initialDebt uint\n     */\n    function initializeBondTerms(\n        uint256 _controlVariable,\n        uint256 _vestingTerm,\n        uint256 _minimumPrice,\n        uint256 _maxPayout,\n        uint256 _fee,\n        uint256 _maxDebt,\n        uint256 _initialDebt\n    ) external onlyPolicy {\n        require(terms.controlVariable == 0, \"Bonds must be initialized from 0\");\n        terms = Terms({\n            controlVariable: _controlVariable,\n            vestingTerm: _vestingTerm,\n            minimumPrice: _minimumPrice,\n            maxPayout: _maxPayout,\n            fee: _fee,\n            maxDebt: _maxDebt\n        });\n        totalDebt = _initialDebt;\n        lastDecay = block.number;\n        isInitialized = true;\n    }\n\n    /* ======== POLICY FUNCTIONS ======== */\n\n    enum PARAMETER {\n        VESTING,\n        PAYOUT,\n        FEE,\n        DEBT\n    }\n\n    /**\n     *  @notice set parameters for new bonds\n     *  @param _parameter PARAMETER\n     *  @param _input uint\n     */\n    function setBondTerms(PARAMETER _parameter, uint256 _input) external onlyPolicy {\n        if (_parameter == PARAMETER.VESTING) {\n            // 0\n            require(_input >= 10000, \"Vesting must be longer than 36 hours\");\n            terms.vestingTerm = _input;\n        } else if (_parameter == PARAMETER.PAYOUT) {\n            // 1\n            require(_input <= 1000, \"Payout cannot be above 1 percent\");\n            terms.maxPayout = _input;\n        } else if (_parameter == PARAMETER.FEE) {\n            // 2\n            require(_input <= 10000, \"WARCHEST fee cannot exceed payout\");\n            terms.fee = _input;\n        } else if (_parameter == PARAMETER.DEBT) {\n            // 3\n            terms.maxDebt = _input;\n        }\n    }\n\n    /**\n     *  @notice set control variable adjustment\n     *  @param _addition bool\n     *  @param _increment uint\n     *  @param _target uint\n     *  @param _buffer uint\n     */\n    function setAdjustment(\n        bool _addition,\n        uint256 _increment,\n        uint256 _target,\n        uint256 _buffer\n    ) external onlyPolicy {\n        require(_increment <= terms.controlVariable.mul(25).div(1000), \"Increment too large\");\n\n        adjustment = Adjust({\n            add: _addition,\n            rate: _increment,\n            target: _target,\n            buffer: _buffer,\n            lastBlock: block.number\n        });\n    }\n\n    /**\n     *  @notice set contract for auto stake\n     *  @param _staking address\n     *  @param _helper bool\n     */\n    function setStaking(address _staking, bool _helper) external onlyPolicy {\n        require(_staking != address(0));\n        if (_helper) {\n            useHelper = true;\n            stakingHelper = _staking;\n        } else {\n            useHelper = false;\n            staking = _staking;\n        }\n    }\n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice deposit bond\n     *  @param _amount uint\n     *  @param _maxPrice uint\n     *  @param _depositor address\n     *  @return uint\n     */\n    function deposit(\n        uint256 _amount,\n        uint256 _maxPrice,\n        address _depositor\n    ) external returns (uint256) {\n        require(isInitialized, \"Bonds Not Initalized\");\n        require(_depositor != address(0), \"Invalid address\");\n\n        decayDebt();\n        require(totalDebt <= terms.maxDebt, \"Max capacity reached\");\n\n        uint256 priceInUSD = bondPriceInUSD(); // Stored in bond info\n        uint256 nativePrice = _bondPrice();\n\n        require(_maxPrice >= nativePrice, \"Slippage limit: more than max price\"); // slippage protection\n\n        uint256 value = ITreasury(treasury).valueOf(principle, _amount);\n        uint256 payout = payoutFor(value); // payout to bonder is computed\n\n        require(payout >= 10000000, \"Bond too small\"); // must be > 0.01 ROME ( underflow protection )\n        require(payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n        // profits are calculated\n        uint256 fee = payout.mul(terms.fee).div(10000);\n        uint256 profit = value.sub(payout).sub(fee);\n\n        /**\n            principle is transferred in\n            approved and\n            deposited into the treasury, returning (_amount - profit) ROME\n         */\n        IERC20(principle).safeTransferFrom(msg.sender, address(this), _amount);\n        IERC20(principle).approve(address(treasury), _amount);\n        ITreasury(treasury).deposit(_amount, principle, profit);\n\n        if (fee != 0) {\n            // fee is transferred to WARCHEST\n            IERC20(ROME).safeTransfer(WARCHEST, fee);\n        }\n\n        // total debt is increased\n        totalDebt = totalDebt.add(value);\n\n        // depositor info is stored\n        bondInfo[_depositor] = Bond({\n            payout: bondInfo[_depositor].payout.add(payout),\n            vesting: terms.vestingTerm,\n            lastBlock: block.number,\n            pricePaid: priceInUSD\n        });\n\n        // indexed events are emitted\n        emit BondCreated(_amount, payout, block.number.add(terms.vestingTerm), priceInUSD);\n        emit BondPriceChanged(bondPriceInUSD(), _bondPrice(), debtRatio());\n\n        adjust(); // control variable is adjusted\n        return payout;\n    }\n\n    /**\n     *  @notice redeem bond for user\n     *  @param _recipient address\n     *  @param _stake bool\n     *  @return uint\n     */\n    function redeem(address _recipient, bool _stake) external returns (uint256) {\n        Bond memory info = bondInfo[_recipient];\n        uint256 percentVested = percentVestedFor(_recipient); // (blocks since last interaction / vesting term remaining)\n\n        if (percentVested >= 10000) {\n            // if fully vested\n            delete bondInfo[_recipient]; // delete user info\n            emit BondRedeemed(_recipient, info.payout, 0); // emit bond data\n            return stakeOrSend(_recipient, _stake, info.payout); // pay user everything due\n        } else {\n            // if unfinished\n            // calculate payout vested\n            uint256 payout = info.payout.mul(percentVested).div(10000);\n\n            // store updated deposit info\n            bondInfo[_recipient] = Bond({\n                payout: info.payout.sub(payout),\n                vesting: info.vesting.sub(block.number.sub(info.lastBlock)),\n                lastBlock: block.number,\n                pricePaid: info.pricePaid\n            });\n\n            emit BondRedeemed(_recipient, payout, bondInfo[_recipient].payout);\n            return stakeOrSend(_recipient, _stake, payout);\n        }\n    }\n\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n    /**\n     *  @notice allow user to stake payout automatically\n     *  @param _stake bool\n     *  @param _amount uint\n     *  @return uint\n     */\n    function stakeOrSend(\n        address _recipient,\n        bool _stake,\n        uint256 _amount\n    ) internal returns (uint256) {\n        if (!_stake) {\n            // if user does not want to stake\n            IERC20(ROME).transfer(_recipient, _amount); // send payout\n        } else {\n            console.log(\"useHelper is ==> %s\", useHelper);\n            // if user wants to stake\n            if (useHelper) {\n                // use if staking warmup is 0\n                IERC20(ROME).approve(stakingHelper, _amount);\n                IStakingHelper(stakingHelper).stake(_amount, _recipient);\n            } else {\n                IERC20(ROME).approve(staking, _amount);\n                IStaking(staking).stake(_amount, _recipient);\n            }\n        }\n        return _amount;\n    }\n\n    /**\n     *  @notice makes incremental adjustment to control variable\n     */\n    function adjust() internal {\n        uint256 blockCanAdjust = adjustment.lastBlock.add(adjustment.buffer);\n        if (adjustment.rate != 0 && block.number >= blockCanAdjust) {\n            uint256 initial = terms.controlVariable;\n            if (adjustment.add) {\n                terms.controlVariable = terms.controlVariable.add(adjustment.rate);\n                if (terms.controlVariable >= adjustment.target) {\n                    adjustment.rate = 0;\n                }\n            } else {\n                terms.controlVariable = terms.controlVariable.sub(adjustment.rate);\n                if (terms.controlVariable <= adjustment.target) {\n                    adjustment.rate = 0;\n                }\n            }\n            adjustment.lastBlock = block.number;\n            emit ControlVariableAdjustment(initial, terms.controlVariable, adjustment.rate, adjustment.add);\n        }\n    }\n\n    /**\n     *  @notice reduce total debt\n     */\n    function decayDebt() internal {\n        totalDebt = totalDebt.sub(debtDecay());\n        lastDecay = block.number;\n    }\n\n    /* ======== VIEW FUNCTIONS ======== */\n\n    /**\n     *  @notice determine maximum bond size\n     *  @return uint\n     */\n    function maxPayout() public view returns (uint256) {\n        return IERC20(ROME).totalSupply().mul(terms.maxPayout).div(100000);\n    }\n\n    /**\n     *  @notice calculate interest due for new bond\n     *  @param _value uint\n     *  @return uint\n     */\n    function payoutFor(uint256 _value) public view returns (uint256) {\n        return FixedPoint.fraction(_value, bondPrice()).decode112with18().div(1e16);\n    }\n\n    /**\n     *  @notice calculate current bond premium\n     *  @return price_ uint\n     */\n    function bondPrice() public view returns (uint256 price_) {\n        price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(1e7);\n        if (price_ < terms.minimumPrice) {\n            price_ = terms.minimumPrice;\n        }\n    }\n\n    /**\n     *  @notice calculate current bond price and remove floor if above\n     *  @return price_ uint\n     */\n    function _bondPrice() internal returns (uint256 price_) {\n        price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(1e7);\n        if (price_ < terms.minimumPrice) {\n            price_ = terms.minimumPrice;\n        } else if (terms.minimumPrice != 0) {\n            terms.minimumPrice = 0;\n        }\n    }\n\n    /**\n     *  @notice converts bond price to DAI value\n     *  @return price_ uint\n     */\n    function bondPriceInUSD() public view returns (uint256 price_) {\n        if (isLiquidityBond) {\n            price_ = bondPrice().mul(IBondCalculator(bondCalculator).markdown(principle)).div(100);\n        } else {\n            price_ = bondPrice().mul(10**IERC20Metadata(principle).decimals()).div(100);\n        }\n    }\n\n    /**\n     *  @notice calculate current ratio of debt to ROME supply\n     *  @return debtRatio_ uint\n     */\n    function debtRatio() public view returns (uint256 debtRatio_) {\n        uint256 supply = IERC20(ROME).totalSupply();\n        debtRatio_ = FixedPoint.fraction(currentDebt().mul(1e9), supply).decode112with18().div(1e18);\n    }\n\n    /**\n     *  @notice debt ratio in same terms for reserve or liquidity bonds\n     *  @return uint\n     */\n    function standardizedDebtRatio() external view returns (uint256) {\n        if (isLiquidityBond) {\n            return debtRatio().mul(IBondCalculator(bondCalculator).markdown(principle)).div(1e9);\n        } else {\n            return debtRatio();\n        }\n    }\n\n    /**\n     *  @notice calculate debt factoring in decay\n     *  @return uint\n     */\n    function currentDebt() public view returns (uint256) {\n        return totalDebt.sub(debtDecay());\n    }\n\n    /**\n     *  @notice amount to decay total debt by\n     *  @return decay_ uint\n     */\n    function debtDecay() public view returns (uint256 decay_) {\n        uint256 blocksSinceLast = block.number.sub(lastDecay);\n        decay_ = totalDebt.mul(blocksSinceLast).div(terms.vestingTerm);\n        if (decay_ > totalDebt) {\n            decay_ = totalDebt;\n        }\n    }\n\n    /**\n     *  @notice calculate how far into vesting a depositor is\n     *  @param _depositor address\n     *  @return percentVested_ uint\n     */\n    function percentVestedFor(address _depositor) public view returns (uint256 percentVested_) {\n        Bond memory bond = bondInfo[_depositor];\n        uint256 blocksSinceLast = block.number.sub(bond.lastBlock);\n        uint256 vesting = bond.vesting;\n\n        if (vesting > 0) {\n            percentVested_ = blocksSinceLast.mul(10000).div(vesting);\n        } else {\n            percentVested_ = 0;\n        }\n    }\n\n    /**\n     *  @notice calculate amount of ROME available for claim by depositor\n     *  @param _depositor address\n     *  @return pendingPayout_ uint\n     */\n    function pendingPayoutFor(address _depositor) external view returns (uint256 pendingPayout_) {\n        uint256 percentVested = percentVestedFor(_depositor);\n        uint256 payout = bondInfo[_depositor].payout;\n\n        if (percentVested >= 10000) {\n            pendingPayout_ = payout;\n        } else {\n            pendingPayout_ = payout.mul(percentVested).div(10000);\n        }\n    }\n\n    /* ======= AUXILLIARY ======= */\n\n    /**\n     *  @notice allow anyone to send lost tokens (excluding principle or ROME) to the WARCHEST\n     *  @return bool\n     */\n    function recoverLostToken(address _token) external returns (bool) {\n        require(_token != ROME);\n        require(_token != principle);\n        IERC20(_token).safeTransfer(WARCHEST, IERC20(_token).balanceOf(address(this)));\n        return true;\n    }\n}\n"
    },
    "src/Distributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.7.5;\n\nimport './libraries/SafeERC20.sol';\n\nimport './types/Policy.sol';\n\n\ninterface ITreasury {\n    function mintRewards( address _recipient, uint _amount ) external;\n}\n\ncontract Distributor is Policy {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n    \n    \n    \n    /* ====== VARIABLES ====== */\n\n    address public immutable ROME;\n    address public immutable treasury;\n    \n    uint public immutable epochLength;\n    uint public nextEpochBlock;\n    \n    mapping( uint => Adjust ) public adjustments;\n    \n    \n    /* ====== STRUCTS ====== */\n        \n    struct Info {\n        uint rate; // in ten-thousandths ( 5000 = 0.5% )\n        address recipient;\n    }\n    Info[] public info;\n    \n    struct Adjust {\n        bool add;\n        uint rate;\n        uint target;\n    }\n    \n    \n    \n    /* ====== CONSTRUCTOR ====== */\n\n    constructor( address _treasury, address _rome, uint _epochLength, uint _nextEpochBlock ) {\n        require( _treasury != address(0) );\n        treasury = _treasury;\n        require( _rome != address(0) );\n        ROME = _rome;\n        epochLength = _epochLength;\n        nextEpochBlock = _nextEpochBlock;\n    }\n    \n    \n    \n    /* ====== PUBLIC FUNCTIONS ====== */\n    \n    /**\n        @notice send epoch reward to staking contract\n     */\n    function distribute() external returns ( bool ) {\n        if ( nextEpochBlock <= block.number ) {\n            nextEpochBlock = nextEpochBlock.add( epochLength ); // set next epoch block\n            \n            // distribute rewards to each recipient\n            for ( uint i = 0; i < info.length; i++ ) {\n                if ( info[ i ].rate > 0 ) {\n                    ITreasury( treasury ).mintRewards( // mint and send from treasury\n                        info[ i ].recipient, \n                        nextRewardAt( info[ i ].rate ) \n                    );\n                    adjust( i ); // check for adjustment\n                }\n            }\n            return true;\n        } else { \n            return false; \n        }\n    }\n    \n    \n    \n    /* ====== INTERNAL FUNCTIONS ====== */\n\n    /**\n        @notice increment reward rate for collector\n     */\n    function adjust( uint _index ) internal {\n        Adjust memory adjustment = adjustments[ _index ];\n        if ( adjustment.rate != 0 ) {\n            if ( adjustment.add ) { // if rate should increase\n                info[ _index ].rate = info[ _index ].rate.add( adjustment.rate ); // raise rate\n                if ( info[ _index ].rate >= adjustment.target ) { // if target met\n                    adjustments[ _index ].rate = 0; // turn off adjustment\n                }\n            } else { // if rate should decrease\n                info[ _index ].rate = info[ _index ].rate.sub( adjustment.rate ); // lower rate\n                if ( info[ _index ].rate <= adjustment.target ) { // if target met\n                    adjustments[ _index ].rate = 0; // turn off adjustment\n                }\n            }\n        }\n    }\n    \n    \n    \n    /* ====== VIEW FUNCTIONS ====== */\n\n    /**\n        @notice view function for next reward at given rate\n        @param _rate uint\n        @return uint\n     */\n    function nextRewardAt( uint _rate ) public view returns ( uint ) {\n        return IERC20( ROME ).totalSupply().mul( _rate ).div( 1000000 );\n    }\n\n    /**\n        @notice view function for next reward for specified address\n        @param _recipient address\n        @return uint\n     */\n    function nextRewardFor( address _recipient ) public view returns ( uint ) {\n        uint reward;\n        for ( uint i = 0; i < info.length; i++ ) {\n            if ( info[ i ].recipient == _recipient ) {\n                reward = nextRewardAt( info[ i ].rate );\n            }\n        }\n        return reward;\n    }\n    \n    \n    \n    /* ====== POLICY FUNCTIONS ====== */\n\n    /**\n        @notice adds recipient for distributions\n        @param _recipient address\n        @param _rewardRate uint\n     */\n    function addRecipient( address _recipient, uint _rewardRate ) external onlyPolicy() {\n        require( _recipient != address(0) );\n        info.push( Info({\n            recipient: _recipient,\n            rate: _rewardRate\n        }));\n    }\n\n    /**\n        @notice removes recipient for distributions\n        @param _index uint\n        @param _recipient address\n     */\n    function removeRecipient( uint _index, address _recipient ) external onlyPolicy() {\n        require( _recipient == info[ _index ].recipient );\n        info[ _index ].recipient = address(0);\n        info[ _index ].rate = 0;\n    }\n\n    /**\n        @notice set adjustment info for a collector's reward rate\n        @param _index uint\n        @param _add bool\n        @param _rate uint\n        @param _target uint\n     */\n    function setAdjustment( uint _index, bool _add, uint _rate, uint _target ) external onlyPolicy() {\n        adjustments[ _index ] = Adjust({\n            add: _add,\n            rate: _rate,\n            target: _target\n        });\n    }\n}\n"
    },
    "src/RedeemHelper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"./types/Policy.sol\";\n\ninterface IBond {\n    function redeem( address _recipient, bool _stake ) external returns ( uint );\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ );\n}\n\ncontract RedeemHelper is Policy {\n\n    address[] public bonds;\n\n    function redeemAll( address _recipient, bool _stake ) external {\n        for( uint i = 0; i < bonds.length; i++ ) {\n            if ( bonds[i] != address(0) ) {\n                if ( IBond( bonds[i] ).pendingPayoutFor( _recipient ) > 0 ) {\n                    IBond( bonds[i] ).redeem( _recipient, _stake );\n                }\n            }\n        }\n    }\n\n    function addBondContract( address _bond ) external onlyPolicy() {\n        require( _bond != address(0) );\n        bonds.push( _bond );\n    }\n\n    function removeBondContract( uint _index ) external onlyPolicy() {\n        bonds[ _index ] = address(0);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 9999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}